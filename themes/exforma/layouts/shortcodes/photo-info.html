{{- $metadata := resources.Get "js/image-metadata.js" | js.Build (dict "format" "esm") | fingerprint }}
{{- $watermark := resources.Get "js/watermark.js" | js.Build (dict "format" "esm") | fingerprint }}
<div class="mx-auto max-w-2xl p-6">
  <h2 class="mb-4 text-center text-2xl font-bold">ğŸ“¸ å›¾åƒä¿¡æ¯è¯»å–å·¥å…·</h2>
  <p class="mb-4 text-gray-600">é€‰æ‹©ä¸€å¼  JPG / PNG / HEIC å›¾ç‰‡ï¼š</p>
  <input
    type="file"
    accept="image/jpeg,image/png,image/heic"
    id="imageInput"
    class="w-full rounded-lg border border-gray-200 p-2 text-sm file:mr-4 file:rounded file:border-0 file:bg-gray-100 file:px-3 file:py-1.5 file:text-sm file:font-medium file:text-gray-700 hover:file:bg-gray-200"
  />
  <div class="mt-4 flex justify-center gap-4">
    <button id="watermarkBtn" class="rounded-lg bg-blue-500 px-4 py-2 text-sm font-medium text-white hover:bg-blue-600 disabled:cursor-not-allowed disabled:bg-gray-400" disabled>æ·»åŠ æ°´å°</button>
    <button id="downloadBtn" class="rounded-lg bg-green-500 px-4 py-2 text-sm font-medium text-white hover:bg-green-600 disabled:cursor-not-allowed disabled:bg-gray-400" disabled>ä¸‹è½½å›¾ç‰‡</button>
  </div>
  <img id="preview" class="mx-auto mb-6 hidden max-h-96 max-w-full rounded border border-gray-200" alt="å›¾åƒé¢„è§ˆ" />
  <div id="info" class="min-h-24 rounded-lg bg-gray-50 p-4 whitespace-pre-wrap text-gray-800">è¯·é€‰æ‹©å›¾åƒæ–‡ä»¶</div>
</div>

<script src="https://unpkg.com/exifr@7.1.3/dist/full.umd.js"></script>
<script type="module">
  import { getImageMetadata } from '{{ $metadata.RelPermalink }}';
  import { addWatermark } from '{{ $watermark.RelPermalink }}';

  function renderInfoList(title, data, formatter = v => v) {
    const items = Object.entries(data)
      .filter(([, v]) => v !== null && v !== undefined && v !== '')
      .map(([k, v]) => `  - ${k}ï¼š${formatter(v)}`)
      .join('\n');
    return items ? `\n${title}:\n${items}` : '';
  }

  const fileInput = document.getElementById('imageInput');
  const preview = document.getElementById('preview');
  const info = document.getElementById('info');
  const watermarkBtn = document.getElementById('watermarkBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  let currentMetadata = null;
  let currentBlobUrl = null;
  let watermarked = false;

  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) {
      info.textContent = 'è¯·é€‰æ‹©å›¾åƒæ–‡ä»¶';
      preview.classList.add('hidden');
      preview.src = '';
      watermarkBtn.disabled = true;
      downloadBtn.disabled = true;
      if (currentBlobUrl) {
        URL.revokeObjectURL(currentBlobUrl);
        currentBlobUrl = null;
      }
      return;
    }

    // é‡Šæ”¾æ—§çš„ blob URL
    if (currentBlobUrl) {
      URL.revokeObjectURL(currentBlobUrl);
    }

    currentBlobUrl = URL.createObjectURL(file);
    preview.src = currentBlobUrl;
    preview.classList.remove('hidden');
    watermarkBtn.disabled = false;
    downloadBtn.disabled = true;
    watermarked = false;

    try {
      info.textContent = 'è¯»å–ä¸­...';
      currentMetadata = await getImageMetadata(file);

      let output = '';
      output += renderInfoList('ğŸ“· å›¾åƒæ¦‚è§ˆ', currentMetadata.generalInfo);
      output += renderInfoList('\nğŸ“¸ åŸºæœ¬ EXIF ä¿¡æ¯', currentMetadata.basicExif);
      output += renderInfoList('\nğŸ§ª å¯Œå£«èƒ¶ç‰‡æ¨¡æ‹Ÿè®¾ç½®', currentMetadata.fujiRecipe);

      info.textContent = output.trim();
      console.log('Metadata loaded:', currentMetadata);
    } catch (err) {
      console.error('Metadata error:', err);
      info.textContent = `è¯»å–å¤±è´¥ï¼š${err.message || err}`;
      preview.classList.add('hidden');
      watermarkBtn.disabled = true;
      downloadBtn.disabled = true;
      if (currentBlobUrl) {
        URL.revokeObjectURL(currentBlobUrl);
        currentBlobUrl = null;
      }
    }
  });

  // æ”¯æŒä»å‰ªè´´æ¿ç²˜è´´å›¾åƒ
  document.addEventListener('paste', async (event) => {
    const items = event.clipboardData?.items;
    if (!items) return;

    for (const item of items) {
      if (item.type.startsWith('image/')) {
        const file = item.getAsFile();
        if (!file) continue;

        // æ¨¡æ‹Ÿ fileInput è¡Œä¸º
        if (currentBlobUrl) {
          URL.revokeObjectURL(currentBlobUrl);
        }

        currentBlobUrl = URL.createObjectURL(file);
        preview.src = currentBlobUrl;
        preview.classList.remove('hidden');
        watermarkBtn.disabled = false;
        downloadBtn.disabled = true;
        watermarked = false;

        try {
          info.textContent = 'è¯»å–ä¸­...';
          currentMetadata = await getImageMetadata(file);

          let output = '';
          output += renderInfoList('ğŸ“· å›¾åƒæ¦‚è§ˆ', currentMetadata.generalInfo);
          output += renderInfoList('\nğŸ“¸ åŸºæœ¬ EXIF ä¿¡æ¯', currentMetadata.basicExif);
          output += renderInfoList('\nğŸ§ª å¯Œå£«èƒ¶ç‰‡æ¨¡æ‹Ÿè®¾ç½®', currentMetadata.fujiRecipe);

          info.textContent = output.trim();
          console.log('Pasted image metadata loaded:', currentMetadata);
        } catch (err) {
          console.error('Metadata error:', err);
          info.textContent = `è¯»å–å¤±è´¥ï¼š${err.message || err}`;
          preview.classList.add('hidden');
          watermarkBtn.disabled = true;
          downloadBtn.disabled = true;
          if (currentBlobUrl) {
            URL.revokeObjectURL(currentBlobUrl);
            currentBlobUrl = null;
          }
        }

        break; // åªå¤„ç†ç¬¬ä¸€ä¸ªå›¾ç‰‡
      }
    }
  });


  watermarkBtn.addEventListener('click', async () => {
    if (!currentMetadata || !preview.src || !currentBlobUrl) {
      info.textContent = 'è¯·å…ˆä¸Šä¼ æœ‰æ•ˆçš„å›¾ç‰‡';
      console.warn('Watermark button clicked but no metadata or image available');
      return;
    }

    try {
      console.log('Starting watermark process...');
      const image = new Image();
      image.src = currentBlobUrl;
      await new Promise((resolve, reject) => {
        image.onload = () => {
          console.log('Image loaded for watermarking:', image.src);
          resolve();
        };
        image.onerror = () => {
          console.error('Image load failed:', image.src);
          reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
        };
      });

      const watermarkedImage = await addWatermark(image, currentMetadata);
      console.log('Watermark applied, updating preview...');

      // é‡Šæ”¾æ—§çš„ blob URL
      if (currentBlobUrl) {
        URL.revokeObjectURL(currentBlobUrl);
      }

      // æ›´æ–°é¢„è§ˆå›¾ç‰‡å¹¶ä¿å­˜æ–°çš„ blob URL
      currentBlobUrl = watermarkedImage.src;
      preview.src = currentBlobUrl;
      watermarked = true;
      downloadBtn.disabled = false;

      // å¼ºåˆ¶é‡ç»˜
      preview.style.display = 'none';
      setTimeout(() => {
        preview.style.display = 'block';
        console.log('Preview updated with watermarked image');
      }, 0);
    } catch (err) {
      console.error('Watermark error:', err);
      info.textContent = `æ·»åŠ æ°´å°å¤±è´¥ï¼š${err.message || err}`;
    }
  });

  downloadBtn.addEventListener('click', () => {
    if (!currentBlobUrl || !watermarked) {
      info.textContent = 'è¯·å…ˆæ·»åŠ æ°´å°';
      return;
    }

    // åˆ›å»ºä¸€ä¸ªä¸´æ—¶é“¾æ¥ç”¨äºä¸‹è½½
    const link = document.createElement('a');
    link.href = currentBlobUrl;

    // ä»åŸå§‹æ–‡ä»¶åç”Ÿæˆä¸‹è½½æ–‡ä»¶å
    const originalFile = fileInput.files[0];
    const originalName = originalFile.name.split('.')[0];
    link.download = `${originalName}_watermarked.jpg`;

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    console.log('Download initiated for watermarked image');
  });
</script>

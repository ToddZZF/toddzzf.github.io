<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>对C++类的整理(2)——运算符重载 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2019/2019-05-23-summary-class-of-c++/>对C++类的整理(2)——运算符重载</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">对C++类的整理(2)——运算符重载</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2019-05-23</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>简单整理一下运算符重载的相关知识</p></blockquote><h1 id=基本概念>基本概念</h1><p>  重载运算符是一种特殊的函数，使得类可以依靠运算符进行特点的操作。它的定义形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//声明为成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=err>类型</span><span class=p>]</span> <span class=p>[</span><span class=err>类名</span><span class=p>]</span><span class=o>::</span><span class=k>operator</span><span class=p>[</span><span class=err>运算符</span><span class=p>](</span> <span class=p>[</span><span class=err>参数表</span><span class=p>]</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//声明为非成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=err>类型</span><span class=p>]</span> <span class=k>operator</span><span class=p>[</span><span class=err>运算符</span><span class=p>](</span> <span class=p>[</span><span class=err>类名</span><span class=p>],[</span><span class=err>参数表</span><span class=p>]</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>参数的数量与该运算符作用的运算对象数量一样多</li><li>若运算符函数是成员函数，则它左侧（第一个）运算对象绑定到this指针上，故它的（显式）参数数量要少一个</li><li>运算符函数要么是类成员，要么含有一个类类型的参数</li><li>重载不改变运算符的优先级和结合律，也不能改变所需的操作数</li></ul><p>  有五个运算符不能被重载：<code>::</code>，<code>.*</code>，<code>。</code>，<code>?:</code>、<code>sizeof</code>。而有两个不应该被重载：<code>,</code>，<code>&</code>（取地址），<code>&&</code>（逻辑与），<code>||</code>（逻辑或），因为它们有特殊含义。（注：<code>new</code>和<code>delete</code>是可以被重载的！）</p><p>  大部分重载函数可以是类的成员函数，也可以是友元函数。只有小部分只能是成员函数：<code>=</code>、<code>()</code>、<code>[]</code>、<code>-></code>。</p><h2 id=成员or非成员>成员or非成员</h2><p>  对于声明为成员函数还是友元函数，应遵循以下原则：</p><ul><li>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>、成员访问箭头<code>-></code>运算符必须是成员函数</li><li>具有对称性的运算符应该是非成员（比如加减乘除、相等性、关系、位运算符）</li><li>改变对象状态的运算符应该是成员（比如递增、递减、解引用）</li></ul><h1 id=具体的运算符>具体的运算符</h1><h2 id=输入输出运算符>输入输出运算符(&#171;、&#187;)</h2><p>  考虑<code>&lt;&lt;</code>的使用方法：<code>cout&lt;&lt;类类型</code>，所以第一个对象是<code>ostream</code>，第二个对象是我们的类，故我们声明为非成员函数，并且声明为类的友元：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>bookNo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>units_sold</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>revenue</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>Sales_data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  由于<code>ostream</code>无法被复制，所以它的形参和返回值都是引用；而由于我们一般不改变类的数据，所以类用<code>const</code>修饰。</p><p>  考虑<code>>></code>的用法：<code>cin>>类类型</code>，所以第一个对象为<code>istream</code>，第二个对象是我们的类，故和<code>&lt;&lt;</code>的重载方法差不多：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>bookNo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>units_sold</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>revenue</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>istream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>istream</span> <span class=o>&amp;</span><span class=p>,</span> <span class=n>Sales_data</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  同样，<code>istream</code>不能被复制，故形参和返回值也都是引用；而我们需要改变原类类型的值，故类的形参是引用。特别的，我们在定义输入重载函数时，需要考虑输入失败的情况，并要从失败中恢复，并将流状态设置为<code>failbit</code>（见《C++ Pimer》496页）</p><h2 id=算术和关系运算符-等>算术和关系运算符（+、-、==、!=、&lt;、>等）</h2><p>  算术运算符有三个特点：</p><ol><li>左右对象可交换（故一般定义为<strong>友元函数</strong>）</li><li>不改变操作对象的值（故形参为<strong>常量引用</strong>）</li><li>返回一个临时的类类型（故返回局部变量的副本）</li></ol><p>  以加法为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>bookNo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>units_sold</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>revenue</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>Sales_data</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Sales_data</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Sales_data</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sales_data</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Sales_data</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Sales_data</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Sales_data</span> <span class=n>sum</span><span class=o>=</span><span class=n>lhs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>sum</span> <span class=o>+=</span> <span class=n>rhs</span><span class=p>;</span><span class=c1>//采用后面的+=的重载函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>  《C++ Primer》 497页：类如果同时定义了算术运算符和复合赋值运算符，通常情况下应用复合赋值来实现算术运算符。</p><p>  关系运算符也大同小异，唯一不同是返回值是bool值。并且要遵循如下设计准则：</p><ul><li>相等运算符<code>==</code>应具有传递性</li><li>定义了<code>==</code>，则相应的要定义<code>!=</code>；同理，定义了<code>&lt;</code>，相应的要定义<code>></code></li></ul><h2 id=递增和递减运算符-->递增和递减运算符（++、&ndash;）</h2><p>  虽然没必要，但还是建议将递增和递减运算符定义为成员函数。因为它们只改变所操作的对象。</p><h3 id=前置版本a>前置版本（++a）</h3><p>  应该返回<strong>递增或递减后的对象的引用</strong>，这样才能作为左值使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>++</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span><span class=o>&amp;</span> <span class=n>A</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span><span class=c1>//返回递增后的对象的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=后置版本a>后置版本（a++）</h3><p>  应该返回递增或递减<strong>前</strong>的对象的<strong>原值</strong>，而非引用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span><span class=o>&amp;</span> <span class=n>A</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=n>temp</span><span class=o>=*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>++*</span><span class=k>this</span><span class=p>;</span><span class=c1>//用之前定义的前置来实现
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>temp</span><span class=p>;</span><span class=c1>//返回递增后的对象的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>  需要注意的是，我们的参数中有一个<code>int</code>，但我们并不会用到它，所以无需为其命名，编译器会为它提供一个值为0的实参。也就等价于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>A</span><span class=o>&amp;</span> <span class=n>A</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>){};</span>
</span></span></code></pre></div><h2 id=赋值运算符>赋值运算符（=）</h2><p>  之前本来是要讲拷贝赋值的，不过基础部分还是不要太深入了，其实和复制构造函数是一样的，也就是编译器会为我们自动重载赋值运算符，但那只是浅复制。要实现深复制，则需要手动对赋值运算符进行重载。要求如下：</p><ul><li>必须是成员函数</li><li>返回左侧运算对象的引用（<code>return *this</code>）</li></ul><p>  例子和深复制那部分差不多，就不给了。</p><h2 id=下标运算符-->下标运算符（ [] ）</h2><p>  貌似最近写程序都没用过这个，就大概讲一下要求：</p><ul><li>必须是成员函数</li><li>返回的是对应元素的引用（这样可以作为左值或右值）</li><li>最好定义多一个常量版本（函数后面加const），并且返回常量引用</li></ul><h2 id=成员访问运算符>成员访问运算符（*）</h2><p>（待定）</p><h2 id=函数调用运算符--->函数调用运算符（ ( ) ）</h2><p>（待定）</p><h1 id=类类型转换>类类型转换</h1><p>  假如我们需要将类和一个整数相加，则编译器会利用构造函数，将整数转化为类，再相加。那么有没有办法能让类转化为整数呢？这就是类类型转换。</p><p>  类型转换运算符类似于一般的运算符重载，它的声明格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>operator</span> <span class=nf>type</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span><span class=c1>//type为要转换成的类型，可以是内置类型，也可以是其它类
</span></span></span></code></pre></div><p>  它有几个特点：</p><ul><li>类类型转换函数必须是成员函数；</li><li>不能声明返回类型（返回类型只能为type）；</li><li>不能有形参；</li><li>通常应该是const</li></ul><p>  类类型转换一般是隐式执行的，因此无法给这些函数传递实参（强制执行的话可以用<code>int([类类型])</code>，或者<code>[类型].operator type()</code>）。</p><h2 id=注意>注意</h2><p>  首先，不是所有类都需要类类型转换，比如某个类表示Date，某一天Aug 13, 2000既可以解释为20000813，也可以解释为从Jan 1, 2000经过的天数。在这种情况下，应该定义两个成员函数负责返回不同的格式。</p><p>  其次，要避免二义性。比如：类A定义了接受类B的转换构造函数，而类B定义了转换到类A的函数。这种情况下，我们只能显式的使用对应的函数，否则编译器无法确定要用哪个。并且我们不能使用强制类型转换，因为这种情况下，强制类型转换也面临二义性。</p><p>  关于如何避免这些情况，见</p><h2 id=显式的类类型转换>显式的类类型转换</h2><p>  为了防止某些情况下，隐式的类类型转换造成错误，可以在类类型转换函数声明前加<code>explicit</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=k>operator</span> <span class=kt>int</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=n>val</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>  此时，如果想要将A转化为int，需要显式的强制转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span><span class=o>=</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>+</span><span class=mi>3</span><span class=p>;</span><span class=c1>//错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=p>(</span><span class=n>a</span><span class=p>)</span><span class=o>+</span><span class=mi>3</span><span class=p>;</span><span class=c1>//正确
</span></span></span></code></pre></div><p>  但是，在下列位置，显式的类类型转换会被隐式执行：</p><ul><li>if、while及do语句的条件部分</li><li>for语句头的条件表达式</li><li>逻辑运算符的运算对象</li><li>条件运算符（?:）的条件表达式</li></ul><p>  实际上，cin有一个向bool转换的显式的类型转换函数，所以我们可以在条件表达式中用cin，并且在其他位置用cin不会出错。</p><h1 id=题外话>题外话</h1><p>顺便说一句：NASA有一个<em>把名字刻在火星漫游者芯片上</em> 的活动，也就是说，我的名字要上火星咯~</p><iframe width=980 height=410 src="https://mars.nasa.gov/layout/embed/send-your-name/mars2020/certificate/?cn=798945412605" frameborder=0></iframe></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
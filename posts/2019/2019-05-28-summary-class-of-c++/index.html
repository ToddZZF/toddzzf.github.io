<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>对C++类的整理(3)——继承 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2019/2019-05-28-summary-class-of-c++/>对C++类的整理(3)——继承</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">对C++类的整理(3)——继承</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2019-05-28</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>派生与继承是一对好兄弟</p></blockquote><p><strong>考点</strong>：类与类之间有三种关系：<code>has-a</code>、<code>uses-a</code>和<code>is-a</code>。<code>has-a</code>表示一个类是另一个类的数据成员；<code>uses-a</code>表示一个类使用另一个类的函数或对象；<code>is-a</code>表示继承。用有向无环图（DAG）表示类之间的继承关系，称为类格，前驱结点称为基类，后继节点称为派生类。</p><h1 id=基类和派生类的关系>基类和派生类的关系</h1><p>  之前的类都是独立的类，而通过<strong>继承</strong>我们可以将类联系起来，构成一种层次关系。位于底层的叫<strong>基类</strong>，继承得到的类叫<strong>派生类</strong>。我们可以“一继承一”，“一继承多”，“一派生多”，总之这种派生关系是没限制的。如果你不想某个类用作基类，可以在类名后面加上<code>final</code></p><h2 id=定义派生类>定义派生类</h2><p>  派生类通过<strong>基类名表</strong>（类派生列表）指出它是从哪些基类派生而来的，其基本格式为：<code>[访问控制] 基类名1, [访问控制] 基类名2, ...</code>，访问控制和访问说明符一样，有三种：<code>private</code>、<code>protected</code>和<code>public</code>，省略的话，stuct默认为<code>public</code>，class默认为<code>private</code>，这是它们唯二的区别。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>;</span><span class=c1>//基类
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=访问控制和继承>访问控制和继承</h2><p>  派生类的成员有两部分组成：自己的和继承的。自己的成员受访问说明符控制，而继承的那部分受 基类的访问说明符 和 基类名表的访问控制符 控制。具体如下：</p><ol><li>先看基类的访问说明符：<ul><li><code>private</code>：只能在基类中访问，派生类和（任何）外部无法访问</li><li><code>protected</code>：能在基类、派生类中访问，（任何）外部无法访问</li><li><code>public</code>：能在基类、派生类中访问，（基类）外部可以访问，（派生类）外部要看下面一部分</li></ul></li><li>再看继承时的访问描述符<ul><li><code>private</code>：继承的来的成员，除基类中的private部分外，全部属于派生类的<code>private</code>。（外部无法访问）</li><li><code>protected</code>：继承的来的成员，除基类中的private部分外，全部属于派生类的<code>protected</code>。（外部无法访问）</li><li><code>public</code>：继承的来的成员，除基类中的private部分外，基类中的protected部分属于派生类的<code>protected</code>，基类中的public部分属于派生类的<code>public</code>。</li></ul></li></ol><p>（注意，外部指的是类的用户）</p><p>  派生类会继承基类中的以下部分：</p><ul><li>基类中<code>private</code>、<code>protected</code>和<code>public</code>的<strong>一般的</strong>数据成员和成员函数</li><li>虚函数</li></ul><p>  派生类不会继承基类的以下部分：</p><ul><li>友元声明：友元声明永远只对做出声明的类有效</li><li>静态成员：静态成员在整个类体系（基类和派生类）中被共享</li></ul><h3 id=改变个别成员的访问性>改变个别成员的访问性</h3><p>  特别的，我们可以单独地改变某些成员的访问控制，称为访问声明。格式为<code>基类名::成员</code>，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>private</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>::</span><span class=n>a</span><span class=p>;</span><span class=c1>//外部可以访问
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//也可以这样写 using Base::a;//见Primer 546
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>  <strong>注意</strong>：</p><ol><li>访问声明不能带任何类型说明（数据成员），或参数和返回类型声明（成员函数）</li><li>访问声明只能用于基类中的<strong>非private部分</strong>，基类的私有成员不能用访问声明</li><li>访问声明不能降低基类成员的可访问性（这条有问题，但考试还是当它对）</li><li>访问声明作用于所有同名函数（重载函数），因此，同名函数位于基类的不同访问域时，无法用访问声明</li><li>若派生类中存在与基类名字相同的成员，则不能用访问声明</li></ol><h2 id=类作用域>类作用域</h2><p>  派生类的作用域嵌套在基类里面（想象几个同心圆）。当要查找某个数据成员或成员函数时，编译器先从内部查找，若不存在，再到外部查找。也就是说，如果派生类中存在与基类<strong>同名</strong>的成员，则派生类的成员将“隐藏”基类的成员，但我们依然可以通过<code>类名::成员</code>的方式显式地使用基类的成员。</p><p>  实际上，<code>类名::成员</code>的方式是让编译器从指定类开始找，而非内部，这点在多层继承时要注意。</p><p>   <strong>注意，只要名字相同，就会隐藏基类成员；就算同名而参数不同，也会隐藏！！！</strong> 如果想要隐藏某个，而不隐藏某个，可以使用<code>using</code>。参照上面的“改变个别成员的访问性”那一节。</p><h2 id=多继承和虚继承>多继承和虚继承</h2><p>  派生类可以继承多个基类，这种继承是没有任何限制的，你甚至可以C继承B和A，同时B又继承A，这种情况下，C实际上有两个A部分，使用时要分清类作用域。</p><p>  如果你希望上面的例子中，C只有一个A部分，那么可以在B继承A的“基类名表”前加<code>virtual</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>A</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span><span class=o>:</span> <span class=k>public</span> <span class=n>A</span><span class=p>,</span> <span class=k>public</span> <span class=n>B</span><span class=p>{};</span>
</span></span></code></pre></div><p>  这样，在C中，无论你是通过B使用A成员，还是直接使用A成员，都是同一个A部分。</p><h1 id=派生类的初始化>派生类的初始化</h1><p>  派生类需要初始化两部分：从基类继承的部分 与 派生类自己的部分。我们依然可以用初始化列表，用<code>基类名(变元表)</code>初始化基类部分，用<code>数据成员(参数)</code>初始化自己部分。系统会先执行基类的初始化，之后的顺序和之前一样。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span><span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>i</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>private</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Derived</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span><span class=o>:</span><span class=n>Base</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>data2</span><span class=p>(</span><span class=n>j</span><span class=p>)</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  对于有多个基类的派生类，其基类的初始化顺序取决于声明基类时的“基类名表”。总的来说，构造函数的执行顺序为：基类构造函数——对象成员构造函数——派生类构造函数；析构函数的执行情况与之相反。</p><h1 id=多态性>多态性</h1><p>  一般情况下，引用或指针的类型 与 所绑定的对象的类型 应一致。但在继承关系中，允许将<strong>基类的指针或引用</strong>绑定在派生类上。这种情况下，基类指针<strong>只能引用基类的成员</strong>，如果要引用派生类的成员，则必须使用强制类型转换，将基类指针转换为派生类指针。</p><p>  我们之所以能将基类的指针或引用绑定在派生类上，是因为派生类中包含一个基类部分。如果我们将派生类的指针或引用绑定在基类上，则指针或引用可能会使用基类中不存在的成员，因此不允许<strong>将派生类的指针或引用绑定在基类上</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=o>:</span><span class=n>data</span><span class=p>(</span><span class=n>i</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=o>:</span><span class=k>public</span> <span class=n>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>B</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span><span class=o>:</span><span class=n>data</span><span class=p>(</span><span class=n>i</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>B</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=n>B</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span><span class=c1>//强制类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span><span class=c1>//错误！
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=p>((</span><span class=n>A</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>data</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span><span class=c1>//1
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>=&amp;</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span><span class=c1>//1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=p>((</span><span class=n>B</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>data</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span><span class=c1>//-1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>  在此引入<strong>静态类型</strong>与<strong>动态类型</strong>的关系：静态类型是声明时所指的类型，而动态类型是内存中所指的对象的类型。对于指针而言，指针的类型为静态类型，指针所指对象的类型为动态类型。</p><h2 id=利用派生类初始化基类>利用派生类初始化基类</h2><p>  如果基类有复制构造函数，那么我们可以传递一个派生类，但只能用派生类中包含的基类部分。如果我们将派生类转化为基类，则派生类特有的那部分将会被“切掉”。</p><h2 id=虚函数>虚函数</h2><p>  如果我们希望基类的某些函数在派生类中覆盖，我们可以在基类中将该函数声明为<strong>虚函数</strong>，即在函数声明前加<code>virtual</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>function</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  之后，我们在派生类中要定义一个<strong>函数名、返回类型、参数个数、参数类型、参数顺序</strong>完全相同的函数，才能覆盖派生类的版本。否则派生类依然会继承其在基类中的版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>function</span><span class=p>()</span> <span class=k>const</span> <span class=p>[</span><span class=k>override</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>//C++11允许在const后面显式注明“覆盖”override，但这非必须
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>  注意，这里的覆盖与之前的覆盖不同。按照之前的覆盖，如果我们用基类指针去使用被覆盖的函数，则使用的是覆盖前的版本；而声明为虚函数后，使用的是覆盖后的版本。也就是说，指针会执行实际指向的对象的函数。</p><p>  虚函数有以下特点：</p><ul><li>一旦基类声明了虚函数，则无论经过多少次派生，派生类的派生类依然保持这个函数的虚特性。（但之后的虚函数无需再加<code>virtual</code>，可以但没必要~）</li><li>虚函数必须是成员函数，且必须位于类内的函数声明，不能用于类外函数定义</li><li>不能将友元声明为虚函数</li><li>析构函数可以是虚函数，但构造函数不能</li></ul><p>  关于最后一点，因为如果我们用基类指针指向派生类，当我们delete指针时，则只会析构基类成员，而不会析构派生类成员，为了达到后一点，必须用虚析构函数。至于构造函数，编译器必须从基类开始，沿继承路径逐个调用构造函数，不能“选择性”地调用虚构函数。</p><h2 id=纯虚函数和抽象类>纯虚函数和抽象类</h2><p>  纯虚函数的声明如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>virtual</span> <span class=err>类型</span> <span class=err>函数名</span><span class=p>(</span> <span class=err>参数表</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div><p>  这个实际上和虚函数的特点是一样的，但有它后面的<code>=0</code>表示它自己是没定义的。也就是说，我们不能在基类用它。而是需要等到派生类覆盖掉它后，才能在派生类中用。</p><p>  基类只要有纯虚函数，就是抽象类。抽象类有如下特点：</p><ul><li>只能用作其他函数的基类</li><li>不能建立具体的对象（但可以声明指针和引用）</li><li>不能用作参数类型、函数返回值或显式类类型转换</li></ul><p>  抽象类的唯二用处是：</p><ul><li>声明指针或引用</li><li>作为其他类的基类</li></ul><p>  那么这有什么用呢？可以想象，如果我们由抽象类派生了多个派生类，则我们可以用抽象类的指针，指向这些派生类，从而实现<strong>多态</strong>，使程序更加灵活。甚至，我们可以建立抽象类的数组，储存不同的派生类。</p></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
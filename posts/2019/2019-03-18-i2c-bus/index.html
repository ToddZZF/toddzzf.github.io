<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>Arduino与I2C总线协议 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2019/2019-03-18-i2c-bus/>Arduino与I2C总线协议</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">Arduino与I2C总线协议</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2019-03-18</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>为了参加学院的电信杯，好好学一下 I2C</p></blockquote><h1 id=i2c总线协议入门>I2C总线协议入门</h1><p>   I2C总线协议（ 全称：Inter Integrated Circuit，又叫 I^2^C，IIC）是一种连接低速设备的通信协议，是由 Philips 在80年代设计的。它有如下几个优点：</p><ul><li>只需要两条数据线；</li><li>没有严格的波特率（baud rate）限制</li><li>主/从关系简单</li><li>多主控，但任何时间点只能有一个主控。</li></ul><p>  缺点也有：</p><ul><li>传输速度比SPI慢</li><li>每个数据字节都只能是8位</li><li>硬件要求比SPI更高</li></ul><p><img src=http://www.vector-logo.net/logo_preview/eps/i/i2c_Bus.png alt=I^2^C title=I2C></p><h2 id=硬件结构>硬件结构</h2><p>  下面这幅图展示了单个主/从机之间的电路连接：</p><p><img src=https://www.i2c-bus.org/static/i2c/BusSetup.gif alt=I2C连线 title=I2C连线></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>VCC</td><td>为I2C提供电压，范围为1.2V~5.5V</td></tr><tr><td>GND</td><td>共地接线</td></tr><tr><td>SDA</td><td>Serial data 串行数据（I2C 数据线）</td></tr><tr><td>SCL</td><td>Serial clock 串行时钟（I2C 时钟线）</td></tr><tr><td>Rp</td><td>上拉电阻（大小计算可参考<a href=http://www.ti.com/lit/pdf/SLVA689>SLVA689</a>）</td></tr><tr><td>Rs</td><td>串口电阻</td></tr><tr><td>Cp</td><td>Wire Caoacitance 线间电容</td></tr><tr><td>Cc</td><td>Cross channel capacitance 路间电容</td></tr></tbody></table><p>对于多个主/从机，可以这样连接：</p><p><img src=http://www.cypress.com/sites/default/files/inline/fckImages/myresources/AN50987.jpg alt=多个从机连线 title=多个从机连线></p><p>  下面重点讲一下双向通信的开漏结构（Open-Drain for Bidirectional Communication），这能帮助我们了解为什么同一时间只允许一个主控。请看结构图：</p><p><img src=/styles/images/I2C/open-drain.PNG alt=&ldquo;Open-Drain&rdquo; title="开漏结构 Open-Drain"></p><p>  主/从机可以让晶体管的导通（开漏），让SDA/SCL线的电压拉低；当主/从机让晶体管不导通时，上拉电阻会将SDA/SCL线上的电压拉高。也就是说，主/从机只能让SDA/SCL为0，当主/从机不控制时，SDA/SCL为1。因此，永远不会出现一个从机传输0，另一个从机传输1的情况，即同一时间只能有一个设备在传输数据。</p><p>  这种结构虽然效率较低，但其驱动电流/电压较小，很适合驱动能力差的微处理器和传感器。</p><h1 id=i2c操作>I2C操作</h1><p> I2C可以在主/从机之间的双向通信。为了分辨每个设备，每个设备都有一个独一的地址，这样主机就能通过地址和指定的从机通信。下面是一个大概的流程：</p><ol><li>假如主机想要给从机发送数据：<ul><li>主机发送起始条件和从机寄存器的地址</li><li>主机发送数据</li><li>主机发送终止条件</li></ul></li><li>假如主机想要接收读取从机数据：<ul><li>主机发送起始条件和从机寄存器地址</li><li>主机发送读指令</li><li>主机从从机接收数据</li><li>主机发送终止条件</li></ul></li></ol><p>  下面我们来详细讲解一下。</p><h2 id=STARTandSTOP>起始条件和终止条件</h2><p>  开始条件：当SCL为高电平时，SDA从高电平变为低电平；终止条件：当SCL为高电平时，SDA从低电平变为高电平。</p><p><img src=http://i2c.info/wp-content/images/i2c.info/start-stop.gif alt=起始与终止条件 title=起始与终止条件></p><h2 id=RepeatedSTART>重复起始条件</h2><p>  如果某一个主机想要在一次通信中与不同从机通信，又不想让其他主机切入，那么可以”重复开始条件“，即在与一个从机通信完后，再次产生一个起始条件，与另一个从机通信。这样，数据线就不会”空闲（idle）“，其他主机就无法切入。</p><p><img src=http://www.avrbeginners.net/architecture/twi/img/sta_sto.gif alt=重复起始条件 title=重复起始条件></p><h2 id=数据有效性和数据格式>数据有效性和数据格式</h2><p>  数据以每8位为一个字节。每个字节可以为设备地址、寄存器地址或读写数据。每个位在SCL脉冲时传输，即当SCL为高电平时，数据能传输，低电平时则改变数据的0/1。结合上面，我们知道如果在SCL时改变了SDA的数据，则会被当作起始/终止条件。所以SDA的数据要在SCL高电平时保持稳定。</p><p><img src="https://tse4-mm.cn.bing.net/th?id=OIP.6FejWLZ164j1Cn4v2kjc_wHaC8&amp;pid=Api" alt=数据有效性 title=数据有效性></p><h2 id=应答位ack>应答位（ACK）</h2><p>  每个数据的字节（包括传输地址的字节）后面都会紧接着一个由接收方发送的ACK位，接收方通过ACK位告诉发送方数据是否成功接收。</p><p>  在接收方发送ACK位前，发送方会释放SDA线，使得接收方可以在SCL高电位时，拉低SDA的电位（即下图的第9周期）。SDA低为ACK（Acknowledge，应答），SDA高为NACK（Not Acknowledge，非应答）</p><p>  下面这几种情况可能会导致非应答：</p><ol><li>接收方正在执行某个实时的功能，无法接收或发送数据</li><li>接收方无法理解发送的数据/命令</li><li>接收方无法接收更多的数据</li><li>主机已经完成了从机的数据读取，主机通过发送NACK告诉从机这个。</li></ol><p><img src=http://www.diangon.com/image/portal/201501/12/100648c7nx7xhw7mom7w31.jpg alt=数据格式 title=数据格式></p><h2 id=向从机写数据>向从机写数据</h2><p>  首先是发送<a href=#STARTandSTOP>起始条件</a>，然后发送从机地址（7位），紧接着第八位是R/W（读写位），R/W=1为读，R/W=0为写。</p><p>  然后还要发送寄存器地址（8位），但有时候从机只有一个寄存器，发送从机地址就够了（就像下图一样）。</p><p>  然后主机就开始发送数据，直到所有数据都发完后，发送<a href=#STARTandSTOP>停止条件</a>（或<a href=#RepeatedSTART>重复起始条件</a>）</p><p><img src=https://i2c.info/wp-content/images/i2c.info/7-bit-address-writing.gif alt=向从机写数据 title=向从机写数据></p><h2 id=从从机读数据>从从机读数据</h2><p>  </p><h1 id=参考资料>参考资料</h1><p><a href=http://www.ti.com/lit/an/slva704/slva704.pdf>SLVA704-Understanding the I2C Bus.pdf</a></p><p><a href=https://www.nxp.com/docs/en/user-guide/UM10204.pdf>I2C-bus specification and user manual</a></p><p><a href=https://blog.csdn.net/jasonchen_gbd/article/details/77431951>I2C总线传输协议</a></p><p><a href=https://zhuanlan.zhihu.com/p/26579936>I2C协议（上）——基础介绍</a></p><p><a href=https://blog.csdn.net/phenixyf/article/details/17846969>I2C通信 读写数据过程</a></p><p>图像来源于网络，若有侵权，请联系</p></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
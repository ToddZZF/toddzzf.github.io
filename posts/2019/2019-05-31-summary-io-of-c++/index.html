<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>对C++I/O库的整理 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2019/2019-05-31-summary-io-of-c++/>对C++I/O库的整理</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">对C++I/O库的整理</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2019-05-31</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>本想着应付考试，然而考试并没有考。</p></blockquote><h1 id=基本的io类库与对象>基本的I/O类库与对象</h1><ul><li><p><code>iostream</code></p><ul><li><code>istream</code>、<code>wistream</code>从流读取数据</li><li><code>ostream</code>、<code>wostream</code>向流中写入数据</li><li><code>iostream</code>、<code>wiostream</code>读写流</li></ul></li><li><p><code>fstream</code></p><ul><li><code>ifstream</code>、<code>wifstream</code>从文件读取数据</li><li><code>ofstream</code>、<code>wofstream</code>向文件写入数据</li><li><code>fstream</code>、<code>wfstream</code>读写文件</li></ul></li><li><p><code>sstream</code></p><ul><li><code>istringstream</code>、<code>wistringstream</code>从string读取数据</li><li><code>ostringstream</code>、<code>wostringstream</code>向string写入数据</li><li><code>stringstream</code>、<code>wstringstream</code>读写string</li></ul></li><li><p><code>iomanip</code>：用于指定输入输出流的格式</p></li></ul><p>  为了支持宽字符的语言（即wchar_t类型），io库定义了以w开头的一组类型和对象，比如<code>wcin</code>、<code>wcout</code>分别对应<code>cin</code>、<code>cout</code>。这些用起来和普通字符没什么不同，后面我们就以普通字符为例子。</p><h2 id=io类型间的关系>IO类型间的关系</h2><p>  IO类型之间存在继承的关系。如下</p><p><img src="https://cn.bing.com/th?id=OIP.vuMzG8pGvefTKe2X1DlFmgHaDR&amp;pid=Api&amp;rs=1&amp;p=0" alt=io类型的关系 title=io类型的关系></p><p>  当然，实际上的继承关系远比这复杂。要了解更多，可以看回课本。</p><p>  正是因为有了上面的继承关系，一些用于<code>istream</code>、<code>ostream</code>的操作，比如<code>&lt;&lt;</code>、<code>>></code>也可以用于<code>ifstream</code>、<code>istringstream</code>、<code>ofstream</code>、<code>ostringstream</code></p><h2 id=io对象无拷贝或赋值>IO对象无拷贝或赋值</h2><p>  **IO对象无拷贝或赋值！**所以我们不能用<code>=</code>对流赋值或拷贝，也不能在函数中使用流参数或返回流，只能使用或返回流的引用或指针。这点格外要注意。</p><h2 id=流状态>流状态</h2><p>  由于IO可能发生错误，我们需要一些标志和函数标记或检测流状态。</p><h3 id=标志>标志</h3><p>  ios类中，有一个数据成员，其每一位都对应一种错误状态，称为状态字。具体如下</p><table><thead><tr><th>标识常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>goodbit</td><td>0x00</td><td>状态正常</td></tr><tr><td>eofbit</td><td>0x01</td><td>文件结束</td></tr><tr><td>failbit</td><td>0x02</td><td>IO操作失败，但数据未丢失，可恢复</td></tr><tr><td>badbit</td><td>0x04</td><td>流崩溃，数据丢失，不可恢复</td></tr></tbody></table><p>  使用时，记得格式是<code>ios::goodbit</code>，当然，直接用值也行，就是不那么好记。</p><h3 id=检查与设置>检查与设置</h3><p>  以下函数用于检查流状态：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>istream</span> <span class=o>&amp;</span><span class=n>s</span><span class=o>=</span><span class=n>cin</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//检查是否为eofbit，是则返回1，否则返回0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>eof</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//检查是否为failbit或badbit，是则返回1，否则返回0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>fail</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=o>!</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//检查是否为badbit，是则返回1，否则返回0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>bad</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//检查是否为goodbit，是则返回1，否则返回0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>good</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//返回状态字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>rdstate</span><span class=p>();</span>
</span></span></code></pre></div><p>  以下函数用于设置流状态（都是返回void）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//复位所有状态位，并将流状态设为有效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//复位所有状态位，并将流状态设为标识常量flags
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>clear</span><span class=p>(</span><span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//单纯地将flags的对应位设为1，并不会清除其他状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>setstate</span><span class=p>(</span><span class=n>flags</span><span class=p>)</span>
</span></span></code></pre></div><p>  关于最后两个函数的区别可以看：<a href=https://blog.csdn.net/origin_lee/article/details/38707643>clear与setstate的区别</a></p><h2 id=缓冲>缓冲</h2><p>  输出流都有一个缓冲区，用来保存程序读写的数据，并直到缓冲区刷新时才写到输出设备或文件。缓冲刷新的时机为：</p><ul><li><p>程序正常结束，main函数的return操作会执行缓冲刷新。</p></li><li><p>缓冲区满时，只有刷新后数据才能继续写入缓冲区</p></li><li><p>用操纵符<code>endl</code>、<code>ends</code>、<code>flush</code>来显式刷新，用法为<code>cin&lt;&lt;endl</code>。它们三个的区别是：</p><p><code>endl</code>：添加一个“换行”，再刷新；</p><p><code>ends</code>：添加一个“空格”，再刷新；</p><p><code>flush</code>：不添加额外字符，直接刷新；</p></li><li><p>用<code>unitbuf</code>来设置不缓存，立即刷新，用法为<code>cin&lt;&lt;unitbuf</code>；若要取消，可用<code>nounitbuf</code>。</p></li><li><p>一个输出流被关联到另一个流，当读写后面那个流时，刷新原输出流。比如<code>cout</code>与<code>cin</code>关联，当写cin时，刷新cout</p></li></ul><h1 id=格式化输入输出>格式化输入输出</h1><p>  标准库定义了一组<strong>操纵符</strong>来控制流的格式状态，也就是修改数值的输出形式或控制补白的数量和位置。一般来讲，操纵符都是“设置”/“复原“成对的。下面的若无说明，无需包含iomanip头文件，凡是以set开头的都在iomanip中。</p><h2 id=bool格式>bool格式</h2><p>  默认情况下，bool值输出0/1；输出true/false，可用<code>boolalpha</code>；复原可用<code>noboolalpha</code>。一旦设置了bool格式，会对后面所有的bool值起作用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=nb>true</span><span class=o>&lt;&lt;</span><span class=sc>&#39; &#39;</span><span class=o>&lt;&lt;</span><span class=nb>false</span><span class=o>&lt;&lt;</span><span class=sc>&#39;\n&#39;</span> <span class=err>\\输出</span><span class=mi>0</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span><span class=n>boolalpha</span><span class=o>&lt;&lt;</span><span class=nb>true</span><span class=o>&lt;&lt;</span><span class=sc>&#39; &#39;</span><span class=o>&lt;&lt;</span><span class=nb>false</span><span class=o>&lt;&lt;</span><span class=sc>&#39;\n&#39;</span> <span class=err>\\输出</span><span class=nb>true</span> <span class=nb>false</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span><span class=n>noboolalpha</span><span class=o>&lt;&lt;</span><span class=nb>true</span><span class=o>&lt;&lt;</span><span class=sc>&#39; &#39;</span><span class=o>&lt;&lt;</span><span class=nb>false</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=err>\\输出</span><span class=mi>1</span> <span class=mi>0</span>
</span></span></code></pre></div><h2 id=整型格式>整型格式</h2><p>  默认情况下，整型输出使用十进制。用<code>hex</code>改为十六进制；<code>oct</code>改为八进制；<code>dec</code>改回十进制。一旦设置了格式，会对后面所有的整型起作用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=c1>//24
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>hex</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=c1>//18
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>oct</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=c1>//30
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>dec</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=c1>//24
</span></span></span></code></pre></div><p>  默认是只输出数字。如果想要十六进制输出0x18，八进制输出030，可以用<code>showbase</code>，若要取消，可以用<code>noshowbase</code>。一旦设置，对后面所有的整型起作用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span><span class=n>showbase</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=c1>//24
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>hex</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=c1>//0x18
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>oct</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=c1>//030
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>dec</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=c1>//24
</span></span></span></code></pre></div><p>  默认情况下，十六进制的0x18是用小写的x，并且用小写的“abcdef”，可以用<code>uppercase</code>来设置为大写，<code>nouppercase</code>设置为小写。一旦设置，对后面所有的整型起效。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span><span class=n>showbase</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;&lt;</span> <span class=n>hex</span> <span class=o>&lt;&lt;</span> <span class=mi>15</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=c1>//0xf
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span><span class=n>uppercase</span><span class=o>&lt;&lt;</span><span class=mi>15</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span><span class=c1>//0XF
</span></span></span></code></pre></div><p>  默认情况下，正数前面无正号，若要输出正号，可用<code>showpos</code>，取消可以用<code>noshowpos</code>。一旦设置，对后面所有的正整数和正浮点数都有效。</p><h2 id=浮点数格式>浮点数格式</h2><p>  默认精度为6位，超出的位四舍五入。若要设置精度，可以用下面三个函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>();</span><span class=c1>//返回旧精度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=c1>//设置新精度，返回旧精度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>setprecision</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=c1>//设置新精度，不返回值。要包含头文件iomanip
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>float</span> <span class=n>pi</span> <span class=o>=</span> <span class=mf>3.1415926</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=c1>//3.1416
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=c1>//3.142
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=c1>//3.14
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>float</span> <span class=n>pi</span> <span class=o>=</span> <span class=mf>3.1415926</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=c1>//4 3.1416
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=c1>//3 3.1416
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=c1>//6 3.1416
</span></span></span></code></pre></div><p>  注意，在最后一个例子中，cout.precision(int)是从后往前执行，并且最终的输出结果取决于前面的。并且float类型的最大精度为6，double最大精度为15。</p><p>  浮点数有三种计数法：科学计数法、定点十进制或十六进制计数法。操纵符<code>scientific</code>设置科学计数法；<code>fixed</code>设置定点十进制；<code>hexfloat</code>设置十六进制法。标准库默认会根据数值自动选择计数法，我们也可以通过<code>defaultfloat</code>来设置成默认模式。一旦设置，对后面所有的浮点数都有效。</p><p>  一旦设置为<code>scientific</code>、<code>fixed</code>或<code>hexfloat</code>后，精度的含义会发生变化：默认模式指的是总位数，设置后指的是小数点后的位数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=c1>//3.14159
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>scientific</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=c1>//3.141593e+00
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>fixed</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=c1>//3.141593
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>hexfloat</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span> <span class=c1>//0x1.921fb4p+1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span> <span class=n>defaultfloat</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>//3.14159
</span></span></span></code></pre></div><p>  科学计数法的e和十六进制默认为小写，要用大写的话可以用<code>uppercase</code>，要用小写的话可以用<code>nouppercase</code>。</p><p>  默认情况下，若浮点数的小数部分为零，则不显示小数点。可以用<code>showpoint</code>和<code>noshowpoint</code>在显示与不显示之间转换。若显示，则小数点后面的零取决于精度。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>showpoint</span><span class=o>&lt;&lt;</span><span class=mf>3.0</span> <span class=c1>//3.00000
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;&lt;</span><span class=n>noshowpoint</span><span class=o>&lt;&lt;</span><span class=mf>3.0</span> <span class=c1>//3
</span></span></span></code></pre></div><h2 id=输出补白>输出补白</h2><p><code>setw(int)</code>：<strong>包含在iomanip中</strong>。指定<strong>下一个</strong>数字或字符串的最小空间（宽度）。如果没填满，则在前面加空格；如果填满或大于，则按正常输出。<strong>只对下一个数字或字符串有效</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>setw</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;yoyoyo&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//1234yoyoyo//1234是为了看清有几个空格人为标上去的
</span></span></span></code></pre></div><p><code>left</code>：左对齐输出。比如在上面的最小空间中，没填满时，数字或字符串默认是在右边；设置左对齐后，是在左边。一旦设置，对后面所有的数字或字符串都有效。右对齐为<code>right</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>setw</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>left</span><span class=o>&lt;&lt;</span><span class=s>&#34;yoyoyo&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//yoyoyo7890//7890是为了看清有几个空格人为标上去的
</span></span></span></code></pre></div><p><code>setfill('a')</code>：<strong>包含在iomanip中</strong>。设置用于补白的字符，默认为空格，只允许用一个字符去替换。一旦设置，对后面所有的都有效。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>setfill</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>setw</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=s>&#34;yoyoyo&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//aaaayoyoyo
</span></span></span></code></pre></div><p><code>internal</code>：控制负数符号的位置，设置之后左对齐符号或基数指示符，右对齐数字，中间补白（前提是setw的宽度要大于负数长度）。一旦设置，对后面所有的负数或非十进制数都有效。并没有找到取消的方法&mldr;&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>internal</span><span class=o>&lt;&lt;</span><span class=n>setw</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>setfill</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>)</span><span class=o>&lt;&lt;-</span><span class=mi>10</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>\
</span></span><span class=line><span class=cl><span class=c1>//-aaaaaaaa10
</span></span></span></code></pre></div><h2 id=控制输入格式>控制输入格式</h2><p>  默认输入为忽略空格、制表、换行、换纸、回车符。要让输入不忽略，可用<code>noskipws</code>；忽略可用<code>skipws</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>ch</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>cin</span><span class=o>&gt;&gt;</span><span class=n>ch</span><span class=p>)</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>ch</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//输入a b c d//输出abcd
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>ch</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span><span class=o>&gt;&gt;</span><span class=n>noskipws</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>cin</span><span class=o>&gt;&gt;</span><span class=n>ch</span><span class=p>)</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>ch</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//输入a b c d//输出a b c d
</span></span></span></code></pre></div><h1 id=其他格式化输入输出>其他格式化输入输出</h1><p>  上面大部分使用<code>&lt;&lt;</code>和<code>>></code>+控制符来实现，下面介绍两种其他设置格式的方法：</p><h2 id=ios类中的方法>ios类中的方法</h2><p>  ios类中可以通过格式控制函数来设置格式。格式控制函数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//返回标志字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ios</span><span class=p>.</span><span class=n>flags</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//设置标志字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ios</span><span class=p>.</span><span class=n>flags</span><span class=p>(</span><span class=n>Flags</span><span class=p>);</span><span class=c1>//清空并设置Flags标志位，返回之前的标志位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ios</span><span class=p>.</span><span class=n>setf</span><span class=p>(</span><span class=n>Flags</span><span class=p>);</span><span class=c1>//在原基础上加上Flags标志位，返回之前的标志位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ios</span><span class=p>.</span><span class=n>setf</span><span class=p>(</span><span class=n>Flags</span><span class=p>,</span> <span class=n>Masks</span><span class=p>);</span><span class=c1>//在基础上加上Flags标志位，清除Masks标志位，返回之前的标志位
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//清除标志位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ios</span><span class=p>.</span><span class=n>unsetf</span><span class=p>(</span><span class=n>Flags</span><span class=p>)</span><span class=c1>//清除Flags标志位，返回之前的标志位
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//设置宽度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>width</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//返回宽度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>width</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//设置填充字符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>fill</span><span class=p>(</span><span class=n>chat</span> <span class=n>ch</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//返回填充字符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>fill</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//设置精度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//返回精度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>();</span>
</span></span></code></pre></div><p>  其中，标志字和上面的控制符差不多，不过用的时候要加上<code>ios::</code>，下面列出常用的标志字：</p><table style=height:686px;width:825px border=1 cellspacing=0 cellpadding=0><tbody><tr><td valign=top width=75><p>位组</p></td><td valign=top width=76><p>格式标志</p></td><td valign=top width=217><p>作用</p></td><td valign=top width=113><p>默认值</p></td><td valign=top width=71><p>所占bit</p></td></tr><tr><td valign=top width=75><p>&nbsp;</p></td><td valign=top width=76><p>skipws</p></td><td valign=top width=217><p>使用输入操作符时跳过空白字符</p></td><td valign=top width=113><p>设置</p></td><td valign=top width=71><p>1</p></td></tr><tr><td valign=top width=75><p>&nbsp;</p></td><td valign=top width=76><p>unitbuf</p></td><td valign=top width=217><p>每次操作后刷新缓冲区</p></td><td valign=top width=113><p>Cerr设置,其他对象不设置</p></td><td valign=top width=71><p>2</p></td></tr><tr><td valign=top width=75><p>&nbsp;</p></td><td valign=top width=76><p>uppercase</p></td><td valign=top width=217><p>字母采用大写</p></td><td valign=top width=113><p>不设置</p></td><td valign=top width=71><p>3</p></td></tr><tr><td valign=top width=75><p>&nbsp;</p></td><td valign=top width=76><p>showbase</p></td><td valign=top width=217><p>输出整数时加上进制前缀</p></td><td valign=top width=113><p>未设置</p></td><td valign=top width=71><p>4</p></td></tr><tr><td valign=top width=75><p>&nbsp;</p></td><td valign=top width=76><p>showpoint</p></td><td valign=top width=217><p>按精度输出浮点数（不够补0）</p></td><td valign=top width=113><p>未设置</p></td><td valign=top width=71><p>5</p></td></tr><tr><td valign=top width=75><p>&nbsp;</p></td><td valign=top width=76><p>showpos</p></td><td valign=top width=217><p>输出非负数时加‘+’</p></td><td valign=top width=113><p>未设置</p></td><td valign=top width=71><p>6</p></td></tr><tr><td rowspan=3 valign=top width=75><p>&nbsp;</p><p>adjustfield</p></td><td valign=top width=76><p>left</p></td><td valign=top width=217><p>加入指定字符使输出左对齐</p></td><td rowspan=3 valign=top width=113><p>&nbsp;</p><p>right</p></td><td valign=top width=71><p>7</p></td></tr><tr><td valign=top width=76><p>right</p></td><td valign=top width=217><p>加入指定字符使输出右对齐</p></td><td valign=top width=71><p>8</p></td></tr><tr><td valign=top width=76><p>Internal</p></td><td valign=top width=217><p>在符号和数值中间插入指定字符</p></td><td valign=top width=71><p>9</p></td></tr><tr><td rowspan=3 valign=top width=75><p>&nbsp;</p><p>basefield</p></td><td valign=top width=76><p>dec</p></td><td valign=top width=217><p>10进制输入/输出</p></td><td rowspan=3 valign=top width=113><p>&nbsp;</p><p>dec</p></td><td valign=top width=71><p>10</p></td></tr><tr><td valign=top width=76><p>oct</p></td><td valign=top width=217><p>8进制输入/输出</p></td><td valign=top width=71><p>11</p></td></tr><tr><td valign=top width=76><p>hex</p></td><td valign=top width=217><p>16进制输入/输出</p></td><td valign=top width=71><p>12</p></td></tr><tr><td rowspan=2 valign=top width=75><p>floatfield</p></td><td valign=top width=76><p>scientific</p></td><td valign=top width=217><p>浮点数按科学计数法输出</p></td><td rowspan=2 valign=top width=113><p>无,由浮点数量级决定</p></td><td valign=top width=71><p>13</p></td></tr><tr><td valign=top width=76><p>fixed</p></td><td valign=top width=217><p>浮点数按小数输出</p></td><td valign=top width=71><p>14</p></td></tr><tr><td valign=top width=75><p>&nbsp;</p></td><td valign=top width=76><p>boolalpha</p></td><td valign=top width=217><p>以字母格式输入和输出布尔值</p></td><td valign=top width=113><p>未设置</p></td><td valign=top width=71><p>15</p></td></tr></tbody></table><p>  下面几点额外需要注意：</p><ul><li>用的时候前面要加上<code>ios::</code></li><li>在使用<code>setf</code>设置属于某一位组的标记位时,需要提供位组作为第二个参数来将其他互斥的标记位复位,否则可能会出现设置无效的现象。并且建议用公有静态符号<code>basefield</code>、<code>adjustfield</code>和<code>floatfield</code></li><li>cout和cin初始时只有<code>ios::skipws</code>和<code>ios::dec</code>，即0010 0000 0001</li></ul><h2 id=iomanip库中的方法>iomanip库中的方法</h2><p>  iomanip中有一些控制符可以用于设置标志字：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//设定标志字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>setiosflags</span><span class=p>(</span><span class=n>ios</span><span class=o>::</span><span class=n>Flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//清除标志字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>resetiosflags</span><span class=p>(</span><span class=n>ios</span><span class=o>::</span><span class=n>Flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//设置基数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>setbase</span><span class=p>(</span><span class=kt>int</span> <span class=n>base</span><span class=p>)</span><span class=c1>//base可以取8 10 16
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//设置填充符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>setfill</span><span class=p>(</span><span class=kt>char</span> <span class=n>ch</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//设置浮点数精度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>setprecision</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//设置输出宽度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>setw</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>);</span>
</span></span></code></pre></div><p>  这些并不是函数，其用法和操纵符一样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>setiosflags</span><span class=p>(</span><span class=n>ios</span><span class=o>::</span><span class=n>left</span><span class=p>);</span>
</span></span></code></pre></div><h1 id=标准流iostream>标准流(iostream)</h1><p>  标准流用于用户与硬件之间的输入输出。它有如下几个特殊的对象：</p><ul><li><code>cin</code>：istream对象，连向键盘，从键盘读取数据</li><li><code>cout</code>：ostream对象，连向显示器，将标准流输出到屏幕上</li><li><code>cerr</code>：ostream对象，标准错误输出流，连向显式器，将错误信息“不经过缓冲区地”、“实时地”输出到屏幕上。不能重定向到文件</li><li><code>clog</code>：ostream对象，标准错误输出流，连向打印机，将错误信息输出到缓冲区，等到缓冲区刷新再输出。不能重定向到文件</li></ul><p>  除了上面几个对象外，我们不能定义自己的<code>istream</code>或<code>ostream</code>或<code>iostream</code>，因为它们并没有构造函数。</p><h2 id=未格式化的操作>未格式化的操作</h2><p>  之前，我们使用的<code>&lt;&lt;</code>和<code>>></code>会根据要 读取或写入的数据类型 来转换成对应格式，并且默认忽略空白符，这种叫格式化的IO操作。如果只是要单纯地提取字节，并且<strong>不忽略空白符</strong>，可以用底层操作，也就是未格式化的操作。</p><h3 id=单字节操作>单字节操作</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>ch</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span><span class=p>.</span><span class=n>get</span><span class=p>();</span><span class=c1>//将下一个字节作为int返回
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cin</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>ch</span><span class=p>);</span><span class=c1>//输入一个字节到ch，返回cin或0（读取到文件结束符时）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=p>.</span><span class=n>put</span><span class=p>(</span><span class=n>ch</span><span class=p>);</span><span class=c1>//输出一个ch字节
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>cin</span><span class=p>.</span><span class=n>peek</span><span class=p>();</span><span class=c1>//偷窥~以int类型返回下一个字节，但不从流中删去
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cin</span><span class=p>.</span><span class=n>unget</span><span class=p>();</span><span class=c1>//将上一个读取的字节放回去
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cin</span><span class=p>.</span><span class=n>putback</span><span class=p>(</span><span class=n>ch</span><span class=p>);</span><span class=c1>//如果上一个读取的字节是ch，就放回去
</span></span></span></code></pre></div><p>  注意，<code>cin.get()</code>和<code>cin.peek()</code>是返回一个<code>int</code>而不是<code>char</code>，这样我们就可以返回文件尾标记（<code>EOF</code>）。而<code>char</code>中每一个都表示一个真实的字符，不能表示文件尾。</p><h3 id=多字节操作>多字节操作</h3><ul><li><p><code>cin.get(char sink[], int size, char delim)</code></p><p>从cin中读取最多size个字符，如果遇到delim或文件尾则结束（delim不会读取出来，保留在流中），读取的字符存放到sink内。</p></li><li><p><code>cin.getline(char sink[], int size, char delim)</code></p><p>和上面类似，不过会读取并丢弃delim.</p></li><li><p><code>cin.read(char sink[], int size)</code></p><p>读取size个字节放入sink中，返回cin</p></li><li><p><code>cin.gcount()</code></p><p>返回上一个未格式化的操作（不包括gcount）从is读取的字节数。如果是<code>peek</code>、<code>unget</code>、<code>putback</code>，则返回0</p></li><li><p><code>cout.write(char sink[], int size)</code></p><p>将sink中size个字节存入cout中，返回cout</p></li><li><p><code>cin.ignore(int size, char delim)</code></p><p>读取并忽略最多size个字符，包括delim。与其他未格式化的操作不同，ignore有默认参数size=1, delim=eof</p></li></ul><h1 id=文件流fstream>文件流(fstream)</h1><p>  头文件<code>fstream</code>中定义了三个类：只读文件<code>ifstream</code>、只写文件<code>ofstream</code>、读写文件<code>fstream</code>。它们分别继承自<code>istream</code>、<code>ostream</code>和<code>iostream</code>，因此可以在函数参数中用文件流代替相应的标准流。</p><h2 id=打开文件>打开文件</h2><p>  我们先定义一个文件流对象，然后再将对象与文件关联起来：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//方法一
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ifstream</span> <span class=nf>infile</span><span class=p>(</span><span class=s>&#34;input.txt&#34;</span><span class=p>);</span><span class=c1>//文件名可以是c字符串或string
</span></span></span><span class=line><span class=cl><span class=c1>//方法二
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ifstream</span> <span class=n>infile</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>infile</span><span class=p>.</span><span class=n>open</span><span class=p>(</span><span class=s>&#34;input.txt&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>  文件有不同的打开方式，如下：</p><table><thead><tr><th>标识常量</th><th>值</th><th>意义</th></tr></thead><tbody><tr><td>ios::in</td><td>0x0001</td><td>读方式</td></tr><tr><td>ios::out</td><td>0x0002</td><td>写方式</td></tr><tr><td>ios::ate</td><td>0x0004</td><td>打开文件后文件指针定位到文件末尾</td></tr><tr><td>ios::app</td><td>0x0008</td><td>每次的写入内容都追加到文件末尾</td></tr><tr><td>ios::trunc</td><td>0x0010</td><td>删除文件已有内容</td></tr><tr><td>ios::nocreate</td><td>0x0020</td><td>如果文件不存在，则打开失败</td></tr><tr><td>ios::noreplace</td><td>0x0040</td><td>如果文件存在，则打开失败</td></tr><tr><td>ios::binary</td><td>0x0080</td><td>以二进制方式打开</td></tr></tbody></table><ul><li><code>ifstream</code>不能以<code>ios::out</code>打开，<code>ofstream</code>不能以<code>ifstream</code>打开；</li><li><code>ofstream</code>默认以<code>ios::out||ios::trunc</code>打开，即默认会删除原文件。要想保留源文件，可以用<code>ios::out||iot::app</code>或<code>ios::out||ios::in</code>；</li><li><code>ios::trunc</code>只能在<code>ios::out</code>设定时才能设置；并且<code>ios::trunc</code>和<code>ios::app</code>不能同时设定；</li><li>在<code>ios::app</code>模式下，即使没有指定<code>ios::out</code>，文件也会以写方式打开；</li><li>默认情况下，文件以文本模式打开</li></ul><p>  根据上面所说的，我们可以指定打开方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>fstream</span> <span class=nf>file</span><span class=p>(</span><span class=s>&#34;data.txt&#34;</span><span class=p>,</span> <span class=n>ios</span><span class=o>::</span><span class=n>in</span><span class=o>||</span><span class=n>ios</span><span class=o>::</span><span class=n>out</span><span class=o>||</span><span class=n>ios</span><span class=o>::</span><span class=n>app</span><span class=p>);</span>
</span></span></code></pre></div><p>  如果打开失败，<code>failbit</code>会被置位，此时，<code>if(file)</code>为false。一旦一个文件流与一个文件关联，再调用open会导致文件流failbit被置位，因此，要关闭后才能打开新的文件。</p><h2 id=关闭文件>关闭文件</h2><p>  当一个文件用完后，最好即使关闭，即调用<code>file.close()</code>。这样缓冲区的数据会写入文件，并添加文件结束标志，切断文件流与文件的联系。</p><p>  尽管文件流在析构时会自动调用<code>file.close()</code>（至于什么时候调用析构函数，可看之前的类基础博文），但我们最好手动写上，防止程序在中途崩溃。</p><h2 id=读写文件>读写文件</h2><p>  读写文件的操作与<code>cin</code>、<code>cout</code>类似，可以用<code>>></code>、<code>&lt;&lt;</code>。</p><p>  当然，<code>file.get()</code>、<code>file.getline()</code>等函数也是可以用的。</p><p>  如果移动读指针用<code>seekg()</code>，写指针用<code>seekp()</code>，这和前面也是一样的。</p><p>  唯一有点麻烦的是二进制文件，我们只能通过下面这种方法写入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ofstream</span> <span class=nf>outfile</span><span class=p>(</span><span class=s>&#34;data&#34;</span><span class=p>,</span> <span class=n>ios</span><span class=o>::</span><span class=n>binary</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>data</span><span class=o>=</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>file</span><span class=p>.</span><span class=n>write</span><span class=p>(</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=p>);</span><span class=c1>//将&amp;data以及后面总共sizeof(data)的数据写入
</span></span></span></code></pre></div><p>  而且读二进制文件也要这样读：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ifstream</span> <span class=nf>infile</span><span class=p>(</span><span class=s>&#34;data&#34;</span><span class=p>,</span> <span class=n>ios</span><span class=o>::</span><span class=n>binary</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>file</span><span class=p>.</span><span class=n>write</span><span class=p>(</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=p>);</span><span class=c1>//将sizeof(data)的数据写入&amp;data以及后面的空间
</span></span></span></code></pre></div><h1 id=串流strstreamsstream>串流(strstream/sstream)</h1><p>  串流有两类，一类是以C类型字符串为流的<code>strstream</code>，一类是以string为流的<code>sstream</code>。串流用起来与<code>cin</code>和<code>cout</code>没什么不同（毕竟是由它俩派生的嘛~），不过原理上，串流是将数据以字符串的格式储存，再将字符串格式的数据输出到数据中，因此它很适合当“中间类”。比如要一次读文件的一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ifstream</span> <span class=nf>infile</span><span class=p>(</span><span class=s>&#34;input.txt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>stringstream</span> <span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>infile</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>infile</span><span class=p>.</span><span class=n>getline</span><span class=p>(</span><span class=n>line</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ss</span><span class=o>&lt;&lt;</span><span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=更多拓展知识>更多拓展知识</h1><ul><li><a href=https://www.runoob.com/cplusplus/cpp-basic-input-output.html>C++基本的输入输出</a></li><li><a href=https://www.cnblogs.com/reasno/p/4875656.html>C++: ios标志位</a></li></ul><div id=cnblogs_post_body><p>&nbsp;</p><p>&nbsp;</p><div class=table-box><table border=1 cellpadding=0 cellspacing=0 width=747><tbody><tr><td rowspan=2 width=125><p align=center><strong>文件流</strong></p></td><td colspan=2 width=257><p align=center><strong>ios::app</strong></p></td><td colspan=2 width=257><p align=center><strong>ios::ate</strong></p></td></tr><tr><td width=142><p align=center><strong>打开方式</strong></p></td><td width=115><p align=center><strong>结果</strong></p></td><td width=149><p align=center><strong>打开方式</strong></p></td><td width=108><p align=center><strong>结果</strong></p></td></tr><tr><td rowspan=2 width=125 style=text-align:center><p><strong>ofstream</strong></p><p>(默认是ios::in | ios::trunc)</p></td><td width=142><p>ios::app或ios::app|ios::out</p></td><td width=115><p>如果没有文件，生成空文件；</p><p>如果有文件，在文件尾追加</p></td><td width=149><p>ios::ate或ios::ate|ios::out</p></td><td width=108><p>如果没有文件，生成空文件；</p><p>如果有文件，清空该文件</p></td></tr><tr><td width=142><p>ios::app|ios::in</p></td><td width=115><p>不管有没有文件，都是失败</p></td><td width=149><p>ios::ate|ios::in</p></td><td width=108><p>如果没有文件，打开失败；</p><p>如果有文件，定位到文件尾，可以写文件，但是不能读文件</p></td></tr><tr><td rowspan=2 width=125 style=text-align:center><p><strong>Ifstream</strong></p><p>(默认是ios::in)</p></td><td width=142><p>ios::app或ios::app|ios::out</p></td><td width=115><p>不管有没有文件，都是失败</p></td><td width=149><p>ios::ate或ios::ate|ios::out</p></td><td width=108><p>如果没有文件，打开失败；<br>如果有文件，定位到文件尾，但是不能写文件</p></td></tr><tr><td width=142><p>ios::app|ios::in</p></td><td width=115><p>?</p></td><td width=149><p>ios::ate|ios::in</p></td><td width=108><p>?</p></td></tr><tr><td rowspan=3 width=125 style=text-align:center><p><strong>fstream</strong></p><p>(默认是ios::in | ios::out)</p></td><td width=142><p>ios::app|ios::out</p></td><td width=115><p>如果没有文件，创建文件；</p><p>如果有文件，在文件尾追加</p></td><td width=149><p>ios::ate|ios::out</p></td><td width=108><p>如果没有文件，创建文件；</p><p>如果有，清空文件</p></td></tr><tr><td width=142><p>ios::app|ios::in</p></td><td width=115><p>如果没有文件，失败</p></td><td width=149><p>ios::ate|ios::in</p></td><td width=108><p>如果没有文件，失败</p></td></tr><tr><td width=142><p>N/A</p></td><td width=115><p>N/A</p></td><td width=149><p>ios::ate|ios::out|ios::in</p></td><td width=108><p>如果没有文件，打开失败，</p><p>如果有文件，定位到文件尾</p></td></tr><tr><td width=125 style=text-align:center><p><strong>总结</strong></p></td><td colspan=2 width=257><p>ios::app不能和ios::in相配合,</p><p>但可以和ios::out配合，打开输入流</p></td><td colspan=2 width=257><p>ios::ate可以和ios::in配合，此时定位到文件尾；</p><p>如果没有ios::in相配合而只是同ios::out配合，那么将清空原文件；</p></td></tr><tr><td width=125 style=text-align:center><p><strong>区别</strong></p></td><td colspan=2 width=257><p>app会在每次写操作之前都把写指针置于文件末尾，</p></td><td colspan=2 width=257><p>而ate模式则只在打开时才将写指针置于文件末尾。在文件操作过程中，可以通过seekp等操作移动指针位置。</p></td></tr><tr><td width=125 style=text-align:center><p><strong>例子：</strong></p><p>多个线程或者进程对一个文件写的时候,假如文件原来的内容是abc</p><p>&nbsp;</p></td><td colspan=2 width=257><p>以ios::app：</p><p>第一个线程(进程)往里面写了个d,第二个线程(进程)写了个e的话，结果是abcde</p></td><td colspan=2 width=257><p>以ios:ate：</p><p>后面写的会覆盖前面一个写的，第一个线程(进程)往里面写了个d,第二个线程(进程)写了个e的话，结果为abce</p></td></tr></tbody></table></div><p>&nbsp;</p><p>参考：</p><p><a href=http://bbs.csdn.net/topics/70007597 rel=nofollow target=_blank>CSDN：ios::app与ios::ate打开方式有什么不同</a></p><p><a href=http://utensil.iteye.com/blog/372138 rel=nofollow target=_blank>ofstream与ate的故事</a></p></div><p>吐槽：</p><p>2019/6/4 C++考试完全没考到这一部分的知识，有点失望（我干嘛要复习一天这个啊！）</p></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
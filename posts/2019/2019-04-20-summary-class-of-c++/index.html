<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>对C++类的整理(1)——类基础 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2019/2019-04-20-summary-class-of-c++/>对C++类的整理(1)——类基础</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">对C++类的整理(1)——类基础</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2019-04-20</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>想象我们经营一家书店，需要对每本书的销售数据进行统计，我们将编写一个<code>Sales_data</code>，来完成这件事，并过一次类的基础知识。</p></blockquote><h1 id=类的简介>类的简介</h1><p>  类的本质上是一种<strong>自定义的数据类型</strong>，它基本组成为(D, S, P)，D为数据对象，S为D上的关系集，P为对D的基本操作。简单来讲，就是：<strong>类=数据+操作</strong>。</p><p>  类的声明以关键字<code>struct</code>开始（也可以用<code>class</code>，区别后面会讲。），紧跟着类名和类体（类体可为空）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//类体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>  <span class=c1>//不要漏了分号！
</span></span></span></code></pre></div><p>  每个类内部是一个新的作用域，所以其内部定义的名字可以和外部重复。</p><hr><h1 id=数据成员>数据成员</h1><p>  类内数据的定义方法和类外相同，比如我们的销售数据要有每本书的编号bookNo，卖出的数量units_sold，收到的钱revenue。如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>bookNo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>units_sold</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>revenue</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>  我们可以为数据成员提供<strong>初始值</strong>（就像上面的units_sold和revenue）,没有初始值的成员将被默认初始化（如bookNo将为空字符串）。</p><p>  如果要在类外使用数据成员，只需在类类型后面加“.变量”：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span> <span class=n>data1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>data1</span><span class=p>,</span><span class=n>revenue</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>//输出0.0
</span></span></span></code></pre></div><hr><h1 id=成员函数>成员函数</h1><p>  成员函数的声明在类内，定义则可以在类内或内外（如果在类内，则自动是内联的），在内外定义时要指明函数的作用域（因为类本身就是一个作用域）。比如我们给销售数据类加点东西：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>isbn</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=n>bookNo</span><span class=p>;}</span><span class=c1>//返回isbn码 //类内声明+定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=nf>avg_price</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span><span class=c1>//返回平均售价 //类内声明，注意不要忘了&#34;;&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>//下面的是数据成员
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>bookNo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>units_sold</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>revenue</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>Sales_data</span><span class=o>::</span><span class=n>avg_price</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span><span class=c1>//类外定义，注意不要忘了&#34;::&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>units_sold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=k>return</span> <span class=n>revenue</span><span class=o>/</span><span class=n>units_sold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=this-指针>this 指针</h2><p>  调用成员函数时，用<code>类名.函数名()</code>的形式。当我们调用成员函数时，实际上是替某个具体对象调用它，为了使成员函数知道使哪个具体对象调用它，C++规定了一个名为<code>this</code>的隐式参数，当编译时，具体对象的地址会传入<code>this</code>。比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>Sales_data</span> <span class=n>total</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>total</span><span class=p>.</span><span class=n>isbn</span><span class=p>();</span><span class=err>#伪代码，相当于：</span><span class=n>Sales_data</span><span class=o>::</span><span class=n>isbn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>total</span><span class=p>)</span>
</span></span></code></pre></div><p>  如果你的类类型是一个常量类（即具体化类时用了const），由于this指针是一个指向非常量的常量指针，所以不能绑定到常量对象上。此时可以通过在函数后面加const，使this能指向常量。比如上上面的<code>isbn()</code>。推荐凡是不改变类数据的函数都加上const</p><p>  最后说一句，this是隐式参数意味着我们不能定义this，但我们依然可以在函数内使用或返回this指针，比如上面<code>isbn()</code>可以写成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>isbn</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>bookNo</span><span class=p>;}</span>
</span></span></code></pre></div><hr><h1 id=构造函数>构造函数</h1><p>  构造函数是特殊的成员函数，其任务是初始化类对象的数据成员，如果在构造函数中没有对数据成员</p><p>初始化，则编译器会对数据成员赋默认值。构造函数有几个特点：</p><ul><li>必须声明在public部分（否则无法在类外使用）</li><li>构造函数的名字与类名相同；</li><li>构造函数不能声明为const（声明成const了还怎么初始化数据成员的值?）；</li><li>没有返回值。</li></ul><p>  当然，它也具有其他普通函数的特点，比如重载，比如默认实参等。</p><h2 id=默认构造函数>默认构造函数</h2><p>  如果不对数据成员提供初始值，则通过<strong>默认构造函数</strong>来初始化，它无须任何实参（也就没任何形参或所有形参都有默认实参）。如果我们没有定义构造函数，则编译器会隐式定义一个<strong>合成的默认构造函数</strong>，它会将按照一定规则默认初始化数据成员。</p><p><strong>但是某些类不能用合成的默认构造函数，具体有如下几种类</strong>：</p><ul><li>只要我们定义了构造函数，无论是否是默认构造函数，编译器都不会生成合成的默认构造函数；</li><li>数据成员含有数组和指针时，其默认初始化的值是未定义的，因此需要在类内初始化，或定义一个自己的默认构造函数；</li><li>如果类中包含其他类型的成员且这个成员的类型没有默认构造函数，则编译器无法默认初始化该成员。</li></ul><h3 id=default>default</h3><p>  如果我们定义的默认构造函数和合成的默认构造函数干的事差不多，则可以直接在构造函数的声明（或定义）的参数括号后写上<code>= default;</code></p><p>  值得注意的是，如果你的编译器不支持类内初始值，你就不能这样写。</p><h2 id=构造函数初始值列表初始化>构造函数初始值列表/初始化</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span><span class=o>:</span> <span class=n>bookNo</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><p>  像上面一样，我们可以在默认函数的括号后面加<code>数据成员(形参)</code>来初始化数据成员，在这里其相当于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>bookNo</span><span class=o>=</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>  如果要对多个数据成员初始化，它们之间用逗号隔开：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>n</span><span class=p>,</span> <span class=kt>double</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span> <span class=n>bookNo</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=n>units_sold</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>revenue</span><span class=p>(</span><span class=n>p</span><span class=o>*</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><p>  因为这些构造函数的唯一的作用是赋初值，所以函数体可以为空。在定义类时写成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span> <span class=nf>data1</span><span class=p>(</span><span class=s>&#34;978-7-121-15535-2&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=初始化与赋值的区别>初始化与赋值的区别</h3><ul><li>如果数据成员是const或引用或“某种未提供默认构造函数的类类型”，则只能用初始化；</li><li>在底层中，实际是先初始化后赋值，所以初始化的效率比较高。</li></ul><p>  所以尽量使用初始化。</p><h3 id=类的包含>类的包含</h3><p>  （待定）</p><h3 id=初始化的顺序>初始化的顺序</h3><p>  成员的初始化顺序与它们在类定义中的出现顺序一致，尽管知道顺序，但还是尽量避免使用一个数据成员初始化另一个数据成员。</p><h2 id=复制构造函数拷贝构造函数>复制构造函数（拷贝构造函数）</h2><p>  如果要通过另一个类类型来初始化，则需要通过复制构造函数将数据复制过来。复制构造函数的声明为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>Sales_data</span> <span class=o>&amp;</span> <span class=p>);</span> <span class=c1>//形参为必须是引用，且最好是常引用，避免误修改。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>  下面是复制构造函数的两种使用方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>Sales_data</span> <span class=n>data1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Sales_data</span> <span class=nf>data2</span><span class=p>(</span><span class=n>data1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Sales_data</span> <span class=n>data3</span><span class=o>=</span><span class=n>data1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Sales_data</span> <span class=n>data4</span><span class=o>=</span><span class=p>{</span><span class=s>&#34;9-999-99999-9&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=err>。</span><span class=mi>0</span><span class=p>};</span><span class=c1>//注意：这种写法只适用于聚合类（仅有数据成员而无成员函数的类）
</span></span></span></code></pre></div><p>  除了主动调用复制构造函数，当函数<strong>有类类型参数</strong>或<strong>返回类类型值</strong>时，都需要隐式地调用复制构造参数（即用到临时的类类型时都要），即：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>Sales_data</span> <span class=nf>function</span><span class=p>(</span><span class=n>Sales_data</span> <span class=n>a</span><span class=p>){</span> <span class=c1>//调用复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>a</span><span class=p>;</span><span class=c1>//调用复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>  上面这段也是复制构造函数的参数必须是引用的原因。如果不是引用，则会建立临时量，而临时量本身又需要用到复制构造函数，从而造成循环。</p><h3 id=浅复制和深复制>浅复制和深复制</h3><p>  其实如果我们不写复制构造函数，编译器会隐式生成一个复制构造函数，但这个只能复制字面值（即类的数据成员储存的数据），即int就复制int，int* 就复制地址。这就叫浅复制。</p><p>  浅复制有个问题，就是如果要复制指针，则只是复制指针所指的地址，而不分配内存空间（因为这个内存空间并不储存在类内）。如果复制得到的对象被析构了，那么原对象的指针就会指向空地址，等到原对象析构时，就会产生“释放空指针”的错误。</p><p>  所以我们需要深复制：手动写一个复制构造函数，在复制构造函数里面分配新的内存空间，再复制。即</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>//我们另外一个类来示范
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//数据成员
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>;</span> <span class=c1>//分配新的内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=n>p</span><span class=o>=*</span><span class=n>a</span><span class=p>.</span><span class=n>p</span><span class=p>;</span> <span class=c1>//复制具体值，而非地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  《C++ Primer》239页：使用Vector类或string类可以避免分配和释放内存带来的复杂性。</p><h3 id=delete禁止复制>delete（禁止复制）</h3><p>  如果我们不希望编译器为我们隐式生成一个复制构造函数（某些对象复制是没意义的，比如iostream，见《C++ Primer》449页），我们可以在第一次声明时，在参数的括号后面加<code>=delete</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>NoCopy</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopy</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopy</span><span class=p>(</span><span class=k>const</span> <span class=n>NoCopy</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopy</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>NoCopy</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  <code>delete</code>不仅适用于隐式的复制构造函数，也适用于其他隐式生成的函数（比如上面的拷贝赋值运算符的重载），析构函数除外。</p><p>  另外，还有一种方法禁止复制，那就是将复制构造函数声明在<code>private</code>中，并且不定义它。这样在编译的过程中就会出错。尽量不要用这种方法，而是用<code>delete</code></p><h2 id=委托构造函数>委托构造函数</h2><p>  就是一个构造函数用其他构造函数来初始化。比如假如我们定义了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>n</span><span class=p>,</span> <span class=kt>double</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span> <span class=n>bookNo</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=n>units_sold</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>revenue</span><span class=p>(</span><span class=n>p</span><span class=o>*</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><p>  我们可以利用这个来定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span><span class=o>:</span> <span class=n>Sales_data</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{}</span><span class=c1>//委托构造函数
</span></span></span></code></pre></div><p>  这样，当运行后面这个构造函数时，实际上是先执行第一个构造函数，再执行后面这个。</p><h2 id=隐式类类型转换>隐式类类型转换</h2><p>  假如我们有某个函数需要接收一个Sales_data对象，而Sales_data有一个这样的构造函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>function</span><span class=p>(</span><span class=k>const</span> <span class=n>Sales_data</span> <span class=o>&amp;</span><span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sales_data</span><span class=o>::</span><span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span><span class=o>:</span> <span class=n>Sales_data</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><p>  我们传递一个string对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>function</span><span class=p>(</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;9-999-99999-9&#34;</span><span class=p>));</span>
</span></span></code></pre></div><p>  编译器会先掉用构造函数，生成一个临时的Sales_data，由于item是一个常量引用，我们可以把临时变量传递给item。</p><p>  另一种用到隐式类类型转换的情况是拷贝：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Sales_data</span> <span class=n>item</span><span class=o>=</span><span class=s>&#34;9-999-99999-9&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>  这种方法只能适用于只有一个变量的构造函数；并且只能适用于“一步的类类型转换”，比如下面这种就不行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>function</span><span class=p>(</span><span class=s>&#34;9-999-99999-9&#34;</span><span class=p>);</span><span class=c1>//两步转换，先是将&#34;9-999-99999-9&#34;转化为string，然后再将string转化为Sales_data
</span></span></span></code></pre></div><h3 id=抑制隐式类类型转换>抑制隐式类类型转换</h3><p>  要是我们想禁止这种转换（比如我们想对“=”进行重载），我们可以在构造函数的<strong>声明</strong>前加<code>explicit</code>来阻止（在定义处加explicit会报错）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>explicit</span> <span class=n>Sales_data</span><span class=o>::</span><span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span><span class=o>:</span> <span class=n>Sales_data</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><p>  注意，<code>explicit</code>只能用于只有一个参数的构造函数（有多个参数怎么进行类类型转换啊~）。在这种情况下，我们依然可以显式的使用构造函数来转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>function</span><span class=p>(</span> <span class=n>string</span><span class=p>(</span><span class=s>&#34;9-999-99999-9&#34;</span><span class=p>)</span> <span class=p>);</span><span class=c1>//错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>function</span><span class=p>(</span> <span class=n>Sales_data</span><span class=p>(</span> <span class=n>string</span><span class=p>(</span><span class=s>&#34;9-999-99999-9&#34;</span><span class=p>)</span> <span class=p>)</span> <span class=p>);</span><span class=c1>//正确
</span></span></span></code></pre></div><hr><h1 id=析构函数>析构函数</h1><p>  析构函数是特殊的成员函数，与构造函数相反，其任务是销毁类对象的数据成员。析构函数的基本特点是：</p><ul><li>名字由波浪号+类名构成，比如<code>~Sales_data();</code></li><li>不接受参数，不能重载，也不返回值。因此每个类只有一个析构函数；</li><li>首先执行函数体，之后按初始化顺序的逆序销毁成员；</li></ul><p>  析构函数被调用的时机：</p><ul><li>变量离开作用域时；</li><li>对象被销毁时；</li><li>动态分配的对象（<code>new</code>），对指向它的指针用<code>delete</code>运算符时；</li><li>临时对象，当创建它的表达式结束时；</li></ul><p>  特别的，当指向对象的引用或指针离开作用域时，并不会调用析构函数。</p><h2 id=合成的析构函数>合成的析构函数</h2><p>  当一个类未定义析构函数时，编译器会为它定义一个合成的析构函数，合成的析构函数等价于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>sales_data</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  注意到它的函数体为空。在此再次强调：无论函数体是否为空，析构函数<strong>首先执行函数体，之后按初始化顺序的逆序销毁成员</strong>。也就是说析构函数内的内容对后面的析构无影响。</p><h2 id=析构指针对象>析构指针对象</h2><p>  销毁一个指针时，指针所指向的对象并不会被删除。因此如果要析构指针，要手动<code>delete</code>它所指的对象。我们这里的指针是内置的指针类型，C++还有一种“智能指针”，它可以自动销毁，无需手动<code>delete</code>。</p><hr><h1 id=访问控制和封装>访问控制和封装</h1><p>  为了限制用户对类的访问权限，可以利用<strong>访问说明符</strong>：<code>public</code>、<code>protected</code> 和<code>private</code>（<code>protected</code>后面再讲）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span><span class=c1>//以下整个程序内可被访问//公有成员
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Sales_data</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Sales_data</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>n</span><span class=p>,</span> <span class=kt>double</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span> <span class=n>bookNo</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=n>units_sold</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>revenue</span><span class=p>(</span><span class=n>p</span><span class=o>*</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span><span class=c1>//以下可被类的成员函数访问
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>bookNo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>units_sold</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>revenue</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  特别的，如果在访问说明符前声明数据成员或成员函数，对于<code>struct</code>则默认为<code>public</code>，对于<code>class</code>则默认为<code>private</code>。这是<code>struct</code>和<code>class</code>唯二的区别（另一个在继承那里）。</p><h2 id=友元>友元</h2><p>  如果希望类外的某个函数，或其他类能访问非公有成员，可以将其声明为友元，声明的位置不限（可以在public或private等）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sales_data</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>friend</span> <span class=n>Sales_data</span> <span class=nf>add</span><span class=p>(</span><span class=k>const</span> <span class=n>Sales_data</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>Sales_data</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>read</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span><span class=p>,</span> <span class=n>Sales_data</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sales_data</span> <span class=nf>add</span><span class=p>(</span><span class=k>const</span> <span class=n>Sales_data</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>Sales_data</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>read</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>&amp;</span><span class=p>,</span> <span class=n>Sales_data</span><span class=o>&amp;</span><span class=p>);</span>
</span></span></code></pre></div><p>  最好在类定义开始或结束前的位置集中声明友元。注意，友元的声明仅指定了访问权限，并非函数声明，我们还是需要在类外声明函数。另外，友元必须和类在同一个作用域内。</p><p>  如果想要将某个类的成员函数声明为友元，必须仔细组织代码结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>function</span><span class=p>();</span><span class=c1>//声明，但不定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>void</span> <span class=n>A</span><span class=o>::</span><span class=n>function</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>A</span><span class=o>::</span><span class=n>function</span><span class=p>(){}</span><span class=c1>//在A声明了友元后再定义，这样才能访问到A
</span></span></span></code></pre></div><h1 id=其他成员>其他成员</h1><h2 id=可变数据成员>可变数据成员</h2><p>  如果我们想要修改类的某个数据成员，即使是在一个const成员函数内。可以在变量的声明前加入<code>mutable</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>function</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span><span class=err>、</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>A</span><span class=o>::</span><span class=n>function</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=静态成员>静态成员</h2><h3 id=声明和定义>声明和定义</h3><p>  对于一般的数据成员，每个类类型都有自己的版本；而有时候我们希望所有的类类型都共有一个数据成员（也就只有一个版本）。可以在变量的声明前加入<code>static</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>10</span><span class=p>;</span><span class=c1>//在类内声明并提供初始值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>A</span><span class=o>::</span><span class=n>a</span><span class=p>;</span><span class=c1>//在类外定义，不再指定初始值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>A</span><span class=o>::</span><span class=n>b</span><span class=o>=</span><span class=mi>20</span><span class=p>;</span><span class=c1>//在类外定义//不要忘了int
</span></span></span></code></pre></div><p>  静态成员不能通过特定的类类型去初始化，必须在类内声明，在类外定义（在类外定义时不能加<code>static</code>）。在类内声明时，可以提供一个初始值，这样在类外定义时就不能再指定初始值。静态成员实际上类似于全局变量（因为在程序中有且只有一个），所以我们<strong>必须在类外定义</strong>，这样编译器才能为它分配空间。</p><h3 id=使用>使用</h3><p>  有两种方式使用静态成员：通过类，或通过某一类类型</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>A</span> <span class=n>sample</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>A</span><span class=o>::</span><span class=n>a</span><span class=o>=</span><span class=mi>20</span><span class=p>;</span><span class=c1>//通过“类::静态成员”访问
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sample</span><span class=p>.</span><span class=n>a</span><span class=o>=</span><span class=mi>20</span><span class=p>;</span><span class=c1>//通过某一的类类型访问
</span></span></span></code></pre></div><h3 id=特殊>特殊</h3><p>  静态成员可以是不完全类型（仅声明而未定义的类），比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>A</span> <span class=n>c</span><span class=p>;</span><span class=c1>//如果c不是静态成员，这种写法是错误的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>A</span><span class=o>::</span><span class=n>c</span><span class=o>=</span><span class=c1>//略
</span></span></span></code></pre></div><p>  而且其他成员函数可以将静态成员作为默认实参：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>function</span><span class=p>(</span><span class=kt>int</span> <span class=o>=</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>A</span><span class=o>::</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>A</span><span class=o>::</span><span class=n>function</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=o>=</span><span class=n>a</span><span class=p>){}</span><span class=c1>//略
</span></span></span></code></pre></div></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
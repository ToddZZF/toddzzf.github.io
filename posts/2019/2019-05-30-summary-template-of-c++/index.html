<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>对C++模板的整理 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2019/2019-05-30-summary-template-of-c++/>对C++模板的整理</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">对C++模板的整理</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2019-05-30</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>模板真的是绕晕我了……</p></blockquote><h1 id=函数模板>函数模板</h1><h2 id=定义函数模板>定义函数模板</h2><p>  普通的函数只能接受指定类型的参数，比如我们定义一个<code>int compare(int, int);</code>来比较大小，则我们只能比较两个整型的大小，如果需要比较浮点数的大小，则需要重新写一个新的函数，但新的函数和原函数做的事情其实是一样的。为了提高代码的复用率，故需要用<code>模板</code>。</p><p>  我们可以定义一个这样的模板：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=o>&lt;</span><span class=n>b</span><span class=p>)</span><span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=o>&gt;</span><span class=n>b</span><span class=p>)</span><span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>  第一行以关键字<code>template</code>开始，后面跟着模板参数列表<code>&lt;typename T1, typename T2, ...></code>（旧的C++标准用<code>&lt;class T1, class T2, ...></code>，class和typename可以混用），每个<code>T</code>表示一种类型。</p><p>  函数模板和普通函数一样可以重载，并且我们既可以用另一个模板来重载它，也可以用普通函数来重载它。比如：</p><pre tabindex=0><code>template &lt;typename T&gt;
int compare(const T *a, const T *b){
    if(*a&lt;*b)return -1;
    if(*a&gt;*b)return 1;
    return 0;
}
</code></pre><p>  顺便说一句，<code>inline</code>和<code>constexpr</code>跟在模板参数列表后面。</p><h2 id=实例化函数模板>实例化函数模板</h2><p>  函数模板用起来和普通的函数一样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>compare</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><p>  编译器会根据实参来实例化一个特定版本的函数<code>int compare(const int&, const int&)</code>、</p><h2 id=模板参数>模板参数</h2><h3 id=类型模板参数>类型模板参数</h3><p>  类型模板参数就是我们上面的那种模板参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span></code></pre></div><p>  <code>T1</code>、<code>T2</code>称为<code>类型参数</code>，我们可以把它当作类型说明符，就像内置类型一样使用，特别是，它可以用为返回类型、参数类型、函数内的变量声明和类型转换。</p><h3 id=非类型模板参数>非类型模板参数</h3><p>  非类型参数表示一个值而非类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>N</span><span class=p>,</span> <span class=kt>int</span> <span class=n>M</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>//不能这样写：template&lt;N, M&gt;
</span></span></span></code></pre></div><p>  非类型参数可以是一个整型，或指向对象或函数类型的指针或引用绑定。绑定到非类型整型参数的实参必须是常量表达式；绑定到指针、引用的非类型参数的实参必须具有静态的生存期。在模板定义内，非类型参数是一个常量值，用在需要常量表达式的地方。比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=n>N</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>M</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>p1</span><span class=p>)[</span><span class=n>N</span><span class=p>],</span> <span class=k>const</span> <span class=kt>char</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p2</span><span class=p>)[</span><span class=n>M</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>strcmp</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>compare</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=s>&#34;World&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>  类型模板参数和非类型模板参数可以混用，但必须放在一个template&lt;>里面，因为参数模板列表只能有一个：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>function</span><span class=p>(</span><span class=n>T</span><span class=p>[</span><span class=n>N</span><span class=p>]){}</span>
</span></span></code></pre></div><h2 id=模板编译>模板编译</h2><p>  编译器只有在遇到模板实例时，才会生成代码。这与普通的函数不同。因此，在头文件中，要有下面几个部分：</p><ul><li>普通函数的声明</li><li>类定义+类中的函数的声明</li><li>函数模板的声明+定义</li><li>类模板的成员函数的定义</li></ul><h1 id=类模板>类模板</h1><p>  类模板大致上和函数模板差不多，但编译器无法通过实参推断参数类型。我们需要在模板名后的尖括号中提供额外的信息。</p><h2 id=定义类模板>定义类模板</h2><p>  和函数模板一样，都是在类名前加上<code>template &lt;[模板参数列表]></code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>number</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>number</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>)</span><span class=o>:</span><span class=n>data</span><span class=p>(</span><span class=n>i</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  我们需要手动为类模板提供<code>&lt;模板实参></code>，如果在类外定义成员函数，必须这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>number</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>getDate</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>retrurn</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>  但在类的作用域里面，我们可以不加<code>&lt;></code>，默认与类实例化的类型一致：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>number</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>number</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>  特别的，在类外的成员函数定义中，我们也无需加<code>&lt;></code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>number</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>number</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>number</span> <span class=n>temp</span><span class=o>=*</span><span class=k>this</span><span class=p>;</span><span class=c1>//默认是number&lt;T&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=使用类模板>使用类模板</h2><p>  使用类模板时，必须提供<strong>显式模板实参</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>number</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=c1>//用类模板实例化一个类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>max</span><span class=p>(</span><span class=k>const</span> <span class=n>number</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span><span class=k>const</span> <span class=n>number</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span><span class=c1>//将类模板用作参数
</span></span></span></code></pre></div><p>  就酱。</p><h2 id=类模板与友元>类模板与友元</h2><p>  类模板可以将其他普通的类或函数声明为友元（这样对所有类型的类模板都是友元，也就是多对一），也可以将另一个类模板或函数模板声明为友元。反过来，一个普通的类可以将特定类型的类模板声明为友元，也可以将所有类型的类模板声明为友元。</p><h3 id=一对一>一对一</h3><p>  可以将某一类型的类模板或某一类型的函数模板声明为友元</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=k>const</span> <span class=n>number</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>number</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>clss</span> <span class=n>number</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=k>const</span> <span class=n>number</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>number</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>  有几点要注意：</p><ul><li>为了在函数中用模板特例，我们需要先声明模板自身。也就是上面一二行。</li><li>为了让函数只能在特定类型的模板中使用，函数也要是模板函数。</li></ul><h3 id=特定的模板的友元关系>特定的模板的友元关系</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>{</span><span class=c1>//普通的类
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>friend</span> <span class=k>class</span> <span class=nc>A</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span><span class=c1>//只有int的类模板是友元
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>friend</span> <span class=k>class</span> <span class=nc>A</span><span class=p>;</span><span class=c1>//所有类模板都是友元，无需前置声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>{</span><span class=c1>//类模板
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>friend</span> <span class=k>class</span> <span class=nc>A</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span><span class=c1>//只有T的类模板是友元
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>X</span><span class=o>&gt;</span> <span class=k>friend</span> <span class=k>class</span> <span class=nc>A</span><span class=p>;</span><span class=c1>//所有类模板都是友元，无需前置声明。注意用了不同的模板参数X
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span> 
</span></span></code></pre></div><h2 id=类模板与静态成员>类模板与静态成员</h2><p>  只是说一句，静态成员<code>static</code>只在相同类型的模板类之间共享，不同类型的类模板的静态成员相互独立。</p></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>操作系统总结 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2019/2019-10-28-summary-of-os/>操作系统总结</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">操作系统总结</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2019-10-28</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>现代操作系统总结</p></blockquote><h1 id=书写规范>书写规范</h1><ol><li><p>定义与定理的格式如下：</p><p>【定义】<strong>操作系统</strong>：……</p><p>【定理】<strong>操作系统定理</strong>：……</p><p>若需要在下面写注释，则用引用的形式：</p><blockquote><p>注：……</p></blockquote></li><li><p>列表一律用有序表，而不是无序表，并且每一项若有标题，则标题粗体</p></li><li><p>凡是有一定”步骤“的算法，均使用类 c 写：</p><p>【方法】：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>//如果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//循环
</span></span></span></code></pre></div></li></ol><h1 id=课程结构>课程结构</h1><p>资源管理的角度：</p><ol><li>硬件资源<ol><li>处理器</li><li>存储器</li><li>I/O 设备</li></ol></li><li>软件资源<ol><li>文件</li></ol></li></ol><p>软件工程的角度：</p><ol><li>进程管理子系统</li><li>存储管理子系统</li><li>I/O 设备管理子系统</li><li>文件管理子系统</li></ol><p>对每个子系统：</p><ol><li>基本功能</li><li>高效运行</li></ol><h1 id=一些常识>一些常识</h1><h2 id=单位换算>单位换算</h2><p>B, Byte 字节</p><p>KB, Kilobyte 千字节 = $2^{10}$ B（ $1024$ B）</p><p>MB, Megabyte 兆字节 = $2^{10}$ KB</p><p>GB, Gigabyte 千兆字节 = $2^{10}$ MB</p><p>TB, Terabyte 太兆字节 = $2^{10}$ GB</p><h2 id=系统启动的过程>系统启动的过程</h2><ol><li>加电或复位</li><li>BIOS（Basic I/O System）</li><li>Boot Loader</li><li>操作系统初始化</li></ol><h1 id=第一章-引论>第一章 引论</h1><p>一些概念：</p><p>计算机的两种运行模式：</p><ol><li>内核态、管态 —— 操作系统 —— 对所有硬件具有完全访问权</li><li>用户态 —— 软件 —— 只能使用机器指令中的一个子集</li></ol><p>操作系统的功能/作用/目的：</p><ol><li>从用户的观点：作为用户与计算机之间的硬件接口</li><li>从系统管理员的观点：作为资源管理者，实现资源在时间和空间上的共用</li><li>从发展的观点：作为扩展机器，给计算机的功能扩展提供支持平台</li></ol><h2 id=操作系统的历史4>操作系统的历史4</h2><ol><li><p>1945~1955：真空管和穿孔卡片</p></li><li><p>1955~1965：晶体管和<strong>批处理系统</strong></p><ol><li>新技术：<ol><li>I/O 与计算并行：中断技术</li><li>多道程序设计：存储保护技术</li></ol></li><li>特点：<ol><li>用户脱机使用计算机</li><li>成批处理作业</li><li>多道程序运行</li></ol></li></ol></li><li><p>1965~1980：集成电路和多道程序设计
<strong>分时操作系统</strong></p><ol><li>新技术：时间片轮转技术（抢占式、剥夺式）</li><li>特点：<ol><li>交互性</li><li>多用户</li><li>独立性</li></ol></li></ol></li><li><p>1980~至今：个人计算机
<strong>实时操作系统</strong>（嵌入式计算）</p><ol><li>新技术：？</li><li>特点：<ol><li>即时响应</li><li>高可靠性</li></ol></li></ol><p>下面说几个重要的操作系统：</p></li><li><p>MULTICS：分时操作系统，幻想用一台机器满足整个波士顿地区用户的需求，虽然失败，但对后续的操作系统影响深远</p></li><li><p>UNIX：由参与 MULTICS 研制的贝尔实验室科学家 Ken Thompson 开发，它有两个重要的分支：</p><ol><li>BSD（Berkelet Software Distribution）：由加州大学伯克利分校开发，它有一个重要的分支：MACH，是第一个微内核的 OS，也是第一个用软件工程开发的 OS。MACH 又有一个重要的分支：苹果的 NeXT，也就是 Mac OS 的前身</li><li>Linux：由芬兰学生 Linux Torvalds 开发，目前使用最广的系统</li></ol></li><li><p>Windows：微软的操作系统，最古老的是 MS-DOS，但我们现在使用的 Windows10 起源于 Windows NT，而不是 MS-DOS，因为它俩的内核完全不同</p><p><img src=http://www.ha97.com/wp-content/uploads/2010/08/Unix_history.png alt title="Unix 家谱"></p></li></ol><h1 id=第二章-进程和线程>第二章 进程和线程</h1><p>一个非常重要的概念：</p><ol><li><p><strong>并行</strong>： 指两个或两个以上进程在 <strong>同一时刻</strong> 运行</p><p><img src=http://img1.51cto.com/attachment/201201/162405177.jpg alt></p></li><li><p><strong>并发</strong>：指两个或两个以上进程共享一个 CPU，在 <strong>同一时间段</strong> 运行，但在同一时刻只有一个进程运行</p><p><img src=http://img1.51cto.com/attachment/201201/162405567.jpg alt></p></li></ol><h2 id=进程的基本概念>进程的基本概念</h2><h3 id=进程的状态>进程的状态</h3><p>三状态：</p><ol><li>运行态：实际占用 CPU</li><li>就绪态：可运行，但不在 CPU 上</li><li>阻塞态：因等待某个事件（比如用户输入）而睡眠</li></ol><p>如果算上初始和终止，则为五状态：</p><p><img src=https://img-blog.csdn.net/20160606074023862 alt></p><p>在实际中，为七状态，多了两种状态：</p><ol start=4><li>挂起阻塞状态</li><li>挂起就绪状态</li></ol><p>挂起指的是：在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存，重新进入等待被执行的状态即就绪态。</p><p><img src=https://images2015.cnblogs.com/blog/901563/201610/901563-20161005233303973-1591989545.png alt></p><p>在此引入三级调度的概念：</p><ol><li>高级调度（作业调度）：程序从硬盘上变为进程（创建到就绪）</li><li>中级调度（内存调度）：进程从内存上转移到硬盘swap space上（挂起/释放）</li><li>低级调度（进程调度）：内存内的进程轮流上下 CPU（就绪/执行）</li></ol><h3 id=进程的描述>进程的描述</h3><p>进程的静态描述由 3 部分组成：</p><ol><li>进程控制块（PCB，process control block）：PCB是系统感知进程的唯一实体，PCB的全部或部分常驻内存。PCB 包含以下信息：<ol><li>描述信息：<ol><li>进程名/进程标识号 PID</li><li>用户名/用户标识号</li><li>进程间的家族关系</li></ol></li><li>控制信息<ol><li>当前状态（初始、就绪、执行、等待、终止）</li><li>进程优先级</li></ol></li><li>资源信息<ol><li>占用内存大小及数据结构指针</li><li>对换或覆盖的相关信息</li></ol></li></ol></li><li>程序段</li><li>数据集</li></ol><p><strong>进程上下文</strong>：</p><ol><li>用户级上下文：<ol><li>用户正文段（程序编译而成）</li><li>用户数据</li><li>用户栈</li></ol></li><li>寄存器级上下文<ol><li>PC 指针</li><li>PSW 寄存器</li><li>栈指针</li><li>通用寄存器</li></ol></li><li>系统级上下文<ol><li>静态部分：PCB 结构、虚地址空间映射的相关表格、核心栈</li><li>动态部分：</li></ol></li></ol><h2 id=进程间通信67>进程间通信67</h2><p>进程间通信问题，又称 <strong>IPC问题（Inter Process Communication）</strong>，包括以下三个：</p><ol><li>进程间的消息传递</li><li>进程间互斥</li><li>进程间同步</li></ol><p>下面间逐一分析。</p><h3 id=进程间互斥>进程间互斥</h3><h4 id=生产者-消费者问题>生产者-消费者问题</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define N 10 </span><span class=c1>//缓冲区中槽的数目
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>int</span> <span class=n>semaphore</span><span class=p>;</span> <span class=c1>//信号量是一种特殊的整数类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>semaphore</span> <span class=n>mutex</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>//控制对临界区的控制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>semaphore</span> <span class=n>empty</span> <span class=o>=</span> <span class=n>N</span><span class=p>;</span> <span class=c1>//空槽数目
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>semaphore</span> <span class=n>full</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>//满槽数目
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>producer</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>=</span> <span class=nf>produce_item</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nf>down</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>down</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>insert_item</span><span class=p>(</span><span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>up</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>down</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>down</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>item</span><span class=o>=</span><span class=nf>remove_item</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nf>up</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>up</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>consum_item</span><span class=p>(</span><span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=第三章-死锁>第三章 死锁</h1><h2 id=资源>资源</h2><p>资源分为：</p><ol><li>共享资源：资源可同时使用</li><li>互斥资源：资源只允许一个进程使用<ol><li>可抢占式资源：可以从拥有它的进程中抢占而不会产生副作用</li><li>不可抢占式资源：在不引起进程失败的情况下，无法从拥有它的进程中抢占过来</li></ol></li></ol><h2 id=死锁的简介249>死锁的简介249</h2><p>死锁产生的必要条件：</p><ol><li>互斥条件：资源要么分配给一个进程，要么可用</li><li>占有和等待条件：已占有资源的进程可以再请求新的资源</li><li>不可抢占条件：已占有的资源不能被抢占</li><li>环路等待条件：有两个或以上进程组成一个环路，每个进程都在等待下一个进程所占有的资源</li></ol><p>处理死锁的方法：</p><ol><li>忽略它（干脆不处理了）</li><li>检测死锁并恢复（监测发送并处理）</li><li>仔细分配资源（避免产生）</li><li>破坏死锁产生的四个条件（从源头预防）</li></ol><p>下面将说说四种情况</p><h2 id=忽略它鸵鸟算法251>忽略它（鸵鸟算法）251</h2><p>虽然听起来很扯淡，但 Linux 和 Windows 都采用这种方法</p><p>原因：</p><ol><li>死锁发生的概率很小</li><li>处理死锁的开销太大</li></ol><p>优点：</p><ol><li>方便</li><li>正确</li></ol><h2 id=检测并恢复251>检测并恢复251</h2><h3 id=check>检测</h3><p>假设每种资源只有一个：（基于图的检测算法）</p><ol><li>构造一个资源分配图</li><li>对资源分配图进行深度优先搜索</li><li>若形成了环，则形成了死锁</li><li>将所有路径都遍历一次</li></ol><p>假设每种资源有多个：（基于矩阵的检测算法）</p><ol><li><p>构造下面四种数据结构：</p><ol><li>假设有 m 种资源，则**现有资源向量（existing resource vector）**为：$\vec{E}=(E_1， E_2, \cdots , E_m)$，代表每种资源总的数量</li><li>**可用资源向量（available resource vector)**为：$\vec{A}=(A_1, A_2, \cdots, A_m)$，代表每种资源可用（未分配）的数量</li><li><strong>当前分配矩阵（current allocation matrix)</strong>：
$$
\begin{bmatrix}
C_{11} & C_{12} & \cdots & C_{1m} \
C_{21} & C_{22} & \cdots & C_{2m} \
\vdots & \vdots & & \vdots \
C_{n1} & C_{n2} & \cdots & C_{nm}
\end{bmatrix}
$$
第 $n$ 行代表进程 $n$ 已分配的资源</li><li><strong>请求矩阵（request matrix）</strong>：
$$
\begin{bmatrix}
R_{11} & R_{12} & \cdots & R_{1m} \
R_{21} & R_{22} & \cdots & R_{2m} \
\vdots & \vdots & & \vdots \
R_{n1} & R_{n2} & \cdots & R_{nm}
\end{bmatrix}
$$
第 $n$ 行代表进程 $n$ 请求的资源</li></ol></li><li><p>对进程 $i$ 运行如下算法：</p><ol><li>考察 R矩阵的第 $i$ 行，若其所有列都小于 A向量，则说明它的请求可以被满足，将这行标记</li><li>若它的请求可以被满足，则它的资源会在使用完后释放出来，故将 C矩阵的第 $i$ 行加到 A向量上</li></ol></li><li><p>对其他未标记的行重复以上算法，直到没有进程可被标记为止，没有被标记的进程即为死锁进程</p></li></ol><h3 id=恢复>恢复</h3><ol><li>利用抢占恢复：将资源从一个进程中强行取走给另一个资源使用，然后再送回。</li><li>利用回滚恢复：周期性对进程进行<strong>检查点检查（checkpointed）</strong>，储存一系列的检查点文件，一旦检测到死锁，将进程回滚到获取资源前，然后将资源分配给一个死锁进程，而其他进程要等到死锁进程结束后才能获取资源。</li><li>通过杀死进程恢复：杀死环内的进程，打破死锁；或杀死环外的进程，为环内进程提供资源。最好杀死可以从头开始运行而且不会发生副作用的进程</li></ol><h2 id=死锁避免-255>死锁避免 255</h2><p>找到一种分配顺序，使得死锁不会发生，有如下两类算法：</p><h3 id=资源轨迹图>资源轨迹图</h3><p><img src=https://raw.githubusercontent.com/mbinary/mbinary.github.io/hexo/source/images/%E8%B5%84%E6%BA%90%E8%BD%A8%E8%BF%B9%E5%9B%BE.png alt></p><ol><li>横轴代表程序A，纵轴代表程序B</li><li>“$\leftarrow!\rightarrow$ ” 代表程序需要资源的阶段</li><li>浅阴影代表两个程序同时需要打印机或绘图仪</li><li>深阴影代表两个程序出现死锁</li><li>虚线代表程序运行时分配资源的轨迹，只能从下到上，从左到右</li><li>目标就是使轨迹不要进入深阴影</li></ol><h3 id=银行家算法>银行家算法</h3><p>【定义】<strong>安全状态</strong>：对于某个时刻的资源状态，存在一种调度次序能使每一个进程运行完毕，则称该状态为安全状态，反之为不安全状态</p><blockquote><p>注：不安全状态并不代表一定会发生死锁，因为可能在运行过程中，有其他程序释放资源</p></blockquote><p><strong>银行家算法（banker&rsquo;s algorithm）</strong>：</p><ol><li>os 分配资源 = 银行家给客户贷款</li><li>在某个时刻，如果银行家无法满足任何一个客户的需求，则为不安全状态；能满足客户其中之一的要求，则为安全状态</li></ol><p>运用银行家算法检测状态是否安全的步骤同上面 <a href=#check>检测并恢复：基于矩阵的检测算法</a> 一模一样</p><h2 id=死锁预防258>死锁预防258</h2><p>破坏死锁产生的四个条件：</p><ol><li>破坏互斥条件：令资源可以被多个程序独占，采用 假脱机打印机（spooling printer），由打印机守护进程占有打印机，而其他进程向其传递打印信息。（有可能因为磁盘空间耗尽导致死锁）</li><li>破坏占有并等待条件：<ol><li>方法一（破坏等待）：规定所有进程在开始执行前请求所需的全部资源，这样它就不会等待（要求进程在开始时明确所需的全部资源，否则无法实现）。</li><li>方法二（破坏占有）：当进程请求资源时，要先释放所有占有的资源，再尝试一次获取所需的全部资源</li></ol></li><li>破坏不可抢占条件：允许抢占，但可能会出现混乱（比如打印机只打印一半）</li><li>破环环路等待条件：<ol><li>对资源编号，进程必须先请求编号小的资源（考虑只有两个进程，两种资源的死锁即可理解）；</li><li>另一种变种是进程不允许请求编号比当前所占有资源编号小的资源（道理同上）</li></ol></li></ol><h2 id=活锁不考261>活锁（不考）261</h2><p>两个进程出现了死锁，于是它们都释放了自己的资源，然后又同步的获取资源，于是又出现了死锁。最终它俩步调一致地同时给对方让路，导致谁也无法前进。</p><p>活锁与死锁的区别是：进程发生死锁后，会进入阻塞状态；但发生活锁，不会发生阻塞，只会空耗 CPU 直到时间片用完。</p><h2 id=饥饿262>饥饿262</h2><p>进程有不同的优先级，优先级高的能先分配到资源，会导致优先级低的一直分配不到资源（一直被插队）</p><h1 id=第四章-内存管理>第四章 内存管理</h1><p>程序在内存中的安排方法可以分为：</p><ol><li>连续：一个程序占据连续的一段内存空间<ol><li>分区技术：简单/虚拟</li></ol></li><li>离散：一个程序占据离散的内存空间<ol><li>分页技术：简单/虚拟</li><li>分段技术</li></ol></li></ol><p>简单指的是：进程要运行时，全部装入内存才能运行；虚拟指的是：进程只装入需要的部分</p><h2 id=一些术语>一些术语：</h2><h3 id=多级存储体系>多级存储体系</h3><p><img src=https://images0.cnblogs.com/blog2015/732320/201506/291624468216459.jpg alt></p><p>三级层次：</p><ol><li>高速缓冲存储器 cache</li><li>主存储器 memory</li><li>辅助存储器 I/O</li></ol><p>为什么：① 为了解决对存储器要求容量大，速度快，成本低三者之间的矛盾 ② 为了缓解主存储器读写速度慢，不能满足CPU运行速度需要的矛盾</p><h3 id=交换技术106>交换技术106</h3><p>【定义】<strong>交换（swap）技术</strong>：将内存中处于等待的进程换出内存，放到硬盘中，要运行时再调入内存</p><h3 id=地址转换重定位>地址转换（重定位）</h3><p>【定义】<strong>重定位</strong>：把程序的逻辑地址空间变换成内存中的实际物理地址空间的过程</p><p>【定义】<strong>基址寄存器（BR，base register）</strong>：当前进程的起始地址。基址寄存器在每个CPU中只有一个。其他进程的起始地址在 PCB 里</p><p>【定义】<strong>界限寄存器（Bounds register）</strong>：当前进程的终止地址</p><p>地址转换：MA（memory address）=（BR）+（VR），然后将 MA 与 界限寄存器比较，若超出，则发生中断。</p><p>地址转换是多道程序并发运行的基础，避免了使用绝对地址造成的进程间干扰。</p><h4 id=静态地址重定位>静态地址重定位</h4><p>思想：在程序执行前，由装配程序将所有指令的虚拟地址 VA加上首地址 BA</p><p>评价：</p><ol><li>优点：无需硬件支持</li><li>缺点：无法实现虚拟内存，因为要求</li></ol><h4 id=动态地址重定位>动态地址重定位</h4><p>思想：在程序执行过程中，在 CPU 访问内存前，依靠硬件完成重定位</p><p>程序寻找某一地址的过程：程序 &mdash;-> <strong>虚拟地址（virtual address）</strong> &mdash;-> <strong>内存管理单元（Memory Management Unit，MMU）</strong> &mdash;-> 物理内存地址</p><p><img src=https://img-blog.csdn.net/20130521082627923 alt></p><h3 id=虚拟内存109>虚拟内存109</h3><p>【定义】<strong>虚拟内存</strong> 的基本思想：每个程序拥有自己的地址空间（即内存中的一部分），这个空间被分为多个块，每个块称为<strong>页面（page）</strong>，页内的地址连续。页被映射到物理内存，但不一定所有的页都在内存中才能运行程序，当一个页不在内存中时，由操作系统将缺失的部分从硬盘装入内存中。</p><p>程序寻找某一地址的过程：程序 &mdash;-> <strong>虚拟地址（virtual address）</strong> &mdash;-> <strong>内存管理单元（Memory Management Unit，MMU）</strong> &mdash;-> 物理内存地址</p><h2 id=分区技术>分区技术</h2><p>比较好的总结：<a href=https://www.cnblogs.com/wkfvawl/p/11687619.html>操作系统——分区存储管理</a> （同时也推荐这个人的其他总结）</p><p>总的来说，分区技术就是指将内存划分为</p><h3 id=固定分区技术静态分区>固定分区技术（静态分区）</h3><p>【定义】<strong>固定分区</strong>：操作系统将内存固定地划分为多个大区域（大小可相等可不等），并且在系统运行的过程中，分区的长度和个数都保持不变。</p><p>进程进入内存的过程：进程先查找空闲的分区，然后比较空间的大小和进程的大小，直到找到合适的分区放进去。若无空闲分区，操作系统则 swap 一个分区出去</p><p>优势：实现简单，系统开销小</p><p>缺点：</p><ol><li>存在内部碎片（小进程放入大分区），内存的利用率较低</li><li>分区尺寸固定，无法运行大程序</li><li>分区数目固定，使活动进程的数目受限</li></ol><h3 id=动态分区技术>动态分区技术</h3><p>【定义】<strong>动态分区</strong>：在作业要求装入内存时，根据用户作业的大小和当时内存空间使用情况决定是否为该作业分配一个分区。分区的大小、个数、位置都不是预先确定的。</p><p><img src=http://c.biancheng.net/cpp/uploads/allimg/140630/1-140630211AT00.jpg alt></p><p>缺点：</p><ol><li>存在外部碎片（离散的空闲分区导致总空间足够，但大进程无法装入，如图）</li></ol><p>【定义】<strong>内存紧凑（memory comaction）</strong>：为了使外部碎片得到充分利用，将所有内存向下移动，使小的空闲区合并为大的空闲区。系统开销较大，并且要求系统有动态重定位功能。</p><p>为了减小外部碎片，需要考虑分区的放置（分配）算法：有下面三种：</p><p><img src=https://cdncontribute.geeksforgeeks.org/wp-content/uploads/Page_replacement_all_three.jpg alt title=三种分配算法></p><h4 id=首次适配算法first-fit>首次适配算法（first fit）</h4><p>思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>评价：简单，性能最好，一是因为它搜索的分区较少，二是因为只从一端开始找，那么另一端就很可能有适合大进程的分区，紧凑的频率就较低</p><h4 id=下次适配算法next-fit>下次适配算法（next fit）</h4><p>思想：和首次适配算法差不多，不同的是每次都从上次结束的地方开始找</p><p>评价：比首次适配算法稍差，因为可能将大块的内存切了</p><h4 id=最佳适配算法best-fit>最佳适配算法（best fit）</h4><p>思想：从所有空闲区中挑选一个能满足要求的最小空闲区，需要先对所有空闲分区排序</p><p>评价：出乎意料的是，性能最差，浪费也较多，因为用了最新的空间后，剩下的碎片会更小，更难找到一个合适的进程放入，导致常常需要紧凑。</p><h4 id=最差适应算法worst-fit>最差适应算法（worst fit）</h4><p>思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时，优先使用最大的连续空闲区，这样分配后的空闲区就不会太小，更方便使用。</p><h3 id=分区管理>分区管理</h3><p>无论是固定分区还是动态分区，都需要对空闲内存进行管理。有两种管理方法：</p><ol><li>使用位图：每一位代表一个分配单元（0为空闲，1为占用，或相反），多个分配单元构成一个分区。分配单元越小，位图越大。简单，但查找空闲分区时需要找出连续的0，比较费时。</li><li>使用链表：每个节点表示一个分区，包含以下域：空闲or占用、起始地址、长度、下一节点。当内存终止时可以非常方便地更新链表</li></ol><p><img src=https://image.51cto.com/files/uploadimg/20090805/123809421.jpg alt></p><h2 id=分页技术110>分页技术110</h2><h3 id=基本原理>基本原理</h3><ol><li>将整个系统的内存空间划分成一系列<strong>大小相等的块</strong>，每一块称为一个 <strong>物理块</strong>、<strong>物理页</strong> 或 <strong>实页</strong>，<strong>页架</strong> 或 <strong>页帧</strong>、<strong>页框（frame）</strong>，可简称为 <strong>块（block）</strong>。所有的页框按物理地址递增顺序连续编号为0、1、2……</li><li>每个作业的地址空间也划分成一系列与内存块一样大小的块，每一块称为一个 <strong>逻辑页</strong> 或 <strong>虚页</strong>，也有人叫 <strong>页面</strong>，可简称为 <strong>页（page）</strong>。所有的页按照逻辑地址递增顺序连续编号为0、1、2……</li><li>一个作业，只要它的总页数不大于内存中的可用块数，系统就可以对它实施分配。系统装入作业时，以页为单位分配内存，一页分配一个页框，作业所有的页所占的页框可以不连续。系统同时为每个作业建立一个页号与页框号的对照表，称为<strong>页表（page table）</strong>，页表放在内存中。最基本的页表包括：<ol><li>页号</li><li>对应页框号</li></ol></li><li>CPU 并不直接去计算物理地址，而是交给 MMU 处理。MMU 先通过 <strong>页表寄存器</strong>（记录页表起始地址）找到页表在内存的位置，然后再通过页表计算地址。</li></ol><p><img src=https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter8/8_14_PagingHardware.jpg alt></p><p>考试：计算页式存储的虚地址对应物理地址的方法：</p><ol><li>页号 = 逻辑地址/页面长度，然后通过查页表找到对应页框</li><li>页内偏移量 = 逻辑地址%页面长度</li><li>物理地址 = 页框号 * 页面长度 + 页内偏移量</li></ol><h3 id=页表>页表</h3><p>页表</p><h2 id=分段技术134>分段技术134</h2><h1 id=第五章-io>第五章 I/O</h1><h2 id=硬件原理>硬件原理</h2><h3 id=io设备的分类>I/O设备的分类</h3><p>按设备功能分类：</p><ol><li>存储型设备</li><li>输入输出型设备</li><li>数据通信型设备</li></ol><p>按数据的组织分类：</p><ol><li>块设备：以数据块为单位存储、传输数据</li><li>字符设备：以字节为单位存储、传输数据</li></ol><p>按资源分配分类：</p><ol><li>独占式设备</li><li>共享式设备</li><li>虚拟式设备（SPOOLing技术）：用高速设备模拟低速设备，用共享设备模拟虚拟设备</li></ol><h3 id=设备控制器>设备控制器</h3><h2 id=io-设备的控制方式>I/O 设备的控制方式</h2><h3 id=程序控制-io忙等待模式>程序控制 I/O（忙等待模式）</h3><p>CPU 直接与 I/O 设备通信，CPU 需要不断查询 I/O 设备的端口状态， 导致CPU的利用率相当低。唯一的优点是简单。</p><h3 id=中断控制-io>中断控制 I/O</h3><p>CPU发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），当前程序阻塞，转去执行其他程序； 当有来自I/O控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。</p><p>由于中断依然会浪费时间，所以 CPU 的效率也不高。</p><p><img src=http://c.biancheng.net/cpp/uploads/allimg/140702/1-140F2151126349.jpg alt></p><h3 id=dma-控制-io飞跃模式越过cpu>DMA 控制 I/O（飞跃模式，越过CPU）</h3><p>DMA 代替 CPU 与设备通信，DMA 传输完一个数据缓冲区后再向 CPU 发出中断，减少了中断次数。</p><p>DMA 控制方式与中断驱动方式的主要区别是中断驱动方式在每个数据需要传输时中断 CPU，而 DMA控制方式则是在所要求传送的一批数据全部传送结束时才中断CPU；此外，中断驱动方式数据传送是在中断处理时由CPU控制完成的，而 DMA 控制方式则是在 DMA 控制器的控制下完成的。</p><h3 id=io-通道机制>I/O 通道机制</h3><p>I/O通道是指专门负责输入/输出的处理机，它相当于一个小型的处理机，可以从 CPU 接受复杂的 I/O 指令。</p><p>当 CPU 要完成一组相关的读（或写）操作及有关控制时，只需向 I/O 通道发送一条 I/O 指令，以给出其所要执行的通道程序的首地址和要访问的 I/O 设备，通道接到该指令后，通过执行通道程序便可完成 CPU 指定的I/O任务，数据传送结束时向 CPU 发中断请求。</p><p>I/O 通道与 DMA 方式的区别是：DMA 方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。另外，每个 DMA 控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。</p></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
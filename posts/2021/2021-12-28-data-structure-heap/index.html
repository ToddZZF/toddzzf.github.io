<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>数据结构：堆 Heap - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2021/2021-12-28-data-structure-heap/>数据结构：堆 Heap</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">数据结构：堆 Heap</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2021-12-28</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><h2 id=复习完全二叉树>复习完全二叉树</h2><p>首先先复习一下完全二叉树。完全二叉树指的是除了最深的一层，其余层都填满。因此，完全二叉树可以按由上到下、由左到右的顺序放入到一个数组中：</p><pre tabindex=0><code class=language-raw data-lang=raw>      0
     / \
    1   2
   / \ / \
  3  4 5  6
 / \
7   8

012345678
</code></pre><p>并且对于编号为 $n$ 的结点，其父结点为 $\lceil (n-1)/2 \rceil$，左子结点为 $2n+1$，右子结点为 $2n+2$. 证明如下：</p><p>我们只需要证明左子结点即可，其余很容易据此推出。我们采用从特殊到一般的证明方法。我们先考虑每层的第1个元素，编号为：$0,1,3,7,\cdots,2^{l-1}-1$，显然，$l+1$ 层的第一个元素为 $2^l-1=2\cdot (2^{l-1}-1)+1$</p><p>我们再考虑每层第 $k$ 个元素，即编号为 $2^{l-1}-1+(k-1)$，显然，其左子结点的编号为 $2^l-1+2\cdot (k-1)$，这两者满足：</p><p>$$
2^l-1+2\cdot (k-1) = 2\cdot [2^{l-1}-1+(k-1)]+1
$$</p><p>故得证。右子结点在左子结点的基础上加一即可，父结点则是对等式进行移项即可。</p><p>注意的是，我们的结点编号是从 0 开始的，层编号也是从 0 开始的。如果从 1 开始，则父结点为 $\lceil n/2 \rceil$，左子结点为 $2n$，右子结点为 $2n+1$. 在做题时要考虑清楚。</p><blockquote><p>后面代码部分以 1 开始。</p></blockquote><p>根据这一点，我们就可以很方便的将完全二叉树存储在线性表中。</p><h2 id=堆>堆</h2><p>堆是一种特殊的二叉树，分两种：</p><ul><li>最大堆：父结点比子结点大</li><li>最小堆：父结点比子结点小</li></ul><p>后面以最大堆为例。</p><p>堆的几个基本操作：</p><ol><li>上浮 shift_up</li><li>下沉 shift_down</li><li>插入 push</li><li>弹出 pop</li><li>取顶 top</li><li>堆排序 heap_sort</li></ol><p>这几个操作在构建、使用堆的过程中会逐一讲解。</p><h2 id=构造堆>构造堆</h2><p>首先先讲一个特殊案例，假设结点的左右子树都是堆，但自身不是堆。比如：</p><pre tabindex=0><code class=language-raw data-lang=raw>      2
     / \
    9   7
   / \ / \
  8  5 0  1
 / \
6   4
</code></pre><p>显然左右子树都是最大堆，但根不是最大的。为了使其称为堆，我们进行“下沉”，把根与其最大的子结点交换：</p><pre tabindex=0><code class=language-raw data-lang=raw>      9
     / \
    2   7
   / \ / \
  8  5 0  1
 / \
6   4
</code></pre><p>然后对左子树重复该过程：</p><pre tabindex=0><code class=language-raw data-lang=raw>      9
     / \
    8   7
   / \ / \
  2  5 0  1
 / \
6   4
</code></pre><p>再重复：</p><pre tabindex=0><code class=language-raw data-lang=raw>      9
     / \
    8   7
   / \ / \
  6  5 0  1
 / \
2   4
</code></pre><p>最终可以得到一个最大堆。最小堆则相反，与子结点中较小的交换。注意在下沉的过程中，二叉树的结构没变，依然是完全二叉树。</p><p>据此，我们可以将任意一个完全二叉树转化为堆，只需自低向上对每个结点进行下沉操作即可，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>new_heap</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>len</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=n>i</span><span class=o>&gt;=</span><span class=mi>1</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>adjust_heap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>此处我们从最后一个有子结点的结点（$\lceil n/2 \rceil$）开始，逐个对前面的结点进行调整。具体调整的代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>adjust_heap</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>node</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>left</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>node</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>max</span> <span class=o>=</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>left</span> <span class=o>&lt;=</span> <span class=n>len</span> <span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>a</span><span class=p>[</span><span class=n>max</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>max</span> <span class=o>=</span> <span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>right</span> <span class=o>&lt;=</span> <span class=n>len</span> <span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>a</span><span class=p>[</span><span class=n>max</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>max</span> <span class=o>=</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>max</span> <span class=o>!=</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>max</span><span class=p>],</span> <span class=n>a</span><span class=p>[</span><span class=n>node</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>adjust_heap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>max</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=插入新结点>插入新结点</h2><p>首先，要保持堆是完全二叉树，那么新插入的结点只能在最末尾的位置。假设我们新插入的是 9</p><pre tabindex=0><code class=language-raw data-lang=raw>      8
     / \
    6   7
   / \ / \
  4  5 0  1
 / \
2   9
</code></pre><p>显然 9 比结点 4 大，所以将它“上浮”，也就是交换。</p><pre tabindex=0><code class=language-raw data-lang=raw>      8
     / \
    6   7
   / \ / \
  9  5 0  1
 / \
2   4
</code></pre><p>然后不断重复这个过程，直到无法上浮为止。</p><pre tabindex=0><code class=language-raw data-lang=raw>      8
     / \
    9   7
   / \ / \
  6  5 0  1
 / \
2   4
</code></pre><pre tabindex=0><code class=language-raw data-lang=raw>      9
     / \
    8   7
   / \ / \
  6  5 0  1
 / \
2   4
</code></pre><h2 id=堆排序>堆排序</h2><p>首先，我们将所有元素组织成堆，然后取出最大的元素：</p><pre tabindex=0><code class=language-raw data-lang=raw>     &#39;7&#39;
     / \
    5   6
   / \ / \
  4  2 1  3

     &#39; &#39;
     / \
    5   6
   / \ / \
  4  2 1  3

7
</code></pre><p>由于根结点空了，所以我们把最右下的元素补上去</p><pre tabindex=0><code class=language-raw data-lang=raw>      3
     / \
    5   6
   / \ /
  4  2 1
</code></pre><p>由于此时左、右子树都是堆，所以只需要将根结点下沉。</p><pre tabindex=0><code class=language-raw data-lang=raw>      6
     / \
    5   3
   / \ /
  4  2 1
</code></pre><p>然后，再取出根结点，重复上述过程。</p><p>代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>heapsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// Heapsort
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Elem</span> <span class=n>mval</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>maxheap</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span> <span class=n>H</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>  <span class=c1>// Now sort
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>H</span><span class=p>.</span><span class=n>removemax</span><span class=p>(</span><span class=n>mval</span><span class=p>);</span>     
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>maxheap</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>Elem</span><span class=o>*</span> <span class=n>Heap</span><span class=p>;</span>   <span class=c1>// Pointer to the heap array
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>size</span><span class=p>;</span>     <span class=c1>// Maximum size of the heap
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>        <span class=c1>// Number of elems now in heap
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>maxheap</span><span class=p>(</span><span class=n>Elem</span><span class=o>*</span> <span class=n>h</span><span class=p>,</span> <span class=kt>int</span> <span class=n>num</span><span class=p>,</span> <span class=kt>int</span> <span class=n>max</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Heap</span> <span class=o>=</span> <span class=n>h</span><span class=p>;</span> <span class=n>n</span> <span class=o>=</span> <span class=n>num</span><span class=p>;</span> <span class=n>size</span> <span class=o>=</span> <span class=n>max</span><span class=p>;</span> <span class=n>buildHeap</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Bool</span> <span class=nf>removemax</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span> <span class=n>it</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Heap is empty
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>swap</span><span class=p>(</span><span class=n>Heap</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>--</span><span class=n>n</span><span class=p>);</span>      <span class=c1>// Swap max with end
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=n>siftdown</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>it</span> <span class=o>=</span> <span class=n>Heap</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>            <span class=c1>// Return max value
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>代价为：1. 建堆 $\Theta(n)$ 2. 移除最大值 $\Theta(\log n)$（因为深度为 $\lceil \log n$ \rceil） 3. n次移除最大值 $\Theta(n\log n)$</p><blockquote><p>话说我觉得建堆应该是 $\Theta(n\log n)$</p></blockquote><h2 id=参考>参考</h2><p><a href=https://www.cnblogs.com/JVxie/p/4859889.html>https://www.cnblogs.com/JVxie/p/4859889.html</a></p><p><a href=https://www.cnblogs.com/xiugeng/p/9645972.html>https://www.cnblogs.com/xiugeng/p/9645972.html</a></p></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><title>数据结构一周速成</title><link rel=canonical href=https://todd.scuteee.com/posts/2021/2021-12-23-data-structure-flash-review/><link rel=stylesheet href=/scss/style.min.ac77dcf8b111b51da39a92990f431923f210f3876d85798a2125667f96dc33a4.css><meta property="og:title" content="数据结构一周速成"><meta property="og:description" content><meta property="og:url" content="https://todd.scuteee.com/posts/2021/2021-12-23-data-structure-flash-review/"><meta property="og:site_name" content="Todd's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2021-12-23T20:34:00+08:00"><meta property="article:modified_time" content="2021-12-23T20:34:00+08:00"><meta name=twitter:title content="数据结构一周速成"><meta name=twitter:description content><link rel="shortcut icon" href=favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/avatar_huab97f25f655a875cd3229d10d376a5bb_18063_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>💘</span></figure><div class=site-meta><h1 class=site-name><a href=/>Todd's Blog</a></h1><h2 class=site-description>Life & Work</h2></div></header><ol class=social-menu><li><a href=https://github.com/toddzzf target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li class=current><a href=/posts/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>日常</span></a></li><li><a href=/food/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tools-kitchen-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19 3v12h-5c-.023-3.681.184-7.406 5-12zm0 12v6h-1v-3M8 4v17M5 4v3a3 3 0 106 0V4"/></svg><span>吃的</span></a></li><li><a href=/design/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-code" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><polyline points="7 8 3 12 7 16"/><polyline points="17 8 21 12 17 16"/><line x1="14" y1="4" x2="10" y2="20"/></svg><span>网页设计</span></a></li><li><a href=/ppt/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-presentation" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="3" y1="4" x2="21" y2="4"/><path d="M4 4v10a2 2 0 002 2h12a2 2 0 002-2V4"/><line x1="12" y1="16" x2="12" y2="20"/><line x1="9" y1="20" x2="15" y2="20"/><path d="M8 12l3-3 2 2 3-3"/></svg><span>PPT</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2021/2021-12-23-data-structure-flash-review/>数据结构一周速成</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Dec 23, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 13 分钟</time></div></footer></div></header><section class=article-content><blockquote><p>我真不明白为什么同一个课程，同样的内容，就只是因为开课的学院不同就不能互认，搞得我一门课程要学两次🙄</p></blockquote><h2 id=chapter-1>Chapter 1</h2><ol><li>什么是数据结构？<blockquote><p>研究如何在计算机中有效的存储和组织数据的方法</p></blockquote></li><li>如何表示数据结构？<blockquote><p>抽象数据类型（ADT）：是一种描述数据结构的程序设计语言无关的模型。ADT定义为一组数值，和一组相关的操作。</p></blockquote></li><li>什么是算法？<blockquote><p>算法：用于解决一个问题的方法或步骤。</p></blockquote></li><li>算法的属性：<blockquote><ol><li>确定性：它必须是正确的</li><li>可行性：它必须包含一系列具体的步骤，执行的过程无二义性</li><li>有穷性：它必须包含有限的步骤，它必须是可以结束的</li></ol></blockquote></li><li>数据结构 + 算法 = 程序<blockquote><ul><li>数据结构主要研究如何有效的存储和组织应用程序的数据。</li><li>算法主要研究如何对数据进行处理从而解决某个问题</li></ul></blockquote></li></ol><h2 id=chapter-2>Chapter 2</h2><h2 id=chapter-3>Chapter 3</h2><p>增长率分析：分析代价（时间、空间）如何随着输入数据规模大小的增长而增长</p><ul><li>$T(n)$：运行时间关于输入数据规模大小 $n$ 的函数。</li><li>$S(n)$：消耗空间关于输入数据规模大小 $n$ 的函数。</li></ul><hr><p>渐进分析：渐进分析是对T(n)的一种简化分析，该分析保留了 $T(n)$ 的渐进增长趋势</p><ul><li>大 $O$ 分析（上界分析）<blockquote><p>对于非负函数 $T(n)$，如果存在正常数 $c$ 和 $n_0$ 使得当 $n>n_0$ 时 $T(n)\leq cf(n)$，则称 $T(n)$ 属于集合 $O(f(n))$，或记为 $T(n)=O(f(n))$</p></blockquote></li><li>大 $\Omega$ 分析（下界分析）<blockquote><p>对于非负函数 $T(n)$，如果存在正常数 $c$ 和 $n_0$ 使得当 $n>n_0$ 时 $T(n)\geq cg(n)$，则称 $T(n)$ 属于集合 $\Omega(g(n))$，或记为 $T(n)=\Omega(g(n))$</p></blockquote></li><li>大 $\Theta$ 分析<blockquote><p>若 $T(n)=O(h(n))$ 且 $T(n)=\Omega(h(n))$，则称 $T(n)=\Theta(h(n))$</p></blockquote></li></ul><p>$T(n)$ 存在多个上界和下界。</p><hr><p>简化规则：</p><ul><li>常数规则：若 $f(n)=O(kg(n))$，$k>0$，则 $f(n)=O(g(n))$<ul><li>该规则同样适用于 $\Omega$ 和 $\Theta$</li></ul></li><li>加法规则：若 $f_1(n)=O(g_1(n))$ 且 $f_2(n)=O(g_2(n))$，则 $f_1(n)+f_2(n)=O(\max(g_1(n),g_2(n)))$</li><li>乘法规则：若 $f_1(n)=O(g_1(n))$ 且 $f_2(n)=O(g_2(n))$，则 $f_1(n)f_2(n)=O(g_1(n)g_2(n))$</li></ul><hr><p>常见的渐进复杂度：</p><p>$$
O(1)&lt;O(\log\log n)&lt;O(\log n)\
&lt;O(n)&lt;O(n\log n)\
&lt;O(n^2)&lt;\cdots&lt;O(n^k)\
&lt;O(k^n)&lt;O(n!)&lt;O(n^n)
$$</p><h2 id=chapter-4>Chapter 4</h2><h3 id=线性表>线性表</h3><p>概念：</p><ul><li><strong>线性表</strong>：由有限的数据元素构成的序列</li><li><strong>当前位置</strong>：在线性表中插入、删除、或读去数据的位置。当前位置通过**栅栏 (fence)**来定义。栅栏将线性表划分为左右两个部分。插入、删除、读取都在栅栏所在的位置执行（栅栏后面的位置）</li><li>一个包含0个数据元素的线性表称为<strong>空表</strong></li><li>线性表的<strong>长度</strong>指的是线性表中数据元素的个数</li><li>线性表的开始端称为<strong>表头（head）</strong>, 线性表的结束端称为<strong>表尾（tail）</strong></li><li><strong>有序表</strong>：表中的所有的数据元素是根据其数值的大小来进行先后排列</li><li><strong>无序表</strong>：表中数据元素的位置和该元素的数值没有必然联系</li></ul><hr><p>线性表ADT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>insert</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>append</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>remove</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>getValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>setPos</span><span class=p>(</span><span class=kt>int</span> <span class=n>pos</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setStart</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setEnd</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>prev</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>next</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>leftLength</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>rightLength</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr><p>线性表的实现：</p><ul><li>数组</li><li>链表</li></ul><div class=table-wrapper><table><thead><tr><th style=text-align:center>比较</th><th style=text-align:center>数组</th><th style=text-align:center>链表</th></tr></thead><tbody><tr><td style=text-align:center>插入与删除</td><td style=text-align:center>$\Theta(n)$</td><td style=text-align:center>$\Theta(1)$</td></tr><tr><td style=text-align:center>求前驱和随机访问</td><td style=text-align:center>$\Theta(1)$</td><td style=text-align:center>$\Theta(n)$</td></tr><tr><td style=text-align:center>特点</td><td style=text-align:center>需要提前为数组分配空间</td><td style=text-align:center>消耗的空间随数据元素个数的增长而增长</td></tr><tr><td style=text-align:center>空间<br>$E$ 每个数据元素所占空间大小<br>$P$：每个指针所占空间大小<br>$D$：数组最多能存放的数据元素的个数<br>$n$：当前数据元素的个数</td><td style=text-align:center>$DE$</td><td style=text-align:center>$n(P+E)$</td></tr></tbody></table></div><h3 id=栈>栈</h3><p>概念：</p><ul><li><strong>栈</strong>：插入、删除只在一端进行的线性表</li><li><strong>LIFO</strong> 性质: Last In, First Out. （后进先出）</li><li><strong>入栈(PUSH)</strong>：插入元素到栈中</li><li><strong>出栈(POP)</strong>：从栈中取出元素</li><li><strong>栈顶(TOP)</strong>：栈中插入、删除的位置</li></ul><hr><p>栈的ADT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Stack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Reinitialize the stack
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Push an element onto the top of the stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>push</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Remove the element at the top of the stack. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get a copy of the top element in the stack
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>topValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Return the number of elements in the stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>length</span> <span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr><p>栈的实现：</p><ul><li>数组</li><li>链表</li></ul><h3 id=队列>队列</h3><p>概念：</p><ul><li><strong>队列</strong>: 插入和删除分别在表的两端进行的线性表</li><li><strong>FIFO</strong> 性质: First in, First Out （先进后出）</li><li>插入: <strong>enqueue（入队）</strong></li><li>删除: <strong>dequeue （出队）</strong></li><li>第一个元素: <strong>front（队头）</strong></li><li>最后一个元素: <strong>rear（队尾）</strong></li></ul><hr><p>队列ADT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Queue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>enqueue</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>dequeue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>frontValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>length</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr><p>栈的实现：</p><ul><li>数组</li><li>链表</li></ul><h2 id=chapter-5-二叉树>Chapter 5 二叉树</h2><p>概念：</p><ul><li><p><strong>二叉树</strong>是一个包含有限个结点的集合，有以下两种情况</p><ul><li>空集，<strong>空树</strong></li><li>包含一个称为<strong>树根(root)<strong>的结点，以及两个互不相交的二叉树，它们分别称为</strong>左子树</strong>和<strong>右子树</strong></li></ul></li><li><p>对于树上的每个结点，和它有连边的下层结点称为它的<strong>孩子结点</strong>。在二叉树中，每个结点最多会有两个孩子，最少没有孩子</p></li><li><p>对于二叉树上的每个结点，和它有连边的上层结点称为它的<strong>父亲结点</strong>。二叉树中，除了树根外，每个结点都有一个父亲结点。</p></li><li><p>一个结点的父亲，父亲的父亲，父亲的父亲的父亲，等等都是它的<strong>祖先结点</strong>。反过来，一个结点的孩子，孩子的孩子，孩子的孩子的孩子，等等都是它的<strong>后辈结点</strong></p></li><li><p><strong>叶子结点</strong>：没有孩子结点的结点为叶子结点</p></li><li><p><strong>路径</strong>：一个结点序列 $n_1,n_2,\cdot,n_k$，如果其中的每个结点 $n_i$ 是 $n_{i+1}$ 的父亲（$1\leq i \leq k$），我们就称这个序列是从 $n_1$ 到 $n_k$ 的路径。这条路径的长度等于 $k-1$</p></li><li><p><strong>深度</strong>：一个结点的深度等于从树根到这个结点的路径的长度</p></li><li><p><strong>层次</strong>：根结点为第0层，往下逐个增加。（貌似等于深度）</p></li><li><p><strong>高度</strong>：一棵树的高度等于其中最大结点深度加一</p></li><li><p><strong>满二叉树</strong>：二叉树的每个结点都是叶子或拥有两个孩子的中间结点。</p><ul><li><strong>非空满二叉树中叶子的数目比中间结点多一个</strong>，这个很容易证明：如果只有根结点，则只有一个叶子结点，没有中间结点。每增加两个叶子，则原有的叶子结点会变为中间结点，故叶子始终比中间结点多一个。</li></ul></li><li><p><strong>完全二叉树</strong>: 除了最深的层次，二叉树的所有层次都填满结点，且最深层的叶子结点集中在该层的最左边的位置</p></li></ul><hr><p>二叉树结点ADT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Template</span>  <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>  <span class=k>class</span> <span class=nc>BinNode</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>Elem</span><span class=o>&amp;</span> <span class=n>val</span><span class=p>(</span> <span class=p>)</span> <span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setVal</span><span class=p>(</span> <span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>BinNode</span><span class=o>*</span> <span class=nf>left</span><span class=p>(</span> <span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setLeft</span><span class=p>(</span> <span class=n>BinNode</span><span class=o>*</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>BinNode</span><span class=o>*</span> <span class=nf>right</span><span class=p>(</span> <span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setRight</span><span class=p>(</span> <span class=n>BinNode</span><span class=o>*</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>isLeaf</span><span class=p>(</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><p>二叉树的实现：</p><ul><li>基于链接的方式</li><li>基于数组的方式</li></ul><hr><p>哈夫曼编码：</p><ul><li>一种可变长度的编码</li><li>高频字符对应较短的编码</li></ul><p>哈夫曼编码的编码过程需要用到一种称为<strong>哈夫曼树</strong>的满二叉树结构。</p><p>平均编码长度取决于所有叶子的加权路径长度的和</p><p>定理: 对于给定的一组字符以及出现的频率，以它们作为叶子节点构建的满二叉树中，哈夫曼树具有最小的加权路径长度的和。在预先知道每个字符的出现的频率的前提下，哈夫曼编码是具有最小的平均编码长度的非前缀编码。</p><p>构建哈夫曼编码的算法：</p><h2 id=chapter-6-一般树>Chapter 6 一般树</h2><p>概念：</p><ul><li><strong>树</strong> T 是一个包含一个或多个节点的有限集合，其中有一个称为 <strong>树根</strong> 的节点r，余下的节点(T –{r}) 可以被划分为k个( k≥0)互不想交的子集 T1, T2, &mldr;, Tk, 每个子集都是一棵树,它们的树根 r1, r2, &mldr;, rk,都是r的孩子</li><li><strong>森林</strong>：是包含有一棵或多棵树的集合。</li></ul><hr><p>树结点 ADT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// General tree node ADT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>GTNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>GTNode</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>);</span> <span class=c1>// Constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>GTNode</span><span class=p>();</span>           <span class=c1>// Destructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Elem</span> <span class=nf>value</span><span class=p>();</span>        <span class=c1>// Return value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>isLeaf</span><span class=p>();</span>       <span class=c1>// TRUE if is a leaf
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>parent</span><span class=p>();</span>    <span class=c1>// Return parent
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>leftmost_child</span><span class=p>();</span> <span class=c1>// First child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>right_sibling</span><span class=p>();</span>  <span class=c1>// Right sibling
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>setValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>);</span>     <span class=c1>// Set value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//insert first child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>insert_first</span><span class=p>(</span><span class=n>GTNode</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//insert right sibling
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>insert_next</span><span class=p>(</span><span class=n>GTNode</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>remove_first</span><span class=p>();</span> <span class=c1>// Remove first child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>remove_next</span><span class=p>();</span>  <span class=c1>// Remove sibling
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>树 ADT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// General tree ADT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>GenTree</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>GenTree</span><span class=p>();</span>               <span class=c1>// Constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>GenTree</span><span class=p>();</span>              <span class=c1>// Destructor  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>clear</span><span class=p>();</span>            <span class=c1>// Send nodes to free store
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>root</span><span class=p>();</span>          <span class=c1>// Return the root
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=n>GTNode</span><span class=o>*</span><span class=p>);</span> <span class=c1>// Print function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=chapter7-内部排序>Chapter7 内部排序</h2><p>概念：</p><ul><li><p>排序：给定一个序列的记录 $R_1 , R_2 , … , R_n$，它们对应的关键字依次是 $k_1 , k_2 ,… , k_n$ , 调整记录在序列中的次序得到新的记录序列 $R_{s1},R_{s2},…,R_{sn}$，使得记录的关键字满足以下性质： $k_{s1} ≤ k_{s2} ≤ …≤ k_{sn}$.</p></li><li><p>稳定的排序算法：排序的过程不会改变具有相等关键字的记录的相对先后次序。</p></li><li><p>内部排序：指的是待排序记录存放在计算机随机存储器中进行的排序过程。</p></li><li><p>外部排序：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录, 在排序过程中尚需对外存进行访问的排序过程。</p></li></ul><hr><h3 id=插入排序>插入排序</h3><p>记忆：像洗牌，将每张牌插入到合适的位置</p><p>实现：在第i次迭代，将第i个元素与前面 i-1 个元素进行比较，使其插入到前面适当的位置(1 &lt;= i &lt;= n-1)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>inssort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span> <span class=p>(</span><span class=n>j</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]));</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span><span class=c1>//插入第i个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>代价分析：最好 $\Theta(n)$，最坏 $\Theta(n^2)$，平均 $\Theta(n^2)$</p><p>插入排序是一种稳定的排序算法。</p><h3 id=冒泡排序>冒泡排序</h3><p>实现：由后到前，相邻两个元素比较，逆序则交换。一次冒泡过程结束后，最小的元素会到达最前面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>bubsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>&gt;</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>代价分析：最好、最坏、平均都是 $\Theta(n^2)$。</p><p>冒泡排序算法是一种稳定的排序算法。</p><h3 id=选择排序>选择排序</h3><p>实现：第i趟排序就是从位置属于[i,n-1]的元素中，选出最小的元素，并将其和第i位置上的元素交换</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>selsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>   <span class=c1>// select the minial values in [i,n-1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>lowindex</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=c1>// lowindex指向较小的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>&gt;</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span> <span class=c1>// Find least
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>lowindex</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>lowindex</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>lowindex</span><span class=p>);</span> <span class=c1>// Put it in place
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>代价分析：最好、最坏、平均都是 $\Theta(n^2)$。</p><p>选择排序是一种不稳定的排序算法。</p><h3 id=希尔排序shellsort>希尔排序（Shellsort）</h3><p>思路（分组）：每隔一定间距取一个元素放入同一组，将所有元素分成多组，并在组内进行插入排序。然后减小间距重新分组，重新排序。最后当间距为 1 时，退化为一般的插入排序。</p><p>分析：由于最后一次排序是一般的插入排序，所以这种方法是可行的。而前面几次排序可以使元素一次性移动多格，所以速度会快。</p><p>代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Modified version of Insertion Sort
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>inssort2</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>from</span><span class=p>,</span> <span class=kt>int</span> <span class=n>incr</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span> <span class=n>from</span> <span class=o>+</span> <span class=n>incr</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>+=</span><span class=n>incr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span> <span class=p>(</span><span class=n>j</span><span class=o>&gt;</span> <span class=n>from</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>           <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=n>incr</span><span class=p>]);</span> <span class=n>j</span><span class=o>-=</span><span class=n>incr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=n>incr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>shellsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// Shellsort
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>n</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=n>i</span><span class=o>&gt;=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>/=</span><span class=mi>2</span><span class=p>)</span>  <span class=c1>// For each incr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>   <span class=c1>// Sort sublists
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>inssort2</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>   
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当增量序列为 $∆[k] = 2^{t-k+1}-1$ 时，算法复杂度为 $O(n^{3/2})$。 其中 t 是排序的趟数，$1\leq k\leq t$。例如（15，7，3，1）。<a class=link href=https://zhuanlan.zhihu.com/p/73726253 target=_blank rel=noopener>证明过程</a></p><p>希尔排序是一种不稳定排序。</p><h3 id=快速排序>快速排序</h3><p>思想（分而治之）：选择一个记录的值作为支点（pivot）。将小于支点的记录安排在支点的左侧，将大于等于支点的记录安排在支点的右侧。从而将原序列划分为左右两个子序列。然后在子序列中重复该过程。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>qsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;=</span> <span class=n>i</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>     <span class=c1>// List too small
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>pivot</span> <span class=o>=</span> <span class=n>findpivot</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>pivot</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>  <span class=c1>// Put pivot at end
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>partition</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>         <span class=c1>// Put pivot in place
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>qsort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>qsort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>findpivot</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>partition</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span><span class=n>Elem</span><span class=o>&amp;</span> <span class=n>pivot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>l</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>)</span> <span class=n>l</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>l</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>A</span><span class=p>[</span><span class=n>r</span><span class=p>]</span> <span class=o>&gt;=</span><span class=n>pivot</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=n>r</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span> <span class=c1>// Swap out-of-place values
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;</span> <span class=n>r</span><span class=p>);</span> <span class=c1>// Stop when they cross
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>l</span><span class=p>;</span>       <span class=c1>// Return first pos on right
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>代价分析：类似二叉树（层数代表次数）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=c>#best: 每次都均匀分成两段</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span>--------<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span>---- ----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>-- -- -- --<span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- - - - - - - -<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c>#worst</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span>-----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- -------<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- ------<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- -----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- ----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- ---<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>- --<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- -<span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>平均情况：</p><p>$$
T(n)=cn+\frac{1}{n} \sum_{k=0}^{n-1} (T(k)+T(n-1-k))=\Theta(n \log n)
$$</p><p>改进方法：</p><ul><li>选取更好的支点<ul><li>选择以下三个记录中的中间值作为支点 : 序列的第一个，中间，最后一个记录</li></ul></li><li>采用非递归的算法来实现快速排序</li></ul><h3 id=归并排序>归并排序</h3><p>思路（分而治之）：将一个序列划分为两个长度相等的子序列，然后递归的对每个子序列进行归并排序。将排好序的两个子序列归并为一个有序的序列。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>mergesort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=n>Elem</span> <span class=n>temp</span><span class=p>[],</span>
</span></span><span class=line><span class=cl>               <span class=kt>int</span> <span class=n>left</span><span class=p>,</span> <span class=kt>int</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span><span class=o>+</span><span class=n>right</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>left</span> <span class=o>==</span> <span class=n>right</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>mergesort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>mergesort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>left</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>right</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>// Copy
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>temp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i1</span> <span class=o>=</span> <span class=n>left</span><span class=p>;</span> <span class=kt>int</span> <span class=n>i2</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>curr</span><span class=o>=</span><span class=n>left</span><span class=p>;</span> <span class=n>curr</span><span class=o>&lt;=</span><span class=n>right</span><span class=p>;</span> <span class=n>curr</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i1</span> <span class=o>==</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>      <span class=c1>// Left exhausted
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i2</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>i2</span> <span class=o>&gt;</span> <span class=n>right</span><span class=p>)</span>  <span class=c1>// Right exhausted
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i1</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>temp</span><span class=p>[</span><span class=n>i1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>temp</span><span class=p>[</span><span class=n>i2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i1</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i2</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>代价分析：最好、最坏、平均都是 $\Theta(n \log n)$。</p><h3 id=堆排序>堆排序</h3><p>思路：堆顶结点的值总保持是最大值/最小值，故每次取堆顶，然后用剩下元素建堆，再重复该过程。</p><p>代价分析：建堆 $\Theta(n)$，移除最大值 $\Theta(\log n)$，n 次移除最大值 $\Theta(n\log n)$。故总代价为 $\Theta(n\log n)$</p><p>详细分析见我的博客。</p><h3 id=箱排序和基数排序>箱排序和基数排序</h3><p>箱排序（Binsort）：设置若干个箱子，依次扫描待排序的记录 R[0]，R[1]，…，R[n-1]，把关键字等于 k 的记录分配到第 k 个箱子里，然后按序号依次将各非空的箱子中的记录收集起来。</p><p>示例：3，8，1，8，4，放入下面这组箱子，允许多个记录具有相同的关键字（链表）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                 8
</span></span><span class=line><span class=cl>---------------------
</span></span><span class=line><span class=cl>| |1| |3|4| | | |8| |
</span></span><span class=line><span class=cl>---------------------
</span></span><span class=line><span class=cl> 0 1 2 3 4 5 6 7 8 9
</span></span></code></pre></td></tr></table></div></div><p>然后从左到右逐个扫描箱子，如果有关键字，则取出：1，3，4，8，8</p><p>代价：对于Key取值范围较大的记录进行Binsort，较为低效。放进箱子需要 $n$ 次，然后要扫描所有箱子，所以代价为：$\Theta(n + m)$，$n$ 是记录个数，$m$ 是箱子个数。</p><p>箱排序是稳定的。</p><hr><p>基数排序（Radix Sort）：对箱排序的改进。将任何一个 $r$ 进制的整数 key $\overline{K_{d-1}K_{d-2}\cdots K_0}$ 看成是由 $d$ 个分量组成，$K_{d-1},K_{d-2},\cdots ,K_0$，对每个分量进行箱排序。</p><p>示例：十进制，27，91，1，97，17，23，84，28，72，5，67，25，先按个位放入箱子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0
</span></span><span class=line><span class=cl>1-&gt;91-&gt;1
</span></span><span class=line><span class=cl>2-&gt;72
</span></span><span class=line><span class=cl>3-&gt;23
</span></span><span class=line><span class=cl>4-&gt;84
</span></span><span class=line><span class=cl>5-&gt;5-&gt;25
</span></span><span class=line><span class=cl>6
</span></span><span class=line><span class=cl>7-&gt;27-&gt;97-&gt;17-&gt;67
</span></span><span class=line><span class=cl>8-&gt;28
</span></span><span class=line><span class=cl>9
</span></span></code></pre></td></tr></table></div></div><p>然后取出来：91，1，72，23，84，5，25，27，97，17，67，28</p><p>再按十位放入箱子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0-&gt;1-&gt;5
</span></span><span class=line><span class=cl>1-&gt;17
</span></span><span class=line><span class=cl>2-&gt;23-&gt;25-&gt;27-&gt;28
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>4
</span></span><span class=line><span class=cl>5
</span></span><span class=line><span class=cl>6-&gt;67
</span></span><span class=line><span class=cl>7-&gt;72
</span></span><span class=line><span class=cl>8-&gt;84
</span></span><span class=line><span class=cl>9-&gt;91-&gt;97
</span></span></code></pre></td></tr></table></div></div><p>再取出来：1，5，17，23，25，27，28，67，72，84，01，07</p><p>代价：每次放入全部 $n$ 个元素，$r$ 进制则需要扫描 $r$ 个箱子，需要重复位数 $d$ 次。故代价为 $\Theta((n+r)d)$，$n$ 是记录个数，$d$ 是Key的位数，$r$ 是基数。</p><p>基数排序是稳定的排序。</p><h3 id=排序算法性能比较>排序算法性能比较</h3><h3 id=排序算法的理论下界>排序算法的理论下界</h3><p>排序问题的上界是 $n \log n$。因为我们能找到的最好排序算法的平均情况下的算法复杂度是 $O(n \log n)$</p><p>我们将证明排序问题的理论下界也是 $n \log n$。</p><p>我们考虑排序的决策树（每个结点处进行一次比较，根据结果分为左右子树），其叶子数量为 $N!$（因为有 $N!$ 种可能结果），深度为 $d$ 的二叉树最多有 $2^{d+1}-1$ 个叶子，那反过来，$N!$ 个叶子的二叉树的深度至少是 $\lceil \log(N!+1) \rceil-1$，即 $\Omega (\log n!)=\Omega(n \log n)$</p><p>$$
斯特林公式：n!\approx \sqrt{2\pi n} \left( \frac{n}{e} \right)^n
$$</p><p>所以排序所需的时间 $T=\Omega(n \log n)$</p><h2 id=chapter9-查找>Chapter9 查找</h2><p>定义：</p><h2 id=chapter10-索引>Chapter10 索引</h2><p>原文件在硬盘中太大，不方便直接查找，所以建立索引文件。</p><p>索引文件：</p><ol><li>索引文件中记录了关键字和对应的数据记录存储在硬盘中的位置</li><li>索引文件比数据记录小的多，查找时被加载到内存中进行查找</li><li>针对不同关键字的索引文件，支持多关键字查找</li></ol><h3 id=线性索引>线性索引</h3><p>线性索引: 索引文件组织成二元组(关键字, 指向记录的指针) 的序列。</p><p>如果索引太大无法加载到内存，则建立二级索引。分段，取每一段的最小值重新构成序列。</p><p>不足之处：插入和删除操作会导致大量数据移动 $\Theta(n)$</p><h3 id=二叉查找树-bst>二叉查找树 BST</h3><p>二叉查找数：对每个结点，左子结点比它小，右子结点比它大</p><p>二叉平衡树：左右子树的高度差不超过1</p><p>二叉平衡树查找复杂度 $\Theta(\log n)$</p><p>不足之处：让BST保持平衡需要付出较高的代价，插入一个结点需要调整大量结点。</p><h3 id=2-3树>2-3树</h3><p>2-3树的性质：</p><h3 id=b树>B+树</h3><h2 id=chapter11-图>Chapter11 图</h2><h3 id=概念>概念</h3><p>图的定义：$G=(V,E)$</p><ul><li><p>$V$ Vertex 顶点的非空有限集合（也就是一组顶点）</p></li><li><p>$E$ 无序集 $V&V$ 的子集，其元素是图的弧（Arc）（也就是顶点对）</p></li><li><p>弧：表示两个顶点 $v$ 和 $w$ 之间存在一个关系，用顶点偶对 $&lt;v,w>$ 表示</p></li><li><p>有向图：若图G的关系集合E(G)中，顶点偶对&lt;v,w>的v和w之间是有序的，称图G是有向图。</p><ul><li>称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) ，就像向量。</li></ul></li><li><p>无向图：若图G的关系集合E(G)中，顶点偶对&lt;v,w>的v和w之间是无序的，称图G是无向图。</p></li><li><p>权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。</p></li><li><p>路径：顶点序列 $v_1, v_2, …, v_n$ 被称为长度为 n-1的路径，其中 $v_i$ 到 $v_{i+1}$ $(1 ≤ i &lt; n)$ 之间有连边</p></li><li><p>简单路径：路径中的所有顶点都是唯一的</p></li><li><p>环：长度不小于3的首尾相接的路径</p></li><li><p>简单环：除了第一个和最后一个顶点外，其余顶点都唯一的环是简单环</p></li><li><p>连通图 : 图中任何两个顶点之间都存在路径</p></li><li><p>连通分量：图中的极大连通子图（也就是让点形成的连通图最大）</p></li></ul><p>参考：<a class=link href=https://zhuanlan.zhihu.com/p/35864291 target=_blank rel=noopener>图的基本概念和遍历</a></p><h3 id=图的实现>图的实现</h3><h3 id=图的遍历>图的遍历</h3><p>图的遍历：按照某特定顺序，依次访问图中的顶点，且每个顶点只访问一次。</p><ol><li>深度优先搜索(Depth First Search ,DFS)</li><li>广度优先搜索(Breadth First Search, BFS)</li><li>拓扑排序(Topological Sort )</li></ol><h3 id=图的最短路径>图的最短路径</h3><p>常见求解问题:</p><ol><li>单源最短路径: 求从某个顶点S到图中其他顶点的最短路径</li><li>所有点对最短路径: 求任意两个顶点之间的最短路径</li></ol><p>定义：</p><ul><li>d(A, B) 从A到B的最短距离（最短路径长度）</li><li>w(A, B) 是A到B的连边的权重。如果A到B没有连边，则定义 w(A, B) = ∞.</li></ul><hr><p>单源最短路径：Dijkstra算法</p><hr><p>所有点对最短路径：Floyd算法</p><h3 id=最小代价生成树>最小代价生成树</h3><p>最小代价生成树（Minimum-Cost Spanning Tree ，MST) 问题：</p><ul><li>输入: 一个无向连通图 G</li><li>输出: 满足以下要求的 G 的子图<ol><li>该子图是包含所有顶点的连通图</li><li>该子图具有最小的代价（代价指的是图中的所有连边上的权重的总和）</li></ol></li></ul><p>有两种算法：</p><ul><li>Prim 最小代价生成树算法</li><li>Kruskal 最小代价生成树算法</li></ul></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 Todd's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.12.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#chapter-1>Chapter 1</a></li><li><a href=#chapter-2>Chapter 2</a></li><li><a href=#chapter-3>Chapter 3</a></li><li><a href=#chapter-4>Chapter 4</a><ol><li><a href=#线性表>线性表</a></li><li><a href=#栈>栈</a></li><li><a href=#队列>队列</a></li></ol></li><li><a href=#chapter-5-二叉树>Chapter 5 二叉树</a></li><li><a href=#chapter-6-一般树>Chapter 6 一般树</a></li><li><a href=#chapter7-内部排序>Chapter7 内部排序</a><ol><li><a href=#插入排序>插入排序</a></li><li><a href=#冒泡排序>冒泡排序</a></li><li><a href=#选择排序>选择排序</a></li><li><a href=#希尔排序shellsort>希尔排序（Shellsort）</a></li><li><a href=#快速排序>快速排序</a></li><li><a href=#归并排序>归并排序</a></li><li><a href=#堆排序>堆排序</a></li><li><a href=#箱排序和基数排序>箱排序和基数排序</a></li><li><a href=#排序算法性能比较>排序算法性能比较</a></li><li><a href=#排序算法的理论下界>排序算法的理论下界</a></li></ol></li><li><a href=#chapter9-查找>Chapter9 查找</a></li><li><a href=#chapter10-索引>Chapter10 索引</a><ol><li><a href=#线性索引>线性索引</a></li><li><a href=#二叉查找树-bst>二叉查找树 BST</a></li><li><a href=#2-3树>2-3树</a></li><li><a href=#b树>B+树</a></li></ol></li><li><a href=#chapter11-图>Chapter11 图</a><ol><li><a href=#概念>概念</a></li><li><a href=#图的实现>图的实现</a></li><li><a href=#图的遍历>图的遍历</a></li><li><a href=#图的最短路径>图的最短路径</a></li><li><a href=#最小代价生成树>最小代价生成树</a></li></ol></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>
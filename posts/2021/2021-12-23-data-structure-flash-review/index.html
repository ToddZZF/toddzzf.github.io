<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>数据结构一周速成 - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2021/2021-12-23-data-structure-flash-review/>数据结构一周速成</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">数据结构一周速成</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2021-12-23</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><blockquote><p>我真不明白为什么同一个课程，同样的内容，就只是因为开课的学院不同就不能互认，搞得我一门课程要学两次🙄</p></blockquote><h2 id=chapter-1>Chapter 1</h2><ol><li>什么是数据结构？<blockquote><p>研究如何在计算机中有效的存储和组织数据的方法</p></blockquote></li><li>如何表示数据结构？<blockquote><p>抽象数据类型（ADT）：是一种描述数据结构的程序设计语言无关的模型。ADT定义为一组数值，和一组相关的操作。</p></blockquote></li><li>什么是算法？<blockquote><p>算法：用于解决一个问题的方法或步骤。</p></blockquote></li><li>算法的属性：<blockquote><ol><li>确定性：它必须是正确的</li><li>可行性：它必须包含一系列具体的步骤，执行的过程无二义性</li><li>有穷性：它必须包含有限的步骤，它必须是可以结束的</li></ol></blockquote></li><li>数据结构 + 算法 = 程序<blockquote><ul><li>数据结构主要研究如何有效的存储和组织应用程序的数据。</li><li>算法主要研究如何对数据进行处理从而解决某个问题</li></ul></blockquote></li></ol><h2 id=chapter-2>Chapter 2</h2><h2 id=chapter-3>Chapter 3</h2><p>增长率分析：分析代价（时间、空间）如何随着输入数据规模大小的增长而增长</p><ul><li>$T(n)$：运行时间关于输入数据规模大小 $n$ 的函数。</li><li>$S(n)$：消耗空间关于输入数据规模大小 $n$ 的函数。</li></ul><hr><p>渐进分析：渐进分析是对T(n)的一种简化分析，该分析保留了 $T(n)$ 的渐进增长趋势</p><ul><li>大 $O$ 分析（上界分析）<blockquote><p>对于非负函数 $T(n)$，如果存在正常数 $c$ 和 $n_0$ 使得当 $n>n_0$ 时 $T(n)\leq cf(n)$，则称 $T(n)$ 属于集合 $O(f(n))$，或记为 $T(n)=O(f(n))$</p></blockquote></li><li>大 $\Omega$ 分析（下界分析）<blockquote><p>对于非负函数 $T(n)$，如果存在正常数 $c$ 和 $n_0$ 使得当 $n>n_0$ 时 $T(n)\geq cg(n)$，则称 $T(n)$ 属于集合 $\Omega(g(n))$，或记为 $T(n)=\Omega(g(n))$</p></blockquote></li><li>大 $\Theta$ 分析<blockquote><p>若 $T(n)=O(h(n))$ 且 $T(n)=\Omega(h(n))$，则称 $T(n)=\Theta(h(n))$</p></blockquote></li></ul><p>$T(n)$ 存在多个上界和下界。</p><hr><p>简化规则：</p><ul><li>常数规则：若 $f(n)=O(kg(n))$，$k>0$，则 $f(n)=O(g(n))$<ul><li>该规则同样适用于 $\Omega$ 和 $\Theta$</li></ul></li><li>加法规则：若 $f_1(n)=O(g_1(n))$ 且 $f_2(n)=O(g_2(n))$，则 $f_1(n)+f_2(n)=O(\max(g_1(n),g_2(n)))$</li><li>乘法规则：若 $f_1(n)=O(g_1(n))$ 且 $f_2(n)=O(g_2(n))$，则 $f_1(n)f_2(n)=O(g_1(n)g_2(n))$</li></ul><hr><p>常见的渐进复杂度：</p><p>$$
O(1)&lt;O(\log\log n)&lt;O(\log n)\
&lt;O(n)&lt;O(n\log n)\
&lt;O(n^2)&lt;\cdots&lt;O(n^k)\
&lt;O(k^n)&lt;O(n!)&lt;O(n^n)
$$</p><h2 id=chapter-4>Chapter 4</h2><h3 id=线性表>线性表</h3><p>概念：</p><ul><li><strong>线性表</strong>：由有限的数据元素构成的序列</li><li><strong>当前位置</strong>：在线性表中插入、删除、或读去数据的位置。当前位置通过**栅栏 (fence)**来定义。栅栏将线性表划分为左右两个部分。插入、删除、读取都在栅栏所在的位置执行（栅栏后面的位置）</li><li>一个包含0个数据元素的线性表称为<strong>空表</strong></li><li>线性表的<strong>长度</strong>指的是线性表中数据元素的个数</li><li>线性表的开始端称为<strong>表头（head）</strong>, 线性表的结束端称为<strong>表尾（tail）</strong></li><li><strong>有序表</strong>：表中的所有的数据元素是根据其数值的大小来进行先后排列</li><li><strong>无序表</strong>：表中数据元素的位置和该元素的数值没有必然联系</li></ul><hr><p>线性表ADT</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>insert</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>append</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>remove</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>getValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>setPos</span><span class=p>(</span><span class=kt>int</span> <span class=n>pos</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setStart</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setEnd</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>prev</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>next</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>leftLength</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>rightLength</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><p>线性表的实现：</p><ul><li>数组</li><li>链表</li></ul><table><thead><tr><th style=text-align:center>比较</th><th style=text-align:center>数组</th><th style=text-align:center>链表</th></tr></thead><tbody><tr><td style=text-align:center>插入与删除</td><td style=text-align:center>$\Theta(n)$</td><td style=text-align:center>$\Theta(1)$</td></tr><tr><td style=text-align:center>求前驱和随机访问</td><td style=text-align:center>$\Theta(1)$</td><td style=text-align:center>$\Theta(n)$</td></tr><tr><td style=text-align:center>特点</td><td style=text-align:center>需要提前为数组分配空间</td><td style=text-align:center>消耗的空间随数据元素个数的增长而增长</td></tr><tr><td style=text-align:center>空间<br>$E$ 每个数据元素所占空间大小<br>$P$：每个指针所占空间大小<br>$D$：数组最多能存放的数据元素的个数<br>$n$：当前数据元素的个数</td><td style=text-align:center>$DE$</td><td style=text-align:center>$n(P+E)$</td></tr></tbody></table><h3 id=栈>栈</h3><p>概念：</p><ul><li><strong>栈</strong>：插入、删除只在一端进行的线性表</li><li><strong>LIFO</strong> 性质: Last In, First Out. （后进先出）</li><li><strong>入栈(PUSH)</strong>：插入元素到栈中</li><li><strong>出栈(POP)</strong>：从栈中取出元素</li><li><strong>栈顶(TOP)</strong>：栈中插入、删除的位置</li></ul><hr><p>栈的ADT</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Stack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Reinitialize the stack
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Push an element onto the top of the stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>push</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Remove the element at the top of the stack. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get a copy of the top element in the stack
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>topValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Return the number of elements in the stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>length</span> <span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><p>栈的实现：</p><ul><li>数组</li><li>链表</li></ul><h3 id=队列>队列</h3><p>概念：</p><ul><li><strong>队列</strong>: 插入和删除分别在表的两端进行的线性表</li><li><strong>FIFO</strong> 性质: First in, First Out （先进后出）</li><li>插入: <strong>enqueue（入队）</strong></li><li>删除: <strong>dequeue （出队）</strong></li><li>第一个元素: <strong>front（队头）</strong></li><li>最后一个元素: <strong>rear（队尾）</strong></li></ul><hr><p>队列ADT</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Queue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>enqueue</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>dequeue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>frontValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>length</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><p>栈的实现：</p><ul><li>数组</li><li>链表</li></ul><h2 id=chapter-5-二叉树>Chapter 5 二叉树</h2><p>概念：</p><ul><li><p><strong>二叉树</strong>是一个包含有限个结点的集合，有以下两种情况</p><ul><li>空集，<strong>空树</strong></li><li>包含一个称为<strong>树根(root)<strong>的结点，以及两个互不相交的二叉树，它们分别称为</strong>左子树</strong>和<strong>右子树</strong></li></ul></li><li><p>对于树上的每个结点，和它有连边的下层结点称为它的<strong>孩子结点</strong>。在二叉树中，每个结点最多会有两个孩子，最少没有孩子</p></li><li><p>对于二叉树上的每个结点，和它有连边的上层结点称为它的<strong>父亲结点</strong>。二叉树中，除了树根外，每个结点都有一个父亲结点。</p></li><li><p>一个结点的父亲，父亲的父亲，父亲的父亲的父亲，等等都是它的<strong>祖先结点</strong>。反过来，一个结点的孩子，孩子的孩子，孩子的孩子的孩子，等等都是它的<strong>后辈结点</strong></p></li><li><p><strong>叶子结点</strong>：没有孩子结点的结点为叶子结点</p></li><li><p><strong>路径</strong>：一个结点序列 $n_1,n_2,\cdot,n_k$，如果其中的每个结点 $n_i$ 是 $n_{i+1}$ 的父亲（$1\leq i \leq k$），我们就称这个序列是从 $n_1$ 到 $n_k$ 的路径。这条路径的长度等于 $k-1$</p></li><li><p><strong>深度</strong>：一个结点的深度等于从树根到这个结点的路径的长度</p></li><li><p><strong>层次</strong>：根结点为第0层，往下逐个增加。（貌似等于深度）</p></li><li><p><strong>高度</strong>：一棵树的高度等于其中最大结点深度加一</p></li><li><p><strong>满二叉树</strong>：二叉树的每个结点都是叶子或拥有两个孩子的中间结点。</p><ul><li><strong>非空满二叉树中叶子的数目比中间结点多一个</strong>，这个很容易证明：如果只有根结点，则只有一个叶子结点，没有中间结点。每增加两个叶子，则原有的叶子结点会变为中间结点，故叶子始终比中间结点多一个。</li></ul></li><li><p><strong>完全二叉树</strong>: 除了最深的层次，二叉树的所有层次都填满结点，且最深层的叶子结点集中在该层的最左边的位置</p></li></ul><hr><p>二叉树结点ADT</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Template</span>  <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>  <span class=k>class</span> <span class=nc>BinNode</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>Elem</span><span class=o>&amp;</span> <span class=n>val</span><span class=p>(</span> <span class=p>)</span> <span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setVal</span><span class=p>(</span> <span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>BinNode</span><span class=o>*</span> <span class=nf>left</span><span class=p>(</span> <span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setLeft</span><span class=p>(</span> <span class=n>BinNode</span><span class=o>*</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>BinNode</span><span class=o>*</span> <span class=nf>right</span><span class=p>(</span> <span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>setRight</span><span class=p>(</span> <span class=n>BinNode</span><span class=o>*</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>isLeaf</span><span class=p>(</span> <span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><p>二叉树的实现：</p><ul><li>基于链接的方式</li><li>基于数组的方式</li></ul><hr><p>哈夫曼编码：</p><ul><li>一种可变长度的编码</li><li>高频字符对应较短的编码</li></ul><p>哈夫曼编码的编码过程需要用到一种称为<strong>哈夫曼树</strong>的满二叉树结构。</p><p>平均编码长度取决于所有叶子的加权路径长度的和</p><p>定理: 对于给定的一组字符以及出现的频率，以它们作为叶子节点构建的满二叉树中，哈夫曼树具有最小的加权路径长度的和。在预先知道每个字符的出现的频率的前提下，哈夫曼编码是具有最小的平均编码长度的非前缀编码。</p><p>构建哈夫曼编码的算法：</p><h2 id=chapter-6-一般树>Chapter 6 一般树</h2><p>概念：</p><ul><li><strong>树</strong> T 是一个包含一个或多个节点的有限集合，其中有一个称为 <strong>树根</strong> 的节点r，余下的节点(T –{r}) 可以被划分为k个( k≥0)互不想交的子集 T1, T2, &mldr;, Tk, 每个子集都是一棵树,它们的树根 r1, r2, &mldr;, rk,都是r的孩子</li><li><strong>森林</strong>：是包含有一棵或多棵树的集合。</li></ul><hr><p>树结点 ADT</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// General tree node ADT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>GTNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>GTNode</span><span class=p>(</span><span class=k>const</span> <span class=n>Elem</span><span class=o>&amp;</span><span class=p>);</span> <span class=c1>// Constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>GTNode</span><span class=p>();</span>           <span class=c1>// Destructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Elem</span> <span class=nf>value</span><span class=p>();</span>        <span class=c1>// Return value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>isLeaf</span><span class=p>();</span>       <span class=c1>// TRUE if is a leaf
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>parent</span><span class=p>();</span>    <span class=c1>// Return parent
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>leftmost_child</span><span class=p>();</span> <span class=c1>// First child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>right_sibling</span><span class=p>();</span>  <span class=c1>// Right sibling
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>setValue</span><span class=p>(</span><span class=n>Elem</span><span class=o>&amp;</span><span class=p>);</span>     <span class=c1>// Set value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//insert first child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>insert_first</span><span class=p>(</span><span class=n>GTNode</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//insert right sibling
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>insert_next</span><span class=p>(</span><span class=n>GTNode</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>remove_first</span><span class=p>();</span> <span class=c1>// Remove first child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>remove_next</span><span class=p>();</span>  <span class=c1>// Remove sibling
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>树 ADT</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// General tree ADT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>GenTree</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>GenTree</span><span class=p>();</span>               <span class=c1>// Constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>GenTree</span><span class=p>();</span>              <span class=c1>// Destructor  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>clear</span><span class=p>();</span>            <span class=c1>// Send nodes to free store
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GTNode</span><span class=o>*</span> <span class=nf>root</span><span class=p>();</span>          <span class=c1>// Return the root
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=n>GTNode</span><span class=o>*</span><span class=p>);</span> <span class=c1>// Print function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h2 id=chapter7-内部排序>Chapter7 内部排序</h2><p>概念：</p><ul><li><p>排序：给定一个序列的记录 $R_1 , R_2 , … , R_n$，它们对应的关键字依次是 $k_1 , k_2 ,… , k_n$ , 调整记录在序列中的次序得到新的记录序列 $R_{s1},R_{s2},…,R_{sn}$，使得记录的关键字满足以下性质： $k_{s1} ≤ k_{s2} ≤ …≤ k_{sn}$.</p></li><li><p>稳定的排序算法：排序的过程不会改变具有相等关键字的记录的相对先后次序。</p></li><li><p>内部排序：指的是待排序记录存放在计算机随机存储器中进行的排序过程。</p></li><li><p>外部排序：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录, 在排序过程中尚需对外存进行访问的排序过程。</p></li></ul><hr><h3 id=插入排序>插入排序</h3><p>记忆：像洗牌，将每张牌插入到合适的位置</p><p>实现：在第i次迭代，将第i个元素与前面 i-1 个元素进行比较，使其插入到前面适当的位置(1 &lt;= i &lt;= n-1)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>inssort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span> <span class=p>(</span><span class=n>j</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]));</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span><span class=c1>//插入第i个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>代价分析：最好 $\Theta(n)$，最坏 $\Theta(n^2)$，平均 $\Theta(n^2)$</p><p>插入排序是一种稳定的排序算法。</p><h3 id=冒泡排序>冒泡排序</h3><p>实现：由后到前，相邻两个元素比较，逆序则交换。一次冒泡过程结束后，最小的元素会到达最前面。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>bubsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>&gt;</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>代价分析：最好、最坏、平均都是 $\Theta(n^2)$。</p><p>冒泡排序算法是一种稳定的排序算法。</p><h3 id=选择排序>选择排序</h3><p>实现：第i趟排序就是从位置属于[i,n-1]的元素中，选出最小的元素，并将其和第i位置上的元素交换</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>selsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>   <span class=c1>// select the minial values in [i,n-1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>lowindex</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=c1>// lowindex指向较小的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>&gt;</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span> <span class=c1>// Find least
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>lowindex</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>lowindex</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>lowindex</span><span class=p>);</span> <span class=c1>// Put it in place
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>代价分析：最好、最坏、平均都是 $\Theta(n^2)$。</p><p>选择排序是一种不稳定的排序算法。</p><h3 id=希尔排序shellsort>希尔排序（Shellsort）</h3><p>思路（分组）：每隔一定间距取一个元素放入同一组，将所有元素分成多组，并在组内进行插入排序。然后减小间距重新分组，重新排序。最后当间距为 1 时，退化为一般的插入排序。</p><p>分析：由于最后一次排序是一般的插入排序，所以这种方法是可行的。而前面几次排序可以使元素一次性移动多格，所以速度会快。</p><p>代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Modified version of Insertion Sort
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>inssort2</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>from</span><span class=p>,</span> <span class=kt>int</span> <span class=n>incr</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span> <span class=n>from</span> <span class=o>+</span> <span class=n>incr</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>+=</span><span class=n>incr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span> <span class=p>(</span><span class=n>j</span><span class=o>&gt;</span> <span class=n>from</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>           <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=n>incr</span><span class=p>]);</span> <span class=n>j</span><span class=o>-=</span><span class=n>incr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=n>incr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>shellsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// Shellsort
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>n</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=n>i</span><span class=o>&gt;=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>/=</span><span class=mi>2</span><span class=p>)</span>  <span class=c1>// For each incr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>   <span class=c1>// Sort sublists
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>inssort2</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>   
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当增量序列为 $∆[k] = 2^{t-k+1}-1$ 时，算法复杂度为 $O(n^{3/2})$。 其中 t 是排序的趟数，$1\leq k\leq t$。例如（15，7，3，1）。<a href=https://zhuanlan.zhihu.com/p/73726253>证明过程</a></p><p>希尔排序是一种不稳定排序。</p><h3 id=快速排序>快速排序</h3><p>思想（分而治之）：选择一个记录的值作为支点（pivot）。将小于支点的记录安排在支点的左侧，将大于等于支点的记录安排在支点的右侧。从而将原序列划分为左右两个子序列。然后在子序列中重复该过程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>qsort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;=</span> <span class=n>i</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>     <span class=c1>// List too small
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>pivot</span> <span class=o>=</span> <span class=n>findpivot</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>pivot</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>  <span class=c1>// Put pivot at end
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>partition</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>         <span class=c1>// Put pivot in place
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>qsort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>qsort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>findpivot</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>partition</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span><span class=n>Elem</span><span class=o>&amp;</span> <span class=n>pivot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>l</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>)</span> <span class=n>l</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>l</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>A</span><span class=p>[</span><span class=n>r</span><span class=p>]</span> <span class=o>&gt;=</span><span class=n>pivot</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=n>r</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span> <span class=c1>// Swap out-of-place values
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;</span> <span class=n>r</span><span class=p>);</span> <span class=c1>// Stop when they cross
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>l</span><span class=p>;</span>       <span class=c1>// Return first pos on right
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>代价分析：类似二叉树（层数代表次数）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=c>#best: 每次都均匀分成两段</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span>--------<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span>---- ----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>-- -- -- --<span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- - - - - - - -<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c>#worst</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span>-----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- -------<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- ------<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- -----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- ----<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- ---<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>- --<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- -<span class=w>
</span></span></span></code></pre></div><p>平均情况：</p><p>$$
T(n)=cn+\frac{1}{n} \sum_{k=0}^{n-1} (T(k)+T(n-1-k))=\Theta(n \log n)
$$</p><p>改进方法：</p><ul><li>选取更好的支点<ul><li>选择以下三个记录中的中间值作为支点 : 序列的第一个，中间，最后一个记录</li></ul></li><li>采用非递归的算法来实现快速排序</li></ul><h3 id=归并排序>归并排序</h3><p>思路（分而治之）：将一个序列划分为两个长度相等的子序列，然后递归的对每个子序列进行归并排序。将排好序的两个子序列归并为一个有序的序列。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Elem</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>mergesort</span><span class=p>(</span><span class=n>Elem</span> <span class=n>A</span><span class=p>[],</span> <span class=n>Elem</span> <span class=n>temp</span><span class=p>[],</span>
</span></span><span class=line><span class=cl>               <span class=kt>int</span> <span class=n>left</span><span class=p>,</span> <span class=kt>int</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span><span class=o>+</span><span class=n>right</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>left</span> <span class=o>==</span> <span class=n>right</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>mergesort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>mergesort</span><span class=o>&lt;</span><span class=n>Elem</span><span class=o>&gt;</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>left</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>right</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>// Copy
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>temp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i1</span> <span class=o>=</span> <span class=n>left</span><span class=p>;</span> <span class=kt>int</span> <span class=n>i2</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>curr</span><span class=o>=</span><span class=n>left</span><span class=p>;</span> <span class=n>curr</span><span class=o>&lt;=</span><span class=n>right</span><span class=p>;</span> <span class=n>curr</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i1</span> <span class=o>==</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>      <span class=c1>// Left exhausted
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i2</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>i2</span> <span class=o>&gt;</span> <span class=n>right</span><span class=p>)</span>  <span class=c1>// Right exhausted
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i1</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>temp</span><span class=p>[</span><span class=n>i1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>temp</span><span class=p>[</span><span class=n>i2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i1</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>A</span><span class=p>[</span><span class=n>curr</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i2</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>代价分析：最好、最坏、平均都是 $\Theta(n \log n)$。</p><h3 id=堆排序>堆排序</h3><p>思路：堆顶结点的值总保持是最大值/最小值，故每次取堆顶，然后用剩下元素建堆，再重复该过程。</p><p>代价分析：建堆 $\Theta(n)$，移除最大值 $\Theta(\log n)$，n 次移除最大值 $\Theta(n\log n)$。故总代价为 $\Theta(n\log n)$</p><p>详细分析见我的博客。</p><h3 id=箱排序和基数排序>箱排序和基数排序</h3><p>箱排序（Binsort）：设置若干个箱子，依次扫描待排序的记录 R[0]，R[1]，…，R[n-1]，把关键字等于 k 的记录分配到第 k 个箱子里，然后按序号依次将各非空的箱子中的记录收集起来。</p><p>示例：3，8，1，8，4，放入下面这组箱子，允许多个记录具有相同的关键字（链表）</p><pre tabindex=0><code class=language-raw data-lang=raw>                 8
---------------------
| |1| |3|4| | | |8| |
---------------------
 0 1 2 3 4 5 6 7 8 9
</code></pre><p>然后从左到右逐个扫描箱子，如果有关键字，则取出：1，3，4，8，8</p><p>代价：对于Key取值范围较大的记录进行Binsort，较为低效。放进箱子需要 $n$ 次，然后要扫描所有箱子，所以代价为：$\Theta(n + m)$，$n$ 是记录个数，$m$ 是箱子个数。</p><p>箱排序是稳定的。</p><hr><p>基数排序（Radix Sort）：对箱排序的改进。将任何一个 $r$ 进制的整数 key $\overline{K_{d-1}K_{d-2}\cdots K_0}$ 看成是由 $d$ 个分量组成，$K_{d-1},K_{d-2},\cdots ,K_0$，对每个分量进行箱排序。</p><p>示例：十进制，27，91，1，97，17，23，84，28，72，5，67，25，先按个位放入箱子</p><pre tabindex=0><code class=language-raw data-lang=raw>0
1-&gt;91-&gt;1
2-&gt;72
3-&gt;23
4-&gt;84
5-&gt;5-&gt;25
6
7-&gt;27-&gt;97-&gt;17-&gt;67
8-&gt;28
9
</code></pre><p>然后取出来：91，1，72，23，84，5，25，27，97，17，67，28</p><p>再按十位放入箱子</p><pre tabindex=0><code class=language-raw data-lang=raw>0-&gt;1-&gt;5
1-&gt;17
2-&gt;23-&gt;25-&gt;27-&gt;28
3
4
5
6-&gt;67
7-&gt;72
8-&gt;84
9-&gt;91-&gt;97
</code></pre><p>再取出来：1，5，17，23，25，27，28，67，72，84，01，07</p><p>代价：每次放入全部 $n$ 个元素，$r$ 进制则需要扫描 $r$ 个箱子，需要重复位数 $d$ 次。故代价为 $\Theta((n+r)d)$，$n$ 是记录个数，$d$ 是Key的位数，$r$ 是基数。</p><p>基数排序是稳定的排序。</p><h3 id=排序算法性能比较>排序算法性能比较</h3><h3 id=排序算法的理论下界>排序算法的理论下界</h3><p>排序问题的上界是 $n \log n$。因为我们能找到的最好排序算法的平均情况下的算法复杂度是 $O(n \log n)$</p><p>我们将证明排序问题的理论下界也是 $n \log n$。</p><p>我们考虑排序的决策树（每个结点处进行一次比较，根据结果分为左右子树），其叶子数量为 $N!$（因为有 $N!$ 种可能结果），深度为 $d$ 的二叉树最多有 $2^{d+1}-1$ 个叶子，那反过来，$N!$ 个叶子的二叉树的深度至少是 $\lceil \log(N!+1) \rceil-1$，即 $\Omega (\log n!)=\Omega(n \log n)$</p><p>$$
斯特林公式：n!\approx \sqrt{2\pi n} \left( \frac{n}{e} \right)^n
$$</p><p>所以排序所需的时间 $T=\Omega(n \log n)$</p><h2 id=chapter9-查找>Chapter9 查找</h2><p>定义：</p><h2 id=chapter10-索引>Chapter10 索引</h2><p>原文件在硬盘中太大，不方便直接查找，所以建立索引文件。</p><p>索引文件：</p><ol><li>索引文件中记录了关键字和对应的数据记录存储在硬盘中的位置</li><li>索引文件比数据记录小的多，查找时被加载到内存中进行查找</li><li>针对不同关键字的索引文件，支持多关键字查找</li></ol><h3 id=线性索引>线性索引</h3><p>线性索引: 索引文件组织成二元组(关键字, 指向记录的指针) 的序列。</p><p>如果索引太大无法加载到内存，则建立二级索引。分段，取每一段的最小值重新构成序列。</p><p>不足之处：插入和删除操作会导致大量数据移动 $\Theta(n)$</p><h3 id=二叉查找树-bst>二叉查找树 BST</h3><p>二叉查找数：对每个结点，左子结点比它小，右子结点比它大</p><p>二叉平衡树：左右子树的高度差不超过1</p><p>二叉平衡树查找复杂度 $\Theta(\log n)$</p><p>不足之处：让BST保持平衡需要付出较高的代价，插入一个结点需要调整大量结点。</p><h3 id=2-3树>2-3树</h3><p>2-3树的性质：</p><h3 id=b树>B+树</h3><h2 id=chapter11-图>Chapter11 图</h2><h3 id=概念>概念</h3><p>图的定义：$G=(V,E)$</p><ul><li><p>$V$ Vertex 顶点的非空有限集合（也就是一组顶点）</p></li><li><p>$E$ 无序集 $V&amp;V$ 的子集，其元素是图的弧（Arc）（也就是顶点对）</p></li><li><p>弧：表示两个顶点 $v$ 和 $w$ 之间存在一个关系，用顶点偶对 $&lt;v,w>$ 表示</p></li><li><p>有向图：若图G的关系集合E(G)中，顶点偶对&lt;v,w>的v和w之间是有序的，称图G是有向图。</p><ul><li>称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) ，就像向量。</li></ul></li><li><p>无向图：若图G的关系集合E(G)中，顶点偶对&lt;v,w>的v和w之间是无序的，称图G是无向图。</p></li><li><p>权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。</p></li><li><p>路径：顶点序列 $v_1, v_2, …, v_n$ 被称为长度为 n-1的路径，其中 $v_i$ 到 $v_{i+1}$ $(1 ≤ i &lt; n)$ 之间有连边</p></li><li><p>简单路径：路径中的所有顶点都是唯一的</p></li><li><p>环：长度不小于3的首尾相接的路径</p></li><li><p>简单环：除了第一个和最后一个顶点外，其余顶点都唯一的环是简单环</p></li><li><p>连通图 : 图中任何两个顶点之间都存在路径</p></li><li><p>连通分量：图中的极大连通子图（也就是让点形成的连通图最大）</p></li></ul><p>参考：<a href=https://zhuanlan.zhihu.com/p/35864291>图的基本概念和遍历</a></p><h3 id=图的实现>图的实现</h3><h3 id=图的遍历>图的遍历</h3><p>图的遍历：按照某特定顺序，依次访问图中的顶点，且每个顶点只访问一次。</p><ol><li>深度优先搜索(Depth First Search ,DFS)</li><li>广度优先搜索(Breadth First Search, BFS)</li><li>拓扑排序(Topological Sort )</li></ol><h3 id=图的最短路径>图的最短路径</h3><p>常见求解问题:</p><ol><li>单源最短路径: 求从某个顶点S到图中其他顶点的最短路径</li><li>所有点对最短路径: 求任意两个顶点之间的最短路径</li></ol><p>定义：</p><ul><li>d(A, B) 从A到B的最短距离（最短路径长度）</li><li>w(A, B) 是A到B的连边的权重。如果A到B没有连边，则定义 w(A, B) = ∞.</li></ul><hr><p>单源最短路径：Dijkstra算法</p><hr><p>所有点对最短路径：Floyd算法</p><h3 id=最小代价生成树>最小代价生成树</h3><p>最小代价生成树（Minimum-Cost Spanning Tree ，MST) 问题：</p><ul><li>输入: 一个无向连通图 G</li><li>输出: 满足以下要求的 G 的子图<ol><li>该子图是包含所有顶点的连通图</li><li>该子图具有最小的代价（代价指的是图中的所有连边上的权重的总和）</li></ol></li></ul><p>有两种算法：</p><ul><li>Prim 最小代价生成树算法</li><li>Kruskal 最小代价生成树算法</li></ul></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=pragma content="no-cache"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.7.0/style.css><link rel=stylesheet href=/css/tailwindcss/output.css><link rel=stylesheet href=/css/mdstyle.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script id=highlightjs src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js async></script>
<script>document.getElementById("highlightjs").addEventListener("load",function(){hljs.highlightAll()})</script><title>尝试Hugo - Todd's Blog</title></head><body class="font-kai bg-neutral-50 antialiased"><header class="w-full text-gray-700 bg-white dark-mode:text-gray-200 dark-mode:bg-gray-800 shadow-sm"><div x-data="{ open: false }" class="flex flex-col max-w-screen-xl px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="p-4 flex flex-row items-center justify-between"><a href=/ class="text-lg tracking-wider text-gray-900 uppercase rounded-lg dark-mode:text-white">Todd's Blog</a>
<button class="md:hidden rounded-lg focus:outline-none focus:drop-shadow-sm" @click="open = !open"><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow pb-4 md:pb-0 hidden md:flex md:justify-end md:flex-row"><a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/goodstuffs/>好物</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold text-gray-900 rounded-lg dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 dark-mode:focus:bg-gray-600 dark-mode:focus:text-white dark-mode:hover:text-white dark-mode:text-gray-200 md:mt-0 hover:text-gray-900 focus:text-gray-900 hover:bg-gray-200 focus:bg-gray-200 focus:outline-none focus:shadow-outline" href=/posts/>日常</a></nav></div></header><main><div class="max-w-screen-lg w-full mx-auto py-8 px-4 flex flex-col gap-4"><div class="breadcrumb w-full bg-white py-2 px-4 shadow-sm"><ul class="flex align-baseline flex-wrap"><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/>主页</a></li><li class="after:content-['>'] after:mr-0.5 after:text-gray-300 whitespace-nowrap"><a href=http://example.org/posts/>日常</a></li><li class="active whitespace-nowrap"><a href=http://example.org/posts/2022/2022-05-25-try-out-hugo/>尝试Hugo</a></li></ul></div><div class="w-full mx-auto py-8"><div class="text-4xl font-semibold">尝试Hugo</div><div class="flex gap-2 text-sm flex-wrap"><span class=post-date>2022-05-25</span>
<a href=/posts/>📂日常</a></div></div><div class="mdstyle highlightjs"><p>本博客已用 Hugo 重构。</p><h2 id=hugo入门>Hugo入门</h2><p>自从我开始写博客以来，我一直使用的是 <a href=https://jekyllrb.com/>Jekyll</a>，因为 github page 用的就是 Jekyll，我不需要在本地生成静态页面。但当我开始自己设计主题后，Jekyll 繁琐的安装方式和非常慢的生成页面的速度，让我很不爽。因此我决定尝试使用 <a href=https://gohugo.io/>Hugo</a>. Hugo 是由 Go 编写的，并且运行速度很快（宣传生成一篇文章只需 1ms）。Hugo 的安装方式十分简单，下载一个 exe 文件，然后添加到 PATH 里即可。可以用以下命令验证安装是否成功：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ hugo version
</span></span><span class=line><span class=cl>hugo v0.99.1-d524067382e60ce2a2248c3133a1b3af206b6ef1 windows/amd64 <span class=nv>BuildDate</span><span class=o>=</span>2022-05-18T11:18:14Z <span class=nv>VendorInfo</span><span class=o>=</span>gohugoio
</span></span></code></pre></div><p>Hugo 建立静态网站的步骤和 Jekyll 很类似，都是 init -> write -> generate -> serve。可以跟着官网的 <a href=https://gohugo.io/getting-started/quick-start/>Quick Start</a> 实践一下。</p><p>Hugo 的主题管理用的是 git submodule，并且在配置文件 <code>config.toml</code> 中设置 <code>theme = "[your theme]"</code>。顺便提一下 <a href=https://toml.io/cn/>toml</a> 是一种与 json、yaml 类似的配置文件格式。（尽管我个人更喜欢yaml，因为 toml 的表必须写在最后面，让我很难受）</p><p>Hugo 的文章放在 <code>/content/post/</code> 下，写完后用 <code>hugo server -D</code> 来预览，地址是 <a href=http://localhost:1313/>http://localhost:1313/</a>，预览是实时更新的。</p><p>Hugo 提供了迁移命令 <code>import</code>，可以将其他博客项目转换为 Hugo 项目，命令格式是 <code>hugo import jekyll JEKYLL_ROOT_PATH TARGET_PATH</code></p><h2 id=hugo开发>Hugo开发</h2><h3 id=hugo命令>Hugo命令</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>hugo new site <span class=o>[</span>site name<span class=o>]</span> <span class=c1># 新建一个 site name 网站</span>
</span></span><span class=line><span class=cl>hugo <span class=c1># 在 /public/ 文件夹中生成页面</span>
</span></span><span class=line><span class=cl>hugo server <span class=c1># 运行一个实时更新的服务器</span>
</span></span></code></pre></div><p>以上两个命令可以和以下参数结合：</p><ul><li><code>-D</code>：生成草稿（Drafts）</li><li><code>-E</code>：生成过期文章（Expired）</li><li><code>-F</code>：生成未来文章（Future）</li></ul><h3 id=项目结构>项目结构</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── archetypes <span class=c1># 头信息模板</span>
</span></span><span class=line><span class=cl>├── config.toml <span class=c1># 配置文件</span>
</span></span><span class=line><span class=cl>├── content <span class=c1># 博文</span>
</span></span><span class=line><span class=cl>├── data <span class=c1># 数据</span>
</span></span><span class=line><span class=cl>├── layouts <span class=c1># 样式</span>
</span></span><span class=line><span class=cl>├── static <span class=c1># 静态文件</span>
</span></span><span class=line><span class=cl>└── themes <span class=c1># 主题</span>
</span></span></code></pre></div><h3 id=内容管理>内容管理</h3><h4 id=page-bundles>Page Bundles</h4><blockquote><p><a href=https://gohugo.io/content-management/page-bundles/>官方文档</a></p></blockquote><p>Page Bundles 用于组织页面资源。Page Bundles 分为 Leaf Bundle 和 Branch Bundle。两者区别如下：</p><table><thead><tr><th></th><th>Leaf Bundle</th><th>Branch Bundle</th></tr></thead><tbody><tr><td>用法</td><td>单页内容和附件的集合</td><td>一系列内容的集合（比如 home page）</td></tr><tr><td>Index file name</td><td><code>index.md</code></td><td><code>_index.md</code></td></tr><tr><td>允许的资源</td><td>page 和 non-page（图片等）</td><td>non-page（图片等）</td></tr><tr><td>资源存放的位置</td><td>leaf bundle 文件夹内的任何文件夹</td><td>只能存放在 branch bundle 的文件夹，与 <code>_index.md</code> 同级</td></tr><tr><td>Layout 类型</td><td>single</td><td>list</td></tr><tr><td>示例</td><td><code>/content/posts/my-post/index.md</code></td><td><code>content/posts/_index.md</code></td></tr><tr><td>非index文件</td><td>Accessed only as page resources</td><td>Accessed only as regular pages</td></tr></tbody></table><p>简单来说，如果只是单篇博文，那么就用 Leaf Bundle；如果是多篇博文，那就用 Branch Bundle. 由于 <code>/content/</code> 本身就包含了所有的博文，所以它应该是 Branch Bundle（我们应该建立一个 <code>/content/_index.md</code>）。</p><p>以下是 Leaf Bundle 示例：</p><pre tabindex=0><code>content/
├── about
│   ├── index.md
├── posts
│   ├── my-post
│   │   ├── content1.md
│   │   ├── content2.md
│   │   ├── image1.jpg
│   │   ├── image2.png
│   │   └── index.md
│   └── my-other-post
│       └── index.md
│
└── another-section
    ├── ..
    └── not-a-leaf-bundle
        ├── ..
        └── another-leaf-bundle
            └── index.md
</code></pre><p>以下是 Branch Bundle 示例：</p><pre tabindex=0><code>content/
├── branch-bundle-1
│   ├── branch-content1.md
│   ├── branch-content2.md
│   ├── image1.jpg
│   ├── image2.png
│   └── _index.md
└── branch-bundle-2
    ├── _index.md
    └── a-leaf-bundle
        └── index.md
</code></pre><p>相比之下，Jekyll 是将博文放在 <code>_post</code>，而图片放在其他文件夹，这点就不太好，图片一多就容易乱。</p><h4 id=page-resources>Page Resources</h4><blockquote><p><a href=https://gohugo.io/content-management/page-resources/>官方文档</a></p></blockquote><p>页面资源（图片、其他页面、文档等）可以通过 Page Bundle 访问，但不同 Page Bundle 的页面资源不互通。有三种方法可以获得页面资源：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 通过文件类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{{</span> <span class=p>.</span><span class=nx>Resources</span><span class=p>.</span><span class=nx>ByType</span> <span class=s>&#34;image&#34;</span> <span class=p>}}</span>
</span></span><span class=line><span class=cl><span class=c1>// 通过文件名匹配，支持模糊匹配
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{{</span> <span class=p>.</span><span class=nx>Resources</span><span class=p>.</span><span class=nx>Match</span> <span class=s>&#34;images/*&#34;</span> <span class=p>}}</span>
</span></span><span class=line><span class=cl><span class=p>{{</span> <span class=p>.</span><span class=nx>Resources</span><span class=p>.</span><span class=nx>Match</span> <span class=s>&#34;**/sunset.jpg&#34;</span> <span class=p>}}</span>
</span></span><span class=line><span class=cl><span class=c1>// 通过文件名匹配，但返回第一个匹配的文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{{</span> <span class=p>.</span><span class=nx>Resources</span><span class=p>.</span><span class=nx>GetMatch</span> <span class=s>&#34;images/*&#34;</span> <span class=p>}}</span>
</span></span></code></pre></div><h4 id=front-matter>Front Matter</h4><blockquote><p><a href=https://gohugo.io/content-management/front-matter/>官方文档</a></p></blockquote><p>Hugo 的 Front Matter 和 Jekyll 一样也可以用 yaml。</p><p>以下是部分常用的预定义的 Front Matter 变量（除了这些之外也可以自定义变量）：</p><ul><li><p><code>date</code>：日期</p></li><li><p><code>expiryDate</code>：过期日期（过了过期日期文章就看不了）</p></li><li><p><code>publishDate</code>：出版日期（没到出版日期文章就看不了）</p></li><li><p><code>lastmod</code>：最后修改时间</p></li><li><p><code>draft</code>：是否是草稿。如果设置为 <code>true</code>，则不会生成页面。</p></li><li><p><code>title</code>：文章标题</p></li><li><p><code>type</code>：文章类型（如果没设置，则默认是文件夹名）</p></li><li><p><code>keyword</code>：文章关键字</p></li><li><p><code>description</code>：文章描述</p></li><li><p><code>images</code>：与文章相关的一组图片，用于 <a href=https://gohugo.io/templates/internal>Internal Templates</a></p></li><li><p><code>audio</code>：与文章相关的一组音频，用于 <a href=https://gohugo.io/templates/internal>Internal Templates</a></p></li><li><p><code>videos</code>：与文章相关的一组视频，用于 <a href=https://gohugo.io/templates/internal>Internal Templates</a></p></li><li><p><code>aliases</code>：替代地址（alias直译是别名），Hugo 会在替代地址处生成一个跳转网页，当访问替代地址时会跳转到原页面地址。<a href=https://gohugo.io/content-management/urls/#aliases>详情</a></p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>aliases</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>/posts/my-original-url/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>/2010/01/01/even-earlier-url.html</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span></code></pre></div><ul><li><code>cascade</code>：一组会传递给子页面的变量（和 Jekyll 中的默认变量差不多），我们可以用 <code>_target</code> 为特定的子页面设置不同变量。<a href=https://gohugo.io/content-management/front-matter/#front-matter-cascade>详情</a>。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>cascade</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>_target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>page</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>lang</span><span class=p>:</span><span class=w> </span><span class=l>en</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/blog/**</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>background</span><span class=p>:</span><span class=w> </span><span class=l>yosemite.jpg</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>_target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>section</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>background</span><span class=p>:</span><span class=w> </span><span class=l>goldenbridge.jpg</span><span class=w>
</span></span></span></code></pre></div><ul><li><p><code>layout</code>：页面布局。如果没有的话，就采用与 section 名相同的 layout。更多请看 <a href=https://gohugo.io/templates/lookup-order/>Hugo Layouts Lookup Rules</a></p></li><li><p><code>weight</code>：用于整理文章。必须是非 0 值，0 表示未设置 weight（默认的排序权重是：Weight > Date > LinkTitle > FilePath）</p></li><li><p><code>_build</code>：可以指定页面的 Build Options，有两个子变量 <code>list</code> 和 <code>render</code>，用法见 <a href=https://gohugo.io/content-management/build-options/#illustrative-use-cases>use cases</a></p></li></ul><h3 id=图像处理>图像处理</h3><blockquote><p><a href=https://gohugo.io/content-management/image-processing/>官方文档</a></p></blockquote><p>得益于 go 自带的图像处理库，我们可以在文章内对文章进行处理，比如裁剪、滤镜、压缩、获取Exif信息（这个在相册中非常有用）</p><h3 id=archetypes>Archetypes</h3><blockquote><p><a href=https://gohugo.io/content-management/archetypes/>官方文档</a></p></blockquote><p>Archetypes 中文是原型，当使用 <code>hugo new</code> 命令新建一个文章时，会使用 <code>archetypes</code> 中的文件来初始化文件，比如如果定义一个 <code>archetypes/newsletter.md</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>title</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{ replace .Name &#34;</span>-<span class=s2>&#34; &#34;</span><span class=w> </span><span class=s2>&#34; | title }}&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>date</span><span class=p>:</span><span class=w> </span>{{<span class=w> </span><span class=l>.Date }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>draft</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span></code></pre></div><p>那么当在 <code>/content/newsletter/</code> 内用命令行新建文章时，就会自动填写 front matter（再也不同复制粘贴了）。</p><p>特殊的，hugo 支持将文件夹作为 archetype，用的时候要用 <code>hugo new --kind [文件夹]</code> 来指定。</p><h3 id=template>template</h3><blockquote><p><a href=https://gohugo.io/templates/introduction/>官方文档</a></p></blockquote><p>Hugo 使用 Go 的 <a href=https://pkg.go.dev/html/template>html/template</a> 和 <a href=https://pkg.go.dev/text/template>text/template</a> 库作为模板的基础。</p><p>与 Liquid 一样，模板用两个花括号 <code>{{ }}</code> 包裹。如果要去除空格，可以用 <code>{{- -}}</code>，也可以只去除单边空格，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>{{</span><span class=mi>23</span> <span class=o>-</span><span class=p>}}</span> <span class=p>&lt;</span> <span class=p>{{</span><span class=o>-</span> <span class=mi>45</span><span class=p>}}</span>
</span></span><span class=line><span class=cl><span class=c1>//output:
</span></span></span><span class=line><span class=cl><span class=c1>//23&lt;45
</span></span></span></code></pre></div><h4 id=action>Action</h4><p>Action 介绍了一些语句，下面的 pipeline 可以看作 Liquid 里的过滤器（可以简单理解为变量、函数调用etc）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>{{</span><span class=cm>/* a comment */</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>注释</span><span class=err>，</span><span class=nx>执行时会忽略</span><span class=err>。</span><span class=nx>可以多行</span><span class=err>。</span><span class=nx>注释不能嵌套</span><span class=err>，</span><span class=nx>并且必须紧贴分界符始止</span><span class=err>，</span><span class=nx>就像这里表示的一样</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=nx>pipeline</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>pipeline的值的默认文本表示会被拷贝到输出里</span><span class=err>。</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=k>if</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>如果pipeline的值为empty</span><span class=err>，</span><span class=nx>不产生输出</span><span class=err>，</span><span class=nx>否则输出T1执行结果</span><span class=err>。</span><span class=nx>不改变dot的值</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    <span class=nx>Empty值包括false</span><span class=err>、</span><span class=mi>0</span><span class=err>、</span><span class=nx>任意nil指针或者nil接口</span><span class=err>，</span><span class=nx>任意长度为0的数组</span><span class=err>、</span><span class=nx>切片</span><span class=err>、</span><span class=nx>字典</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=k>if</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=k>else</span><span class=p>}}</span> <span class=nx>T0</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>如果pipeline的值为empty</span><span class=err>，</span><span class=nx>输出T0执行结果</span><span class=err>，</span><span class=nx>否则输出T1执行结果</span><span class=err>。</span><span class=nx>不改变dot的值</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=k>if</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=k>else</span> <span class=k>if</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T0</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>用于简化if</span><span class=o>-</span><span class=nx>else链条</span><span class=err>，</span><span class=k>else</span> <span class=nx>action可以直接包含另一个if</span><span class=err>；</span><span class=nx>等价于</span><span class=err>：</span>
</span></span><span class=line><span class=cl>        <span class=p>{{</span><span class=k>if</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=k>else</span><span class=p>}}{{</span><span class=k>if</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T0</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=k>range</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>pipeline的值必须是数组</span><span class=err>、</span><span class=nx>切片</span><span class=err>、</span><span class=nx>字典或者通道</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    <span class=nx>如果pipeline的值其长度为0</span><span class=err>，</span><span class=nx>不会有任何输出</span><span class=err>；</span>
</span></span><span class=line><span class=cl>    <span class=nx>否则dot遍历数组</span><span class=err>、</span><span class=nx>切片</span><span class=err>、</span><span class=nx>字典或者通道的每一个成员元素并执行T1</span><span class=err>；</span>
</span></span><span class=line><span class=cl>    <span class=nx>如果pipeline的值为字典</span><span class=err>，</span><span class=nx>且键可排序的基本类型</span><span class=err>，</span><span class=nx>元素也会按键的顺序排序</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=k>range</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=k>else</span><span class=p>}}</span> <span class=nx>T0</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>pipeline的值必须是数组</span><span class=err>、</span><span class=nx>切片</span><span class=err>、</span><span class=nx>字典或者通道</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    <span class=nx>如果pipeline的值其长度为0</span><span class=err>，</span><span class=nx>不改变dot的值并执行T0</span><span class=err>；</span><span class=nx>否则dot会遍历其中的元素并执行T1</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=k>break</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>提前结束</span><span class=p>{{</span><span class=k>range</span> <span class=nx>pipeline</span><span class=p>}}</span><span class=nx>的所有遍历</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=k>continue</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>提前结束</span><span class=p>{{</span><span class=k>range</span> <span class=nx>pipeline</span><span class=p>}}</span><span class=nx>的当次遍历</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=nx>define</span> <span class=s>&#34;name&#34;</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>定义为name的模板</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=nx>template</span> <span class=s>&#34;name&#34;</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>执行名为name的模板</span><span class=err>，</span><span class=nx>提供给模板的参数为nil</span><span class=err>，</span><span class=nx>如模板不存在输出为</span><span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=nx>template</span> <span class=s>&#34;name&#34;</span> <span class=nx>pipeline</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>执行名为name的模板</span><span class=err>，</span><span class=nx>提供给模板的参数为pipeline的值</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=nx>block</span> <span class=s>&#34;name&#34;</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl> <span class=nx>先定义一个名为name的模板</span><span class=err>，</span>
</span></span><span class=line><span class=cl>    <span class=p>{{</span><span class=nx>define</span> <span class=s>&#34;name&#34;</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl> <span class=nx>再将pipeline作为参数</span><span class=err>，</span><span class=nx>执行该模板</span>
</span></span><span class=line><span class=cl>    <span class=p>{{</span><span class=nx>template</span> <span class=s>&#34;name&#34;</span> <span class=nx>pipeline</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=nx>with</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>如果pipeline为empty不产生输出</span><span class=err>，</span><span class=nx>否则将dot设为pipeline的值并执行T1</span><span class=err>。</span><span class=nx>不修改外面的dot</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{{</span><span class=nx>with</span> <span class=nx>pipeline</span><span class=p>}}</span> <span class=nx>T1</span> <span class=p>{{</span><span class=k>else</span><span class=p>}}</span> <span class=nx>T0</span> <span class=p>{{</span><span class=nx>end</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=nx>如果pipeline为empty</span><span class=err>，</span><span class=nx>不改变dot并执行T0</span><span class=err>，</span><span class=nx>否则dot设为pipeline的值并执行T1</span><span class=err>。</span>
</span></span></code></pre></div><h4 id=arguments>Arguments</h4><p>参数代表一个简单的，由下面的某一条表示的值：</p><ul><li>go语法的布尔值、字符串、字符、整数、浮点数、虚数、复数，视为无类型字面常数，字符串不能跨行</li><li>关键字nil，代表一个go的无类型的nil值</li><li>字符&rsquo;.&rsquo;（句点，用时不加单引号），代表dot的值</li><li>变量名，以美元符号起始加上（可为空的）字母和数字构成的字符串，如：$piOver2和$；
执行结果为变量的值，变量参见下面的介绍</li><li>结构体数据的字段名，以句点起始，如：.Field；
执行结果为字段的值，支持链式调用：.Field1.Field2；
字段也可以在变量上使用（包括链式调用）：$x.Field1.Field2；</li><li>字典类型数据的键名；以句点起始，如：.Key；
执行结果是该键在字典中对应的成员元素的值；
键也可以和字段配合做链式调用，深度不限：.Field1.Key1.Field2.Key2；
虽然键也必须是字母和数字构成的标识字符串，但不需要以大写字母起始；
键也可以用于变量（包括链式调用）：$x.key1.key2；</li><li>数据的无参数方法名，以句点为起始，如：.Method；
执行结果为dot调用该方法的返回值，dot.Method()；
该方法必须有1到2个返回值，如果有2个则后一个必须是error接口类型；
如果有2个返回值的方法返回的error非nil，模板执行会中断并返回给调用模板执行者该错误；
方法可和字段、键配合做链式调用，深度不限：.Field1.Key1.Method1.Field2.Key2.Method2；
方法也可以在变量上使用（包括链式调用）：$x.Method1.Field；</li><li>无参数的函数名，如：fun；
执行结果是调用该函数的返回值fun()；对返回值的要求和方法一样；函数和函数名细节参见后面。</li><li>上面某一条的实例加上括弧（用于分组）
执行结果可以访问其字段或者键对应的值：
print (.F1 arg1) (.F2 arg2)
(.StructValuedMethod &ldquo;arg&rdquo;).Field</li></ul><h4 id=pipeline>Pipeline</h4><p>Pipeline是一个（可能是链状的）command序列。Command可以是一个简单值（argument）或者对函数或者方法的（可以有多个参数的）调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>Argument</span>
</span></span><span class=line><span class=cl>    <span class=nx>执行结果是argument的执行结果</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=nx>Method</span> <span class=p>[</span><span class=nx>Argument</span><span class=o>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>方法可以独立调用或者位于链式调用的末端</span><span class=err>，</span><span class=nx>不同于链式调用中间的方法</span><span class=err>，</span><span class=nx>可以使用参数</span><span class=err>；</span>
</span></span><span class=line><span class=cl>    <span class=nx>执行结果是使用给出的参数调用该方法的返回值</span><span class=err>：</span><span class=nx>dot</span><span class=p>.</span><span class=nf>Method</span><span class=p>(</span><span class=nx>Argument1</span><span class=p>,</span> <span class=nx>etc</span><span class=p>.)</span><span class=err>；</span>
</span></span><span class=line><span class=cl><span class=nx>functionName</span> <span class=p>[</span><span class=nx>Argument</span><span class=o>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>执行结果是使用给定的参数调用函数名指定的函数的返回值</span><span class=err>：</span><span class=nf>function</span><span class=p>(</span><span class=nx>Argument1</span><span class=p>,</span> <span class=nx>etc</span><span class=p>.)</span><span class=err>；</span>
</span></span></code></pre></div><p>pipeline可以链式执行，用管道符 <code>|</code> 隔开（与 Liquid 一样）在一个链式的pipeline里，每个command的结果都作为下一个command的最后一个参数。pipeline最后一个command的输出作为整个管道执行的结果。</p><h4 id=variables>Variables</h4><p>Action里可以初始化一个变量来捕获管道的执行结果。变量无论是定义还是使用时都要在前面加 <code>$</code>。变量初始化语法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>$</span><span class=nx>variable</span> <span class=o>:=</span> <span class=nx>pipeline</span>
</span></span></code></pre></div><p>变量可以重新赋值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>$</span><span class=nx>variable</span> <span class=p>=</span> <span class=nx>pipeline</span>
</span></span></code></pre></div><p>如果"range" action初始化了1个变量，该变量设置为迭代器的每一个成员元素，如果初始化了逗号分隔的2个变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>range</span> <span class=err>$</span><span class=nx>index</span><span class=p>,</span> <span class=err>$</span><span class=nx>element</span> <span class=o>:=</span> <span class=nx>pipeline</span>
</span></span></code></pre></div><p>这时，$index和$element分别设置为数组/切片的索引或者字典的键，以及对应的成员元素。注意这和go range从句只有一个参数时设置为索引/键不同！</p><p>一个变量的作用域只到声明它的控制结构（&ldquo;if&rdquo;、&ldquo;with&rdquo;、&ldquo;range&rdquo;）的"end"为止，如果不是在控制结构里声明会直到模板结束为止。子模板的调用不会从调用它的位置（作用域）继承变量。</p><p>模板开始执行时，$会设置为传递给Execute方法的参数，就是说，dot的初始值。</p><h4 id=functions>Functions</h4><p>预定义的全局函数：</p><pre tabindex=0><code class=language-raw data-lang=raw>and
    函数返回它的第一个empty参数或者最后一个参数；
    就是说&#34;and x y&#34;等价于&#34;if x then y else x&#34;；所有参数都会执行；
or
    返回第一个非empty参数或者最后一个参数；
    亦即&#34;or x y&#34;等价于&#34;if x then x else y&#34;；所有参数都会执行；
not
    返回它的单个参数的布尔值的否定
len
    返回它的参数的整数类型长度
index
    执行结果为第一个参数以剩下的参数为索引/键指向的值；
    如&#34;index x 1 2 3&#34;返回x[1][2][3]的值；每个被索引的主体必须是数组、切片或者字典。
print
    即fmt.Sprint
printf
    即fmt.Sprintf
println
    即fmt.Sprintln
html
    返回其参数文本表示的HTML逸码等价表示。
urlquery
    返回其参数文本表示的可嵌入URL查询的逸码等价表示。
js
    返回其参数文本表示的JavaScript逸码等价表示。
call
    执行结果是调用第一个参数的返回值，该参数必须是函数类型，其余参数作为调用该函数的参数；
    如&#34;call .X.Y 1 2&#34;等价于go语言里的dot.X.Y(1, 2)；
    其中Y是函数类型的字段或者字典的值，或者其他类似情况；
    call的第一个参数的执行结果必须是函数类型的值（和预定义函数如print明显不同）；
    该函数类型值必须有1到2个返回值，如果有2个则后一个必须是error接口类型；
    如果有2个返回值的方法返回的error非nil，模板执行会中断并返回给调用模板执行者该错误；
</code></pre><p>二元比较运算也被定义为函数：</p><pre tabindex=0><code class=language-raw data-lang=raw>eq      如果arg1 == arg2则返回真
ne      如果arg1 != arg2则返回真
lt      如果arg1 &lt; arg2则返回真
le      如果arg1 &lt;= arg2则返回真
gt      如果arg1 &gt; arg2则返回真
ge      如果arg1 &gt;= arg2则返回真
</code></pre><p>为了简化多参数相等检测，eq（只有eq）可以接受2个或更多个参数，它会将第一个参数和其余参数依次比较，返回下式的结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arg1</span><span class=o>==</span><span class=nx>arg2</span> <span class=o>||</span> <span class=nx>arg1</span><span class=o>==</span><span class=nx>arg3</span> <span class=o>||</span> <span class=nx>arg1</span><span class=o>==</span><span class=nx>arg4</span> <span class=o>...</span>
</span></span></code></pre></div><p>（和go的||不一样，不做惰性运算，所有参数都会执行）</p><p>更多 function 请参考 <a href=https://gohugo.io/categories/functions>functions | Hugo</a></p><h4 id=常用语句>常用语句</h4><p>拼接字符串</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//to get a output like $b$c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>$</span><span class=nx>a</span> <span class=o>:=</span> <span class=nx>printf</span> <span class=s>&#34;%s%s&#34;</span> <span class=err>$</span><span class=nx>b</span> <span class=err>$</span><span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=c1>//or
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>$</span><span class=nx>a</span> <span class=o>:=</span> <span class=nx>printf</span> <span class=s>&#34;%s&#34;</span> <span class=err>$</span><span class=nx>c</span> <span class=p>|</span> <span class=nx>printf</span> <span class=s>&#34;%s%s&#34;</span> <span class=err>$</span><span class=nx>b</span> <span class=p>|</span> <span class=nx>printf</span> <span class=s>&#34;%s&#34;</span>
</span></span></code></pre></div></div></div></main><script src=https://tokinx.github.io/lately/lately.min.js></script>
<script>window.Lately&&Lately.init({target:".post-date"})</script></body></html>
<!doctype html><html lang=en><head><meta charset=utf-8><meta name=renderer content="webkit"><meta http-equiv=x-ua-compatible content="IE=Edge,chrome=1"><meta http-equiv=cache-control content="no-siteapp"><meta http-equiv=cache-control content="no-transform"><meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name=description content="(Experimental Design)"><link rel="shortcut icon" href=/images/favicon.png><link rel=apple-touch-icon href=/images/favicon.png><meta name=author content="map[]"><title>Todd's Blog | 数据结构一周速成</title><link rel=stylesheet href=/css/style.css></head><body class="antialiased bg-primary"><div class="flex flex-col sm:flex-row w-full text-white"><div class="sm:fixed w-screen sm:w-4/12 lg:w-3/12 h-screen p-4 bg-secondary bg-cover bg-center" style=background-image:url(/images/bg.png)><div class="flex flex-col justify-center items-center space-y-3 w-full h-full text-center text-white"><div><img class="w-3/12 sm:w-4/12 h-auto aspect-square m-auto rounded-[50%]" src=/images/avatar.png alt=Todd></div><div><a class="text-3xl font-semibold hover:text-accent" href=/>Todd's Blog</a></div><div class=item-center><p class="text-lg font-medium">(Experimental Design)</p></div><div class=pt-5><ul class=text-3xl><li class="inline-block hover:text-accent"><a class=p-3 href=/><i class="fas fa-envelope"></i></a></li><li class="inline-block hover:text-accent"><a class=p-3 href=/about><i class="fab fa-youtube"></i></a></li><li class="inline-block hover:text-accent"><a class=p-3 href=https://github.com/ToddZZF><i class="fab fa-github"></i></a></li><li class="inline-block hover:text-accent"><a class=p-3 href=/about><i class="fab fa-weixin"></i></a></li></ul></div></div></div><div class="flex flex-col w-screen sm:w-8/12 lg:w-6/12 sm:ml-[33.3%] lg:ml-[25%] p-6 md:p-12 bg-primary"><div class="text-3xl font-semibold">数据结构一周速成</div><div class="mb-4 text-base text-[#868E96]">Dec 23, 2021</div><div class="article relative"><blockquote><p>我真不明白为什么同一个课程，同样的内容，就只是因为开课的学院不同就不能互认，搞得我一门课程要学两次🙄</p></blockquote><h2 id=chapter-1>Chapter 1</h2><ol><li>什么是数据结构？<blockquote><p>研究如何在计算机中有效的存储和组织数据的方法</p></blockquote></li><li>如何表示数据结构？<blockquote><p>抽象数据类型（ADT）：是一种描述数据结构的程序设计语言无关的模型。ADT定义为一组数值，和一组相关的操作。</p></blockquote></li><li>什么是算法？<blockquote><p>算法：用于解决一个问题的方法或步骤。</p></blockquote></li><li>算法的属性：<blockquote><ol><li>确定性：它必须是正确的</li><li>可行性：它必须包含一系列具体的步骤，执行的过程无二义性</li><li>有穷性：它必须包含有限的步骤，它必须是可以结束的</li></ol></blockquote></li><li>数据结构 + 算法 = 程序<blockquote><ul><li>数据结构主要研究如何有效的存储和组织应用程序的数据。</li><li>算法主要研究如何对数据进行处理从而解决某个问题</li></ul></blockquote></li></ol><h2 id=chapter-2>Chapter 2</h2><h2 id=chapter-3>Chapter 3</h2><p>增长率分析：分析代价（时间、空间）如何随着输入数据规模大小的增长而增长</p><ul><li>$T(n)$：运行时间关于输入数据规模大小 $n$ 的函数。</li><li>$S(n)$：消耗空间关于输入数据规模大小 $n$ 的函数。</li></ul><hr><p>渐进分析：渐进分析是对T(n)的一种简化分析，该分析保留了 $T(n)$ 的渐进增长趋势</p><ul><li>大 $O$ 分析（上界分析）<blockquote><p>对于非负函数 $T(n)$，如果存在正常数 $c$ 和 $n_0$ 使得当 $n>n_0$ 时 $T(n)\leq cf(n)$，则称 $T(n)$ 属于集合 $O(f(n))$，或记为 $T(n)=O(f(n))$</p></blockquote></li><li>大 $\Omega$ 分析（下界分析）<blockquote><p>对于非负函数 $T(n)$，如果存在正常数 $c$ 和 $n_0$ 使得当 $n>n_0$ 时 $T(n)\geq cg(n)$，则称 $T(n)$ 属于集合 $\Omega(g(n))$，或记为 $T(n)=\Omega(g(n))$</p></blockquote></li><li>大 $\Theta$ 分析<blockquote><p>若 $T(n)=O(h(n))$ 且 $T(n)=\Omega(h(n))$，则称 $T(n)=\Theta(h(n))$</p></blockquote></li></ul><p>$T(n)$ 存在多个上界和下界。</p><hr><p>简化规则：</p><ul><li>常数规则：若 $f(n)=O(kg(n))$，$k>0$，则 $f(n)=O(g(n))$<ul><li>该规则同样适用于 $\Omega$ 和 $\Theta$</li></ul></li><li>加法规则：若 $f_1(n)=O(g_1(n))$ 且 $f_2(n)=O(g_2(n))$，则 $f_1(n)+f_2(n)=O(\max(g_1(n),g_2(n)))$</li><li>乘法规则：若 $f_1(n)=O(g_1(n))$ 且 $f_2(n)=O(g_2(n))$，则 $f_1(n)f_2(n)=O(g_1(n)g_2(n))$</li></ul><hr><p>常见的渐进复杂度：</p><p>$$
O(1)&lt;O(\log\log n)&lt;O(\log n)\
&lt;O(n)&lt;O(n\log n)\
&lt;O(n^2)&lt;\cdots&lt;O(n^k)\
&lt;O(k^n)&lt;O(n!)&lt;O(n^n)
$$</p><h2 id=chapter-4>Chapter 4</h2><h3 id=线性表>线性表</h3><p>概念：</p><ul><li><strong>线性表</strong>：由有限的数据元素构成的序列</li><li><strong>当前位置</strong>：在线性表中插入、删除、或读去数据的位置。当前位置通过**栅栏 (fence)**来定义。栅栏将线性表划分为左右两个部分。插入、删除、读取都在栅栏所在的位置执行（栅栏后面的位置）</li><li>一个包含0个数据元素的线性表称为<strong>空表</strong></li><li>线性表的<strong>长度</strong>指的是线性表中数据元素的个数</li><li>线性表的开始端称为<strong>表头（head）</strong>, 线性表的结束端称为<strong>表尾（tail）</strong></li><li><strong>有序表</strong>：表中的所有的数据元素是根据其数值的大小来进行先后排列</li><li><strong>无序表</strong>：表中数据元素的位置和该元素的数值没有必然联系</li></ul><hr><p>线性表ADT</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> clear() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>const</span> Elem<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>append</span>(<span style=color:#66d9ef>const</span> Elem<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>remove</span>(Elem<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>getValue</span>(Elem<span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>setPos</span>(<span style=color:#66d9ef>int</span> pos) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setStart</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setEnd</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>prev</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>next</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>leftLength</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>rightLength</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><p>线性表的实现：</p><ul><li>数组</li><li>链表</li></ul><table><thead><tr><th style=text-align:center>比较</th><th style=text-align:center>数组</th><th style=text-align:center>链表</th></tr></thead><tbody><tr><td style=text-align:center>插入与删除</td><td style=text-align:center>$\Theta(n)$</td><td style=text-align:center>$\Theta(1)$</td></tr><tr><td style=text-align:center>求前驱和随机访问</td><td style=text-align:center>$\Theta(1)$</td><td style=text-align:center>$\Theta(n)$</td></tr><tr><td style=text-align:center>特点</td><td style=text-align:center>需要提前为数组分配空间</td><td style=text-align:center>消耗的空间随数据元素个数的增长而增长</td></tr><tr><td style=text-align:center>空间<br>$E$ 每个数据元素所占空间大小<br>$P$：每个指针所占空间大小<br>$D$：数组最多能存放的数据元素的个数<br>$n$：当前数据元素的个数</td><td style=text-align:center>$DE$</td><td style=text-align:center>$n(P+E)$</td></tr></tbody></table><h3 id=栈>栈</h3><p>概念：</p><ul><li><strong>栈</strong>：插入、删除只在一端进行的线性表</li><li><strong>LIFO</strong> 性质: Last In, First Out. （后进先出）</li><li><strong>入栈(PUSH)</strong>：插入元素到栈中</li><li><strong>出栈(POP)</strong>：从栈中取出元素</li><li><strong>栈顶(TOP)</strong>：栈中插入、删除的位置</li></ul><hr><p>栈的ADT</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Reinitialize the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> clear() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Push an element onto the top of the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>const</span> Elem<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Remove the element at the top of the stack. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>pop</span>(Elem<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get a copy of the top element in the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>topValue</span>(Elem<span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Return the number of elements in the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>length</span> () <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><p>栈的实现：</p><ul><li>数组</li><li>链表</li></ul><h3 id=队列>队列</h3><p>概念：</p><ul><li><strong>队列</strong>: 插入和删除分别在表的两端进行的线性表</li><li><strong>FIFO</strong> 性质: First in, First Out （先进后出）</li><li>插入: <strong>enqueue（入队）</strong></li><li>删除: <strong>dequeue （出队）</strong></li><li>第一个元素: <strong>front（队头）</strong></li><li>最后一个元素: <strong>rear（队尾）</strong></li></ul><hr><p>队列ADT</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Queue</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> clear() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>enqueue</span>(<span style=color:#66d9ef>const</span> Elem<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dequeue</span>(Elem<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>frontValue</span>(Elem<span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>length</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><p>栈的实现：</p><ul><li>数组</li><li>链表</li></ul><h2 id=chapter-5-二叉树>Chapter 5 二叉树</h2><p>概念：</p><ul><li><p><strong>二叉树</strong>是一个包含有限个结点的集合，有以下两种情况</p><ul><li>空集，<strong>空树</strong></li><li>包含一个称为<strong>树根(root)<strong>的结点，以及两个互不相交的二叉树，它们分别称为</strong>左子树</strong>和<strong>右子树</strong></li></ul></li><li><p>对于树上的每个结点，和它有连边的下层结点称为它的<strong>孩子结点</strong>。在二叉树中，每个结点最多会有两个孩子，最少没有孩子</p></li><li><p>对于二叉树上的每个结点，和它有连边的上层结点称为它的<strong>父亲结点</strong>。二叉树中，除了树根外，每个结点都有一个父亲结点。</p></li><li><p>一个结点的父亲，父亲的父亲，父亲的父亲的父亲，等等都是它的<strong>祖先结点</strong>。反过来，一个结点的孩子，孩子的孩子，孩子的孩子的孩子，等等都是它的<strong>后辈结点</strong></p></li><li><p><strong>叶子结点</strong>：没有孩子结点的结点为叶子结点</p></li><li><p><strong>路径</strong>：一个结点序列 $n_1,n_2,\cdot,n_k$，如果其中的每个结点 $n_i$ 是 $n_{i+1}$ 的父亲（$1\leq i \leq k$），我们就称这个序列是从 $n_1$ 到 $n_k$ 的路径。这条路径的长度等于 $k-1$</p></li><li><p><strong>深度</strong>：一个结点的深度等于从树根到这个结点的路径的长度</p></li><li><p><strong>层次</strong>：根结点为第0层，往下逐个增加。（貌似等于深度）</p></li><li><p><strong>高度</strong>：一棵树的高度等于其中最大结点深度加一</p></li><li><p><strong>满二叉树</strong>：二叉树的每个结点都是叶子或拥有两个孩子的中间结点。</p><ul><li><strong>非空满二叉树中叶子的数目比中间结点多一个</strong>，这个很容易证明：如果只有根结点，则只有一个叶子结点，没有中间结点。每增加两个叶子，则原有的叶子结点会变为中间结点，故叶子始终比中间结点多一个。</li></ul></li><li><p><strong>完全二叉树</strong>: 除了最深的层次，二叉树的所有层次都填满结点，且最深层的叶子结点集中在该层的最左边的位置</p></li></ul><hr><p>二叉树结点ADT</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Template  <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BinNode</span> { 
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> Elem<span style=color:#f92672>&amp;</span> val( ) <span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setVal</span>( <span style=color:#66d9ef>const</span> Elem<span style=color:#f92672>&amp;</span> ) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> BinNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>left</span>( ) <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setLeft</span>( BinNode<span style=color:#f92672>*</span> ) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> BinNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>right</span>( ) <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setRight</span>( BinNode<span style=color:#f92672>*</span> ) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isLeaf</span>( ) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>二叉树的实现：</p><ul><li>基于链接的方式</li><li>基于数组的方式</li></ul><hr><p>哈夫曼编码：</p><ul><li>一种可变长度的编码</li><li>高频字符对应较短的编码</li></ul><p>哈夫曼编码的编码过程需要用到一种称为<strong>哈夫曼树</strong>的满二叉树结构。</p><p>平均编码长度取决于所有叶子的加权路径长度的和</p><p>定理: 对于给定的一组字符以及出现的频率，以它们作为叶子节点构建的满二叉树中，哈夫曼树具有最小的加权路径长度的和。在预先知道每个字符的出现的频率的前提下，哈夫曼编码是具有最小的平均编码长度的非前缀编码。</p><p>构建哈夫曼编码的算法：</p><h2 id=chapter-6-一般树>Chapter 6 一般树</h2><p>概念：</p><ul><li><strong>树</strong> T 是一个包含一个或多个节点的有限集合，其中有一个称为 <strong>树根</strong> 的节点r，余下的节点(T –{r}) 可以被划分为k个( k≥0)互不想交的子集 T1, T2, &mldr;, Tk, 每个子集都是一棵树,它们的树根 r1, r2, &mldr;, rk,都是r的孩子</li><li><strong>森林</strong>：是包含有一棵或多棵树的集合。</li></ul><hr><p>树结点 ADT</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// General tree node ADT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GTNode</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    GTNode(<span style=color:#66d9ef>const</span> Elem<span style=color:#f92672>&amp;</span>); <span style=color:#75715e>// Constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>GTNode();           <span style=color:#75715e>// Destructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Elem <span style=color:#a6e22e>value</span>();        <span style=color:#75715e>// Return value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isLeaf</span>();       <span style=color:#75715e>// TRUE if is a leaf
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    GTNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>parent</span>();    <span style=color:#75715e>// Return parent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    GTNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>leftmost_child</span>(); <span style=color:#75715e>// First child
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    GTNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>right_sibling</span>();  <span style=color:#75715e>// Right sibling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setValue</span>(Elem<span style=color:#f92672>&amp;</span>);     <span style=color:#75715e>// Set value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//insert first child
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert_first</span>(GTNode<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;*</span> n);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//insert right sibling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert_next</span>(GTNode<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;*</span> n);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove_first</span>(); <span style=color:#75715e>// Remove first child
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove_next</span>();  <span style=color:#75715e>// Remove sibling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>树 ADT</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// General tree ADT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GenTree</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    GenTree();               <span style=color:#75715e>// Constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>GenTree();              <span style=color:#75715e>// Destructor  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span>();            <span style=color:#75715e>// Send nodes to free store
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    GTNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>root</span>();          <span style=color:#75715e>// Return the root
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>(GTNode<span style=color:#f92672>*</span>); <span style=color:#75715e>// Print function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h2 id=chapter7-内部排序>Chapter7 内部排序</h2><p>概念：</p><ul><li><p>排序：给定一个序列的记录 $R_1 , R_2 , … , R_n$，它们对应的关键字依次是 $k_1 , k_2 ,… , k_n$ , 调整记录在序列中的次序得到新的记录序列 $R_{s1},R_{s2},…,R_{sn}$，使得记录的关键字满足以下性质： $k_{s1} ≤ k_{s2} ≤ …≤ k_{sn}$.</p></li><li><p>稳定的排序算法：排序的过程不会改变具有相等关键字的记录的相对先后次序。</p></li><li><p>内部排序：指的是待排序记录存放在计算机随机存储器中进行的排序过程。</p></li><li><p>外部排序：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录, 在排序过程中尚需对外存进行访问的排序过程。</p></li></ul><hr><h3 id=插入排序>插入排序</h3><p>记忆：像洗牌，将每张牌插入到合适的位置</p><p>实现：在第i次迭代，将第i个元素与前面 i-1 个元素进行比较，使其插入到前面适当的位置(1 &lt;= i &lt;= n-1)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> inssort(Elem A[], <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>i; (j<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>              (A[j]<span style=color:#f92672>&lt;</span> A[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])); j<span style=color:#f92672>--</span>)<span style=color:#75715e>//插入第i个元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            swap(A, j, j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代价分析：最好 $\Theta(n)$，最坏 $\Theta(n^2)$，平均 $\Theta(n^2)$</p><p>插入排序是一种稳定的排序算法。</p><h3 id=冒泡排序>冒泡排序</h3><p>实现：由后到前，相邻两个元素比较，逆序则交换。一次冒泡过程结束后，最小的元素会到达最前面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> bubsort(Elem A[], <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>&gt;</span>i; j<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (A[j]<span style=color:#f92672>&lt;</span> A[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                swap(A, j, j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代价分析：最好、最坏、平均都是 $\Theta(n^2)$。</p><p>冒泡排序算法是一种稳定的排序算法。</p><h3 id=选择排序>选择排序</h3><p>实现：第i趟排序就是从位置属于[i,n-1]的元素中，选出最小的元素，并将其和第i位置上的元素交换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> selsort(Elem A[], <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>++</span>) { 
</span></span><span style=display:flex><span>   <span style=color:#75715e>// select the minial values in [i,n-1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> lowindex <span style=color:#f92672>=</span> i; <span style=color:#75715e>// lowindex指向较小的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>&gt;</span>i; j<span style=color:#f92672>--</span>) <span style=color:#75715e>// Find least
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (A[j]<span style=color:#f92672>&lt;</span> A[lowindex])
</span></span><span style=display:flex><span>                lowindex <span style=color:#f92672>=</span> j; 
</span></span><span style=display:flex><span>        swap(A, i, lowindex); <span style=color:#75715e>// Put it in place
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代价分析：最好、最坏、平均都是 $\Theta(n^2)$。</p><p>选择排序是一种不稳定的排序算法。</p><h3 id=希尔排序shellsort>希尔排序（Shellsort）</h3><p>思路（分组）：每隔一定间距取一个元素放入同一组，将所有元素分成多组，并在组内进行插入排序。然后减小间距重新分组，重新排序。最后当间距为 1 时，退化为一般的插入排序。</p><p>分析：由于最后一次排序是一般的插入排序，所以这种方法是可行的。而前面几次排序可以使元素一次性移动多格，所以速度会快。</p><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Modified version of Insertion Sort
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> inssort2(Elem A[], <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> from, <span style=color:#66d9ef>int</span> incr) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span> from <span style=color:#f92672>+</span> incr; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>+=</span>incr)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>i; (j<span style=color:#f92672>&gt;</span> from <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>           A[j]<span style=color:#f92672>&lt;</span> A[j<span style=color:#f92672>-</span>incr]); j<span style=color:#f92672>-=</span>incr)
</span></span><span style=display:flex><span>       swap(A, j, j<span style=color:#f92672>-</span>incr);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> shellsort(Elem A[], <span style=color:#66d9ef>int</span> n) { <span style=color:#75715e>// Shellsort
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>; i<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>/=</span><span style=color:#ae81ff>2</span>)  <span style=color:#75715e>// For each incr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; j<span style=color:#f92672>&lt;</span>i; j<span style=color:#f92672>++</span>)   <span style=color:#75715e>// Sort sublists
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      inssort2<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;</span>(A, n, j, i);   
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当增量序列为 $∆[k] = 2^{t-k+1}-1$ 时，算法复杂度为 $O(n^{3/2})$。 其中 t 是排序的趟数，$1\leq k\leq t$。例如（15，7，3，1）。<a href=https://zhuanlan.zhihu.com/p/73726253>证明过程</a></p><p>希尔排序是一种不稳定排序。</p><h3 id=快速排序>快速排序</h3><p>思想（分而治之）：选择一个记录的值作为支点（pivot）。将小于支点的记录安排在支点的左侧，将大于等于支点的记录安排在支点的右侧。从而将原序列划分为左右两个子序列。然后在子序列中重复该过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> qsort(Elem A[], <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&lt;=</span> i) <span style=color:#66d9ef>return</span>;     <span style=color:#75715e>// List too small
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> findpivot(A, i, j);
</span></span><span style=display:flex><span>  swap(A, pivot, j);  <span style=color:#75715e>// Put pivot at end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> partition<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;</span>(A, i, j, A[j]);
</span></span><span style=display:flex><span>  swap(A, k, j);         <span style=color:#75715e>// Put pivot in place
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  qsort<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;</span>(A, i, k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  qsort<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;</span>(A, k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, j);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> findpivot(Elem A[], <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j)
</span></span><span style=display:flex><span>  { <span style=color:#66d9ef>return</span> (i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> partition(Elem A[], <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r,Elem<span style=color:#f92672>&amp;</span> pivot) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span> {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (A[l] <span style=color:#f92672>&lt;</span> pivot) l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ((r <span style=color:#f92672>&gt;</span> l) <span style=color:#f92672>&amp;&amp;</span> A[r] <span style=color:#f92672>&gt;=</span>pivot)
</span></span><span style=display:flex><span>       r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    swap(A, l, r); <span style=color:#75715e>// Swap out-of-place values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  } <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r); <span style=color:#75715e>// Stop when they cross
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> l;       <span style=color:#75715e>// Return first pos on right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>代价分析：类似二叉树（层数代表次数）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e>#best: 每次都均匀分成两段</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   --------
</span></span><span style=display:flex><span>   ---- ----
</span></span><span style=display:flex><span>  -- -- -- --
</span></span><span style=display:flex><span>- - - - - - - -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#worst</span>
</span></span><span style=display:flex><span>--------
</span></span><span style=display:flex><span>- -------
</span></span><span style=display:flex><span>  - ------
</span></span><span style=display:flex><span>    - -----
</span></span><span style=display:flex><span>      - ----
</span></span><span style=display:flex><span>        - ---
</span></span><span style=display:flex><span>          - --
</span></span><span style=display:flex><span>            - -
</span></span></code></pre></div><p>平均情况：</p><p>$$
T(n)=cn+\frac{1}{n} \sum_{k=0}^{n-1} (T(k)+T(n-1-k))=\Theta(n \log n)
$$</p><p>改进方法：</p><ul><li>选取更好的支点<ul><li>选择以下三个记录中的中间值作为支点 : 序列的第一个，中间，最后一个记录</li></ul></li><li>采用非递归的算法来实现快速排序</li></ul><h3 id=归并排序>归并排序</h3><p>思路（分而治之）：将一个序列划分为两个长度相等的子序列，然后递归的对每个子序列进行归并排序。将排好序的两个子序列归并为一个有序的序列。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elem</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> mergesort(Elem A[], Elem temp[],
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (left<span style=color:#f92672>+</span>right)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>==</span> right) <span style=color:#66d9ef>return</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mergesort<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;</span>(A, temp, left, mid);
</span></span><span style=display:flex><span>  mergesort<span style=color:#f92672>&lt;</span>Elem<span style=color:#f92672>&gt;</span>(A, temp, mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, right);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>left; i<span style=color:#f92672>&lt;=</span>right; i<span style=color:#f92672>++</span>) <span style=color:#75715e>// Copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    temp[i] <span style=color:#f92672>=</span> A[i];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i1 <span style=color:#f92672>=</span> left; <span style=color:#66d9ef>int</span> i2 <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> curr<span style=color:#f92672>=</span>left; curr<span style=color:#f92672>&lt;=</span>right; curr<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (i1 <span style=color:#f92672>==</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)      <span style=color:#75715e>// Left exhausted
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      A[curr] <span style=color:#f92672>=</span> temp[i2<span style=color:#f92672>++</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (i2 <span style=color:#f92672>&gt;</span> right)  <span style=color:#75715e>// Right exhausted
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      A[curr] <span style=color:#f92672>=</span> temp[i1<span style=color:#f92672>++</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (temp[i1] <span style=color:#f92672>&lt;</span> temp[i2])
</span></span><span style=display:flex><span>      A[curr] <span style=color:#f92672>=</span> temp[i1<span style=color:#f92672>++</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> A[curr] <span style=color:#f92672>=</span> temp[i2<span style=color:#f92672>++</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代价分析：最好、最坏、平均都是 $\Theta(n \log n)$。</p><h3 id=堆排序>堆排序</h3><p>思路：堆顶结点的值总保持是最大值/最小值，故每次取堆顶，然后用剩下元素建堆，再重复该过程。</p><p>代价分析：建堆 $\Theta(n)$，移除最大值 $\Theta(\log n)$，n 次移除最大值 $\Theta(n\log n)$。故总代价为 $\Theta(n\log n)$</p><p>详细分析见我的博客。</p><h3 id=箱排序和基数排序>箱排序和基数排序</h3><p>箱排序（Binsort）：设置若干个箱子，依次扫描待排序的记录 R[0]，R[1]，…，R[n-1]，把关键字等于 k 的记录分配到第 k 个箱子里，然后按序号依次将各非空的箱子中的记录收集起来。</p><p>示例：3，8，1，8，4，放入下面这组箱子，允许多个记录具有相同的关键字（链表）</p><pre tabindex=0><code class=language-raw data-lang=raw>                 8
---------------------
| |1| |3|4| | | |8| |
---------------------
 0 1 2 3 4 5 6 7 8 9
</code></pre><p>然后从左到右逐个扫描箱子，如果有关键字，则取出：1，3，4，8，8</p><p>代价：对于Key取值范围较大的记录进行Binsort，较为低效。放进箱子需要 $n$ 次，然后要扫描所有箱子，所以代价为：$\Theta(n + m)$，$n$ 是记录个数，$m$ 是箱子个数。</p><p>箱排序是稳定的。</p><hr><p>基数排序（Radix Sort）：对箱排序的改进。将任何一个 $r$ 进制的整数 key $\overline{K_{d-1}K_{d-2}\cdots K_0}$ 看成是由 $d$ 个分量组成，$K_{d-1},K_{d-2},\cdots ,K_0$，对每个分量进行箱排序。</p><p>示例：十进制，27，91，1，97，17，23，84，28，72，5，67，25，先按个位放入箱子</p><pre tabindex=0><code class=language-raw data-lang=raw>0
1-&gt;91-&gt;1
2-&gt;72
3-&gt;23
4-&gt;84
5-&gt;5-&gt;25
6
7-&gt;27-&gt;97-&gt;17-&gt;67
8-&gt;28
9
</code></pre><p>然后取出来：91，1，72，23，84，5，25，27，97，17，67，28</p><p>再按十位放入箱子</p><pre tabindex=0><code class=language-raw data-lang=raw>0-&gt;1-&gt;5
1-&gt;17
2-&gt;23-&gt;25-&gt;27-&gt;28
3
4
5
6-&gt;67
7-&gt;72
8-&gt;84
9-&gt;91-&gt;97
</code></pre><p>再取出来：1，5，17，23，25，27，28，67，72，84，01，07</p><p>代价：每次放入全部 $n$ 个元素，$r$ 进制则需要扫描 $r$ 个箱子，需要重复位数 $d$ 次。故代价为 $\Theta((n+r)d)$，$n$ 是记录个数，$d$ 是Key的位数，$r$ 是基数。</p><p>基数排序是稳定的排序。</p><h3 id=排序算法性能比较>排序算法性能比较</h3><h3 id=排序算法的理论下界>排序算法的理论下界</h3><p>排序问题的上界是 $n \log n$。因为我们能找到的最好排序算法的平均情况下的算法复杂度是 $O(n \log n)$</p><p>我们将证明排序问题的理论下界也是 $n \log n$。</p><p>我们考虑排序的决策树（每个结点处进行一次比较，根据结果分为左右子树），其叶子数量为 $N!$（因为有 $N!$ 种可能结果），深度为 $d$ 的二叉树最多有 $2^{d+1}-1$ 个叶子，那反过来，$N!$ 个叶子的二叉树的深度至少是 $\lceil \log(N!+1) \rceil-1$，即 $\Omega (\log n!)=\Omega(n \log n)$</p><p>$$
斯特林公式：n!\approx \sqrt{2\pi n} \left( \frac{n}{e} \right)^n
$$</p><p>所以排序所需的时间 $T=\Omega(n \log n)$</p><h2 id=chapter9-查找>Chapter9 查找</h2><p>定义：</p><h2 id=chapter10-索引>Chapter10 索引</h2><p>原文件在硬盘中太大，不方便直接查找，所以建立索引文件。</p><p>索引文件：</p><ol><li>索引文件中记录了关键字和对应的数据记录存储在硬盘中的位置</li><li>索引文件比数据记录小的多，查找时被加载到内存中进行查找</li><li>针对不同关键字的索引文件，支持多关键字查找</li></ol><h3 id=线性索引>线性索引</h3><p>线性索引: 索引文件组织成二元组(关键字, 指向记录的指针) 的序列。</p><p>如果索引太大无法加载到内存，则建立二级索引。分段，取每一段的最小值重新构成序列。</p><p>不足之处：插入和删除操作会导致大量数据移动 $\Theta(n)$</p><h3 id=二叉查找树-bst>二叉查找树 BST</h3><p>二叉查找数：对每个结点，左子结点比它小，右子结点比它大</p><p>二叉平衡树：左右子树的高度差不超过1</p><p>二叉平衡树查找复杂度 $\Theta(\log n)$</p><p>不足之处：让BST保持平衡需要付出较高的代价，插入一个结点需要调整大量结点。</p><h3 id=2-3树>2-3树</h3><p>2-3树的性质：</p><h3 id=b树>B+树</h3><h2 id=chapter11-图>Chapter11 图</h2><h3 id=概念>概念</h3><p>图的定义：$G=(V,E)$</p><ul><li><p>$V$ Vertex 顶点的非空有限集合（也就是一组顶点）</p></li><li><p>$E$ 无序集 $V&V$ 的子集，其元素是图的弧（Arc）（也就是顶点对）</p></li><li><p>弧：表示两个顶点 $v$ 和 $w$ 之间存在一个关系，用顶点偶对 $&lt;v,w>$ 表示</p></li><li><p>有向图：若图G的关系集合E(G)中，顶点偶对&lt;v,w>的v和w之间是有序的，称图G是有向图。</p><ul><li>称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) ，就像向量。</li></ul></li><li><p>无向图：若图G的关系集合E(G)中，顶点偶对&lt;v,w>的v和w之间是无序的，称图G是无向图。</p></li><li><p>权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。</p></li><li><p>路径：顶点序列 $v_1, v_2, …, v_n$ 被称为长度为 n-1的路径，其中 $v_i$ 到 $v_{i+1}$ $(1 ≤ i &lt; n)$ 之间有连边</p></li><li><p>简单路径：路径中的所有顶点都是唯一的</p></li><li><p>环：长度不小于3的首尾相接的路径</p></li><li><p>简单环：除了第一个和最后一个顶点外，其余顶点都唯一的环是简单环</p></li><li><p>连通图 : 图中任何两个顶点之间都存在路径</p></li><li><p>连通分量：图中的极大连通子图（也就是让点形成的连通图最大）</p></li></ul><p>参考：<a href=https://zhuanlan.zhihu.com/p/35864291>图的基本概念和遍历</a></p><h3 id=图的实现>图的实现</h3><h3 id=图的遍历>图的遍历</h3><p>图的遍历：按照某特定顺序，依次访问图中的顶点，且每个顶点只访问一次。</p><ol><li>深度优先搜索(Depth First Search ,DFS)</li><li>广度优先搜索(Breadth First Search, BFS)</li><li>拓扑排序(Topological Sort )</li></ol><h3 id=图的最短路径>图的最短路径</h3><p>常见求解问题:</p><ol><li>单源最短路径: 求从某个顶点S到图中其他顶点的最短路径</li><li>所有点对最短路径: 求任意两个顶点之间的最短路径</li></ol><p>定义：</p><ul><li>d(A, B) 从A到B的最短距离（最短路径长度）</li><li>w(A, B) 是A到B的连边的权重。如果A到B没有连边，则定义 w(A, B) = ∞.</li></ul><hr><p>单源最短路径：Dijkstra算法</p><hr><p>所有点对最短路径：Floyd算法</p><h3 id=最小代价生成树>最小代价生成树</h3><p>最小代价生成树（Minimum-Cost Spanning Tree ，MST) 问题：</p><ul><li>输入: 一个无向连通图 G</li><li>输出: 满足以下要求的 G 的子图<ol><li>该子图是包含所有顶点的连通图</li><li>该子图具有最小的代价（代价指的是图中的所有连边上的权重的总和）</li></ol></li></ul><p>有两种算法：</p><ul><li>Prim 最小代价生成树算法</li><li>Kruskal 最小代价生成树算法</li></ul></div><hr class=my-6><footer class="text-base text-[#868E96]"><small>&copy; 0001 - 2022 <a href=https://toddzzf.github.io class="underline hover:text-accent">Todd</a>. All rights reserved.
Powered by <a href=https://gohugo.io/ class="underline hover:text-accent">Hugo</a> & <a href=https://github.com/vszhub/not-pure-poole class="underline hover:text-accent">Not Pure Poole</a>.</small></footer></div></div></body><link href=https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.3/css/all.min.css rel=stylesheet><link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css rel=stylesheet><script src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js></script>
<script>hljs.highlightAll()</script></html>
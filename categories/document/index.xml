<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>document on Todd's Blog</title><link>http://example.org/categories/document/</link><description>Recent content in document on Todd's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 12 May 2020 18:01:00 +0800</lastBuildDate><atom:link href="http://example.org/categories/document/index.xml" rel="self" type="application/rss+xml"/><item><title>我的Android必备应用</title><link>http://example.org/posts/2020/2020-05-12-android-app/</link><pubDate>Tue, 12 May 2020 18:01:00 +0800</pubDate><guid>http://example.org/posts/2020/2020-05-12-android-app/</guid><description>&lt;blockquote>
&lt;p>这几天翻出了我的小米5s与红米note4x，打算充分利用这些设备的余温，于是刷了一下机。不得不说现在刷机还是蛮简单的，一点都不麻烦。&lt;/p>
&lt;/blockquote></description></item><item><title>操作系统总结</title><link>http://example.org/posts/2019/2019-10-28-summary-of-os/</link><pubDate>Mon, 28 Oct 2019 23:00:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-10-28-summary-of-os/</guid><description>现代操作系统总结
书写规范 定义与定理的格式如下：
【定义】操作系统：……
【定理】操作系统定理：……
若需要在下面写注释，则用引用的形式：
注：……
列表一律用有序表，而不是无序表，并且每一项若有标题，则标题粗体
凡是有一定”步骤“的算法，均使用类 c 写：
【方法】：
if(){ } //如果 while(){ }//循环 课程结构 资源管理的角度：
硬件资源 处理器 存储器 I/O 设备 软件资源 文件 软件工程的角度：
进程管理子系统 存储管理子系统 I/O 设备管理子系统 文件管理子系统 对每个子系统：
基本功能 高效运行 一些常识 单位换算 B, Byte 字节
KB, Kilobyte 千字节 = $2^{10}$ B（ $1024$ B）
MB, Megabyte 兆字节 = $2^{10}$ KB
GB, Gigabyte 千兆字节 = $2^{10}$ MB
TB, Terabyte 太兆字节 = $2^{10}$ GB
系统启动的过程 加电或复位 BIOS（Basic I/O System） Boot Loader 操作系统初始化 第一章 引论 一些概念：</description></item><item><title>数据库总结</title><link>http://example.org/posts/2019/2019-10-22-summary-of-database/</link><pubDate>Tue, 22 Oct 2019 21:23:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-10-22-summary-of-database/</guid><description>数据库，从删库到跑路。
书写规范 定义与定理的格式如下：
【定义】数据库：……
【定理】数据库定理：……
若需要在下面写注释，则用引用的形式：
注：……
列表一律用有序表，而不是无序表，并且每一项若有标题，则标题粗体
凡是有一定”步骤“的解题方法，均使用类 Python 写：
【方法】：
if …… #如果 while …… #循环……
# 第一章 数据和数据管理 ## 基本概念 【定义】**数据**：一切能被计算机存储和梳理，反应客观实体信息的物理符号，是信息的载体 【定义】**信息**：有一定含义、经加工过、对决策有价值的数据。特点： 1. 可感知 2. 可理解 3. 可传递 4. 可存储 &amp;gt; 数据与信息的联系： &amp;gt; &amp;gt; 1. 数据是信息的载体，信息是数据的内涵； &amp;gt; 2. 同一信息有不同数据表现形式，同一数据也有不同解释 【定义】**数据处理**：将数据转换成信息的过程。分类： 1. 集中处理：数据存储和处理由一台计算机完成 2. 分散处理：数据分块存储在多台计算机上，它们之间没有联系，处理由单台计算机完成 3. 分布处理：数据分块存储在多台计算机上，可以和其他计算机一起处理 其他分类方式： 1. 联机/脱机 2. 批处理/分时/实时 3. 单道/多道/交互式 ## 数据管理技术的发展 【定义】**数据管理**：对数据的组织、编目、定位、存储、检索和维护等 &amp;gt; 数据管理是数据处理的基本环节 &amp;gt; &amp;gt; 数据管理是数据库系统研究内容的核心 1. 人工管理阶段：磁带/汇编/批处理 1. 特点： 1. 数据不保存在计算机中 2.</description></item><item><title>模电实验总结</title><link>http://example.org/posts/2019/2019-10-19-analog-electronics-experiment/</link><pubDate>Fri, 18 Oct 2019 18:22:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-10-19-analog-electronics-experiment/</guid><description>跪求模电实验放过我இ௰இ
吐槽 模电实验是个坑，调试半天蛋真疼。（原谅我的粗言秽语……）
仪器使用 接地的目的：
提供基准零点位，保证电路正常稳定工作 防止外界磁场外泄，同时防止内部电磁场外泄 机壳屏蔽需要 避免触电事故 共地：
对于不平衡的仪器（单端输入，单端输出），必须将仪器的地与电路的地接在一起，防止引入干扰，避免产生较大误差 模拟万用表 技术指标：
直流电压档的输入阻抗：20KΩ/V 注意事项：
测量电阻时，每次更换量程都有调零（两表笔短接） 数字万用表 技术指标：
直流电压档的输入阻抗：10MΩ 交流电压档的输入阻抗：2MΩ，频率范围：20~5k（实验室）或45~1kHz 直流稳压电源 函数信号发生器 示波器 自动设置（Autoset）不适用：输入信号频率小于 20Hz，幅度小于 30mV。此时要设置边缘触发，并设置频率低的通道为触发信号源，再调节 采样速率（TIME/DIV）、垂直灵敏度（VULTS/DIV）、触发电平（LEVEL）
耦合：链接：Coupling AC/DC/GND-示波器耦合差別在哪
接地耦合：将输入接地，用于一开始将波形调到中间 直流耦合：含交直流分量 交流耦合：仅含交流分量 注意事项：
示波器要与电路接地（即只能测对地电压） 光标测量时要选择被测信号的通道作为信源 交流毫伏表 只能测交流，不能测直流
注意事项：
交流毫伏表要与电路接地（即只能测对地电压） 失真度测量仪 元器件的识别、测量、检测 电阻 R 色环电阻的识别：
先找起始端： 误差色环离其他色环较远 有黑、橙、黄、白的为起始端 按各颜色对应数字读出阻值。无论是四环还是五环，最后面两个都是 倍数和误差，前面的是有效数字。 口诀：棕一红二橙是三，四黄五绿六为蓝，七紫八灰九对白，黑是零，金五银十表误差。 电阻值的测量：
不允许双手抓着电阻两端测量，会将人体电阻并联 电阻的最大功率：若无标识，为 $\dfrac{1}{4}\rm{ W}$
电容 C 瓷片电容的识别：104，前两位为有效数字，后一位为倍数，单位为 pF，即 $10 \times 10^4 \rm{pF} = 0.1 \rm{uF}$。耐压值若无标注，则为 63V
电解电容的识别：
容值：一般有表明，直接读即可。 极性：长正短负。若引脚一样长，可根据“正时漏电电阻大，反接时漏电电阻小”，用模拟万用表测（注意黑笔为正，红笔为负） 电容的测量：插到数字万用表的 Cx 插座内，然后用电容档</description></item><item><title>vim 入门</title><link>http://example.org/posts/2019/2019-10-18-vim-tutorial/</link><pubDate>Fri, 18 Oct 2019 16:21:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-10-18-vim-tutorial/</guid><description>vim 从启动到退出
前言 虽然编辑文本文件用 nano 足矣，但是写程序的时候总是不那么方便，所以 vim 还是要学一下的~ 在正式学习之前，先说说如何退出vim：&amp;lt;Esc&amp;gt; + 输入:wq + &amp;lt;Enter&amp;gt;，很多人第一次用 vim 时完全不知道如何退出，所以你去搜索 vim，大部分人都是问这个问题 ~
三种模式 和 Jupyter Notebook 类似，vim 也有多种模式：
基本模式（Command mode）
刚启动时就进入命令模式，此时可以输入基本命令。
输入模式（Insert mode）
可以编辑文字
命令模式（Last line mode）
可以输入比命令模式更多的命令
浏览模式（Visual mode）
可以看（暂时还不知道这是干什么的）
三种模式的切换方法如下：
基本模式 在基本模式下可以做一些基本的操作，比如 移动光标、复制粘贴、搜索替换。
移动光标 除了 ↑↓←→外，没有方向键的键盘也可以用 h左、j下、k下、l右 来移动光标。
除了 PgUp 和 PhDn 外，也可以用 Ctrl+f（front，上一页）、Ctrl+b（below，下一页）来翻页。
除了 Home 和 End 外，也可以用 0（最前面）、$（最后面）来让光标移动到行的前面或后面。
如果想一次移动多行，直接输入数字就好。
如果想移动到第n行，可以用 n+G。
想移动到最后一行，可以用 G。
复制粘贴 不得不说没了鼠标，复制这活可不好干。vim 只能这样复制：
复制光标所在行：yy 复制光标到下面n行：nyy 复制光标到行首：y0 复制光标到行末：y$ 有一些不常用，就不列了 至于粘贴，有两种：</description></item><item><title>在Linux上学习C语言</title><link>http://example.org/posts/2019/2019-10-19-learn-c-with-linux/</link><pubDate>Fri, 18 Oct 2019 14:24:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-10-19-learn-c-with-linux/</guid><description>学了 C++ 的我表示不会 C
前言 在 Linux 上学习 C，更具体来讲，在命令行学习 C 有很多好处，比如说：
能了解从写代码到执行这一过程中，计算机到底做了什么事？ 能了解代码是如何与操作系统，操作系统是如何与硬件沟通的？ 总之，对于我这个电子科学的学生来讲，学好 C 比学好 C++ 更加有用。而在 Linux 上学习能帮助我深入理解内部的原理。我决定立个 Flag，在3 个月内学习下面的内容：
C 语言入门 常量、变量和表达式 函数 分支语句 循环语句 结构体 数组 编码风格 gdb 排序与查找 栈和队列 进程 第 1 章 C 语言入门 编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。
C语言的语句和低级语言的指令之间不是简单的一一对应关系，需要由编译器（Compiler）来编译（Compile）才能翻译成机器指令。
C语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。
总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如program.c（通常C程序的文件名后缀是.c），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如a.out，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令。
第一个程序 在 vim 中打开一个空白的 main.c 文件，输入：
#include &amp;lt;stdio.h&amp;gt; /* main: generate some simple output */ int main(void) { printf(&amp;#34;Hello, world!</description></item><item><title>SQL入门</title><link>http://example.org/posts/2019/2019-10-08-sql-tutorial/</link><pubDate>Tue, 08 Oct 2019 17:44:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-10-08-sql-tutorial/</guid><description>SQL的简介
介绍 最近选修了一门 “数据库技术应用”，遂入门了数据库。下面大部分的内容摘自《MySQL 必知必会》，这本书很好，推荐大家去看看，我只讲部分重点内容：
创建数据库 检索数据 排序检索数据 过滤数据 正则表达式 插入数据 我是在 Linux 上安装 MySQL 来学习的，所以下面都是命令行的形式。
创建数据库 CREATE DATEBASE &amp;lt;数据库名&amp;gt;; 创建一个数据库。
CREATE DATABASE IF NOT EXISTS &amp;lt;数据库名&amp;gt; DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 创建数据库，该命令的作用：
如果数据库不存在则创建，存在则不创建。 创建RUNOOB数据库，并设定编码集为utf8 删除数据库 DROP DATABASE &amp;lt;数据库名&amp;gt;; 删除数据库。
选择数据库 USE &amp;lt;数据库名&amp;gt;; 选择数据库（即打开数据库）
创建数据表 CREATE TABLE &amp;lt;表名&amp;gt; (column_name column_type, ...); 创建数据表，括号里面可以指定多个列名（必需）、数据类型（必需）和约束条件，还可以指定主值、处理引擎、字符集等。比如：
CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; 删除数据表 DROP TABLE &amp;lt;表名&amp;gt; 检索数据 SELECT 语句 检索列 SELECT 列1，列2 FROM &amp;lt;表名&amp;gt; 检索所有列 SELECT * FROM &amp;lt;表名&amp;gt; * 是通配符，可以匹配多个名字</description></item><item><title>软件工程</title><link>http://example.org/posts/2019/2019-09-20-software-engineering/</link><pubDate>Fri, 20 Sep 2019 17:00:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-09-20-software-engineering/</guid><description>星期五晚上的软件工程的老师讲得没什么趣味，还讲得乱，我还不如自己学
以下为详细的复习要点，如果要简化版，可以看 软件工程（第三版）期末复习
考完感想：各种图是最重要的，同时要记一下各个英语的全拼，然后记一下结构化与面向对象的不同。这样应该可以考60分吧~
第一章 软件工程学概论 为什么要设立该学科？ 软件危机：
对软件开发成本和进度的估计常常很不准确 软件产品的质量达不到要求 用户对已完成的软件系统不满意 软件中没有适当的文档资料 软件成本在计算机系统总成本所占的比例逐年上升 软件开发生产率提高的速度不能满足需求的增长 什么是软件工程 有三个定义：
书上的：软件工程是指导计算机软件开发和维护的一门工程学科，采用工程的概念、原理、技术和法昂发来开发与维护软件，把经过时间考验证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它。这就是软件工程 NATO会议：建立并使用完善的工程化原则，以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法。 IEEE： 将系统化的、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件； 在1中所述方法的研究 从定义中，可以发现软件工程的特点：
软件工程关注大程序的构造 软件工程的中心课题是控制复杂性 软件交付使用后需要经常修改 开发软件的效率非常重要 软件工程方法学 软件工程方法学包含三个要素：方法、工具、过程
常用的方法学有：传统方法学、面向对象方法学
软件生命周期 软件生命周期可分为：
软件定义
问题定义：要解决什么问题？ 可行性研究：对上一个问题有可行的解决方法吗？ 需求分析：为了解决问题，目标系统必须做什么？ 软件开发
系统设计 总体设计：概要设计，提出抽象的解决方案 详细设计：将解决具体化，设计规格说明 系统实现 编码和单元测试：写出程序 综合测试：集成测试和验收测试 使用维护
改正性维护 适应性维护 完善性维护 预防性维护 软件过程 软件过程：为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。
瀑布模型 特点：
强调阶段的划分顺序与依赖：①前一工作完成后才开始后一工作；②前一工作的输出文档是后一工作的输入文档 推迟实现的观点； 质量保证的观点：每个阶段都必必须完成文档并进行评审 缺点：
获得完善的需求规约是非常困难的； 难以适应快速变化需求； 快速原型模型 特点：
快速原型模型是不带反馈环的，软件产品的开发基本上是按线性顺序进行的。 原型系统已经通过与用户交互而得到验证，据此产生的规格说明正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现了规格说明文档的错误而进行较大的返工。 开发人员通过建立原型系统已经学到了许多东西（至少知道了“系统不应该做什么，以及怎么不去做不该做的事情”），因此，在设计和编码阶段发生错误的可能性也比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。 缺点：
所选用的开发技术和工具不一定符合主流的发展；快速建立起来的系统结构加上连续的修改可能会导致产品质量低下。 增量模型 特点：
能在较短时间内向用户提交可完成一些有用的工作的产品 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。 缺点：</description></item><item><title>Arduino库之IRremote</title><link>http://example.org/posts/2019/2019-08-22-ir-remote/</link><pubDate>Thu, 22 Aug 2019 15:10:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-08-22-ir-remote/</guid><description>IRremote的wiki的中文翻译
介绍 IRremote 可以让你用标准的红外遥控器控制 Arduino，也可以用 Arduino 控制其他设备（电视、音箱等）
下载安装请见Arduino-IRremote github page
这份文档包括：
[TOC]
硬件设置 红外接收 IRremote 库可以使用任何一个数字信号引脚来接收 38kHz 红外接收模块的数据。这些模块自带了滤波和逻辑输出。不能直接用红外发射管和红外接收管。
红外发射 将红外发射管和适当大小的电阻连接到有PWM的 pin 3，并确保红外发射管极性正确。我已经用 NTE 3027 和 100 欧实验过（如上图），发射距离大概是4~5米。可以加多一个三极管来加大距离。
红外发射示例 下面这个是 Example -&amp;gt; IRremote -&amp;gt; IRsendDemo，它将控制索尼电视的开和关。需要将一个红外发射管连接到 pin 3.
#include &amp;lt;IRremote.h&amp;gt; IRsend irsend; void setup() { Serial.begin(9600); } void loop() { if (Serial.read() != -1) { for (int i = 0; i &amp;lt; 3; i++) { irsend.sendSony(0xa90, 12); // Sony TV power code delay(100); } } } 红外接收示例 接收并打印数据 下面这段代码将接收一个数据并通过串口打印出来，可以用于检测你的遥控器使用了什么数据格式。Example中还有一个更复杂的例子 IRrecvDump</description></item><item><title>天津旅游攻略</title><link>http://example.org/posts/2019/2019-08-22-tianjin-travel/</link><pubDate>Thu, 22 Aug 2019 14:33:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-08-22-tianjin-travel/</guid><description>&lt;blockquote>
&lt;p>本来计划去天津玩的，结果改成去成都，得，计划搁放这，到时候有时间，拿起背包就去。&lt;/p>
&lt;/blockquote></description></item><item><title>Bash入门</title><link>http://example.org/posts/2019/2019-08-11-bash-tutorial/</link><pubDate>Sun, 11 Aug 2019 15:49:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-08-11-bash-tutorial/</guid><description>Bash是 linux 默认的 Shell，这个文章会大致过一次 Bash的常用命令，满足日常 Linux 的使用。
ls ls 会展示当前目录的内容（文件和文件夹）。一般进入Bash后，所在的目录为当前用户的个人目录。（注：目录其实就是文件夹）
可以通过命令前面的字符知道当前是什么用户，比如在我的树莓派上，前面的字符为 pi@raspberry:~\$ ，pi为用户名，raspberry 为电脑名，~代表用户的个人目录，$表示当前用户为标准用户。
Linux 的目录结构与 windows 不同，它并不区分CDE盘，只用文件夹来区分。
ls 后面可以接选项：
ls [目录] 能显示指定目录的内容。 ls -a 显示隐藏文件（以 . 开头的文件） ls -l 显示详细信息 ls -la 显示全部文件的全部信息 pwd pwd 会展示当前在哪个目录（即显示当前目录的路径）
路径分为绝对路径与相对路径。绝对路径是完整的路径，从根开始；相对路径是省略的路径。它们的写法不同：
绝对路径
形如 /home/pi ，以斜杠 / 开头。
相对路径
有两种，如果直接以文件名开头（即无 / ），则前面省略的是当前目录。比如 当前在 /home/pi 目录，那么 相对路径 download 就相当于 /home/pi/download
如果是以 ~ 开头，则前面省略的是用户的个人目录。比如 当前是pi用户，相对路径 ~/download 就相当于 /home/pi/download
cd cd [目录] 可以改变当前目录，去到目标目录。
有个小技巧，输入目录或命令的前几个字母，然后按 Tab 就可以自动补全。如果有多个匹配，双击 Tab 可以查看匹配项。</description></item><item><title>成都旅游攻略</title><link>http://example.org/posts/2019/2019-08-07-chengdu-travel/</link><pubDate>Wed, 07 Aug 2019 17:55:29 +0800</pubDate><guid>http://example.org/posts/2019/2019-08-07-chengdu-travel/</guid><description>8月7~11日去成都玩，玩之前做了点调查，玩之后补充了点评价，遂成这篇攻略。
景点 宽窄巷子 地址：四川省成都市青羊区长顺街附近
介绍：
百度百科：由宽巷子、窄巷子、井巷子平行排列组成，全为青黛砖瓦的仿古四合院落，这里也是成都遗留下来的较成规模的清朝古街道，与大慈寺、文殊院一起并称为成都三大历史文化名城保护街区。宽窄巷子是国家AA级旅游景区，先后获2009年“中国特色商业步行街”、四川省历史文化名街、2011年成都新十景、四川十大最美街道 等称号。
评价：
去宽窄巷子，有什么是绝对不能错过的？ 知乎网友 爱吃肉的小橙子：
去宽窄巷子绝对不能错过的不是宽巷子、不是窄巷子也不是井巷子，而是隔壁的奎星楼、小通巷、泡桐树街。
奎星楼：你能吃到正宗的川菜、火爆成都的串串、绵阳特色冷沾沾、特色糍粑冰粉等等，在这条街随便一家馆子都不得踩雷！
小通巷：这条街是私房菜的天堂，日料、牛排、韩国烤肉都能吃到，当然最少不了的还是川菜啦！这条街的私房菜基本都需要提前预约才能吃上，至于吃什么？那就得看老板心情啦~
泡桐树街：这是成都最文艺的一条街，文青们的最爱。咖啡馆、甜品店、brunch是白天的模样，到了晚上这里又变身迷人的酒馆一条街，和朋友一起喝上一扎原浆，吹着夏夜的微风畅聊，这才是成都。
我自己Todd的评价：我订的民宿就在旁边的小区，走几分钟就到了，于是去了两次。到成都的第一天晚上去了宽巷子，人超级多，只能去远一点的地方吃饭（因而看到了很多穿汉服的妹子，好像是有什么活动吧）。基本上都是卖东西给游客的。第二天早上8点左右去井巷子吃了早餐，锅盔7块一个，有点贵（一般是5块），早上没什么人，很适合拍照。
武侯祠/武侯祠博物馆 地址：成都市武侯区武侯祠大街231号
开放时间：
夏季时段（5月1日至10月31日）开放时间为 8:00 至 20:00（19:00停止售票） 冬季时段（11月1日至4月30日）开放时间为 8:00 至 18:30（17:30停止售票） 门票：50元/人，学生半价
游玩时间：2 - 3小时
介绍：
蜀相 杜甫
丞相祠堂何处寻，锦官城外柏森森。 映阶碧草自春色，隔叶黄鹂空好音。 三顾频烦天下计，两朝开济老臣心。 出师未捷身先死，长使英雄泪满襟。
知乎：成都武侯祠，位于四川省成都市南门武侯祠大街，是中国唯一的君臣合祀祠庙，由武侯祠、汉昭烈庙及惠陵组成，人们习惯将三者统称为武侯祠。成都武侯祠始建于公元223年修建惠陵之时，其中，武侯祠建于唐以前，初与祭祀刘备的汉昭烈庙相邻，明朝初年重建时将武侯祠并入，形成了君臣合祀，祠堂与陵园合一的格局。除惠陵以外现存祠庙主体建筑为1672年清康熙年间复建。1961年成都武侯祠被国务院公布为第一批全国重点文物保护单位。1984年成立博物馆，2008年被评为首批国家一级博物馆，享有“三国圣地”之美誉。 成都武侯祠博物馆现分为三国历史遗迹区、西区、锦里民俗区三大板块，面积15万平方米。2006年武侯祠被评为国家AAAA级旅游景区，是全世界影响最大的三国遗迹博物馆。
相关网站：
都江堰官方网站 成都武侯祠官方网站 知乎：现在的成都武侯祠博物馆为什么通常上只被称作“武侯祠”而不是“汉昭烈庙”？ 新浪旅游：畅游成都武侯祠 诸葛亮殿 评价：
知乎网友 刘一只 ：一直说这武侯祠不是朝圣的话最好不去，因为人是真的多。又靠在锦里边上，好多人都喜欢下午逛武侯晚上锦里吃饭。
我自己Todd的评价：游客不算多也不算少。可以看看里面的古物，有很多明清时的塑像、石碑，有一块上面刻着前出师表，可以读一下。此外，就没什么看的了。如果去了武侯祠觉得一般般的话，就不要去杜甫草堂，杜甫草堂连古物都没有。
锦里 地址：四川省成都市武侯区武侯祠大街231号附1号（就在武侯祠附近）
开放时间：全天
门票：无
游玩时间：待定
介绍：
春熙路的“春熙”二字取自老子《道德经》——“众人熙熙，如享太牢，如登春台。”
百度百科：
锦里是成都武侯祠博物馆（三国历史遗迹区、锦里民俗区、西区）的一部分，占地30000余平方米，建筑面积14000余平方米，街道全长550米，以明末清初川西民居作外衣，三国文化与成都民俗作内涵，集旅游购物、休闲娱乐为一体。
传说中锦里曾是西蜀历史上最古老、最具有商业气息的街道之一，早在秦汉、三国时期便闻名全国。现在，锦里占地30000余平方米，建筑面积14000余平方米，街道全长550米，以明末清初川西民居作外衣，三国文化与成都民俗作内涵，集旅游购物、休闲娱乐为一体。
主要是 三国文化、酒吧、小吃、手工艺品
相关网站：
成都锦里古街官方网站 知乎：你可能去了一个假锦里，不信进来看 | 玩转成都 作者说晚上人比较少 马蜂窝 成都景点：锦里 知乎：成都锦里和宽窄巷子二选一哪个更好？ 评价：</description></item><item><title>Jupyter Notebook入门</title><link>http://example.org/posts/2019/2019-07-22-jupyter-notebook-tutorial/</link><pubDate>Mon, 22 Jul 2019 23:59:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-07-22-jupyter-notebook-tutorial/</guid><description>大致介绍一下 Jupyter Notebook 怎么用。
简介 The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.
官网的介绍巴拉巴拉一大串，其实 Jupyter Notebook （后面简称Jupyter）就是一个 Notebook 只不过这个 Notebook 比较厉害，它不但可以写字，还可以运行代码，还可以加图片、表格，所以非常适合用来学习代码或者编写文档。
官网提供了一个免费在线试用平台，不过由于使用的人较多，所以能不能登上全凭运气。如果能，可以看到它的界面是这样的：
安装 由于我有树莓派，再加之我比较喜欢保持电脑清爽，所以我将树莓派作为一个服务器，再通过电脑访问。你可以视自己的情况决定。
树莓派 先升级 pip ，否则会出现 unsupported operand types &amp;hellip;，逐个输入下面的命令：
wget https://bootstrap.pypa.io/get-pip.py python get-pip.</description></item><item><title>LaTeX入门</title><link>http://example.org/posts/2019/2019-07-20-latex-tutorial/</link><pubDate>Sat, 20 Jul 2019 16:15:17 +0800</pubDate><guid>http://example.org/posts/2019/2019-07-20-latex-tutorial/</guid><description>大致介绍一下 LaTeX怎么用。
数学符号大集
LaTeX简介 LaTeX是一种排版工具，与word不同，LaTeX的排版并不是“所见即所得”，而是依靠编码描述（类似于打代码），只有在最终生成时才可以看到效果。关于LaTeX的历史，我在此不赘述。
选择LaTeX的理由很简单：公式。Word对数学公式的支持不好，而LaTeX对公式的处理则优雅得多。
安装 为了确保我的伙伴与我使用的环境相同，我还是详细写一下我的安装方法。我使用的是 TexLive 包，先下载https://pan.baidu.com/s/1chu4I3DQhOTtVFcES2VVUg（提取码：t9io），下载完后，跟着这里说的做：https://liam.page/texlive
关于为什么用 TexLive，首先它支持Windows，Linux，Mac OS X，其次它支持中文，再其次它现在依然在维护，最后它安装方便。
基本 Hello, world! 打开 TexLive 自带的编辑软件 TexWorks editor，它的界面和记事本差不多，各个按钮都有中文解释，在此就不多说。
在界面中输入如下内容（即图片中的内容）：
%第一个LaTeX文档 \documentclass{article} \begin{document} Hello, world! \end{document} 然后按左上的三角形按钮，就会生成 pdf 并在右边显示。
看起来也不是很难嘛（和编程差不多）。下面说说各语句的意思：
以反斜杠“ \ ”开头的那串东西是 LaTeX 的控制序列（也称命令/标记），用于控制输出效果。
控制序列中间不能有空格；
控制序列的必要参数用 { } 包围，可选参数用 包围；
LaTeX对控制序列的大小写敏感；
注释前面用%，%后面的文字会被忽略
要正常输入%，需要输入%，这个和 python 的转义字符相同 \documentclass[arg1,arg2,...]{arg} 用于指定该文档的布局。
必要参数用于指定文档类型，可选： article：用于学术期刊、编程文档等单篇文章 proc：基于article的一种类型 minimal：最小的类型，只规定了页面大小和字体 book：用于真实的书 slide：幻灯片 memoir：基于book的一种类型 letter：用于信件 beamer：用于presentations 非必要参数之间用 “ , ” 隔开，可有： 纸张大小：letterpaper,``legalpaper，a4paper，a5paper，b5paper` 字体：12pt（数字可变） 将每页分为两边显示：twocolumn \documentclass{} 到 \begin{document} 之间的区域为导言区，用于对整篇文档进行设置。上面并没导言区，但我们很快就要用到。</description></item><item><title>对C++I/O库的整理</title><link>http://example.org/posts/2019/2019-05-31-summary-io-of-c++/</link><pubDate>Fri, 31 May 2019 15:19:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-05-31-summary-io-of-c++/</guid><description>本想着应付考试，然而考试并没有考。
基本的I/O类库与对象 iostream
istream、wistream从流读取数据 ostream、wostream向流中写入数据 iostream、wiostream读写流 fstream
ifstream、wifstream从文件读取数据 ofstream、wofstream向文件写入数据 fstream、wfstream读写文件 sstream
istringstream、wistringstream从string读取数据 ostringstream、wostringstream向string写入数据 stringstream、wstringstream读写string iomanip：用于指定输入输出流的格式
为了支持宽字符的语言（即wchar_t类型），io库定义了以w开头的一组类型和对象，比如wcin、wcout分别对应cin、cout。这些用起来和普通字符没什么不同，后面我们就以普通字符为例子。
IO类型间的关系 IO类型之间存在继承的关系。如下
当然，实际上的继承关系远比这复杂。要了解更多，可以看回课本。
正是因为有了上面的继承关系，一些用于istream、ostream的操作，比如&amp;lt;&amp;lt;、&amp;gt;&amp;gt;也可以用于ifstream、istringstream、ofstream、ostringstream
IO对象无拷贝或赋值 **IO对象无拷贝或赋值！**所以我们不能用=对流赋值或拷贝，也不能在函数中使用流参数或返回流，只能使用或返回流的引用或指针。这点格外要注意。
流状态 由于IO可能发生错误，我们需要一些标志和函数标记或检测流状态。
标志 ios类中，有一个数据成员，其每一位都对应一种错误状态，称为状态字。具体如下
标识常量 值 含义 goodbit 0x00 状态正常 eofbit 0x01 文件结束 failbit 0x02 IO操作失败，但数据未丢失，可恢复 badbit 0x04 流崩溃，数据丢失，不可恢复 使用时，记得格式是ios::goodbit，当然，直接用值也行，就是不那么好记。
检查与设置 以下函数用于检查流状态：
istream &amp;amp;s=cin; //检查是否为eofbit，是则返回1，否则返回0 s.eof(); //检查是否为failbit或badbit，是则返回1，否则返回0 s.fail(); !s; //检查是否为badbit，是则返回1，否则返回0 s.bad(); //检查是否为goodbit，是则返回1，否则返回0 s.good(); *s; //返回状态字 s.rdstate(); 以下函数用于设置流状态（都是返回void）：
//复位所有状态位，并将流状态设为有效 s.clear(); //复位所有状态位，并将流状态设为标识常量flags s.clear(flags) //单纯地将flags的对应位设为1，并不会清除其他状态 s.setstate(flags) 关于最后两个函数的区别可以看：clear与setstate的区别
缓冲 输出流都有一个缓冲区，用来保存程序读写的数据，并直到缓冲区刷新时才写到输出设备或文件。缓冲刷新的时机为：
程序正常结束，main函数的return操作会执行缓冲刷新。</description></item><item><title>对C++模板的整理</title><link>http://example.org/posts/2019/2019-05-30-summary-template-of-c++/</link><pubDate>Thu, 30 May 2019 20:43:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-05-30-summary-template-of-c++/</guid><description>模板真的是绕晕我了……
函数模板 定义函数模板 普通的函数只能接受指定类型的参数，比如我们定义一个int compare(int, int);来比较大小，则我们只能比较两个整型的大小，如果需要比较浮点数的大小，则需要重新写一个新的函数，但新的函数和原函数做的事情其实是一样的。为了提高代码的复用率，故需要用模板。
我们可以定义一个这样的模板：
template &amp;lt;typename T&amp;gt; int compare(const T &amp;amp;a,const T &amp;amp;b){ if(a&amp;lt;b)return -1; if(a&amp;gt;b)return 1; return 0; } 第一行以关键字template开始，后面跟着模板参数列表&amp;lt;typename T1, typename T2, ...&amp;gt;（旧的C++标准用&amp;lt;class T1, class T2, ...&amp;gt;，class和typename可以混用），每个T表示一种类型。
函数模板和普通函数一样可以重载，并且我们既可以用另一个模板来重载它，也可以用普通函数来重载它。比如：
template &amp;lt;typename T&amp;gt; int compare(const T *a, const T *b){ if(*a&amp;lt;*b)return -1; if(*a&amp;gt;*b)return 1; return 0; } 顺便说一句，inline和constexpr跟在模板参数列表后面。
实例化函数模板 函数模板用起来和普通的函数一样：
compare(1, 0); 编译器会根据实参来实例化一个特定版本的函数int compare(const int&amp;amp;, const int&amp;amp;)、
模板参数 类型模板参数 类型模板参数就是我们上面的那种模板参数：
template &amp;lt;typename T1, typename T2&amp;gt; T1、T2称为类型参数，我们可以把它当作类型说明符，就像内置类型一样使用，特别是，它可以用为返回类型、参数类型、函数内的变量声明和类型转换。</description></item><item><title>对C++类的整理(3)——继承</title><link>http://example.org/posts/2019/2019-05-28-summary-class-of-c++/</link><pubDate>Tue, 28 May 2019 20:04:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-05-28-summary-class-of-c++/</guid><description>派生与继承是一对好兄弟
考点：类与类之间有三种关系：has-a、uses-a和is-a。has-a表示一个类是另一个类的数据成员；uses-a表示一个类使用另一个类的函数或对象；is-a表示继承。用有向无环图（DAG）表示类之间的继承关系，称为类格，前驱结点称为基类，后继节点称为派生类。
基类和派生类的关系 之前的类都是独立的类，而通过继承我们可以将类联系起来，构成一种层次关系。位于底层的叫基类，继承得到的类叫派生类。我们可以“一继承一”，“一继承多”，“一派生多”，总之这种派生关系是没限制的。如果你不想某个类用作基类，可以在类名后面加上final
定义派生类 派生类通过基类名表（类派生列表）指出它是从哪些基类派生而来的，其基本格式为：[访问控制] 基类名1, [访问控制] 基类名2, ...，访问控制和访问说明符一样，有三种：private、protected和public，省略的话，stuct默认为public，class默认为private，这是它们唯二的区别。
class Base;//基类 class Derived: Base{ //成员 } 访问控制和继承 派生类的成员有两部分组成：自己的和继承的。自己的成员受访问说明符控制，而继承的那部分受 基类的访问说明符 和 基类名表的访问控制符 控制。具体如下：
先看基类的访问说明符： private：只能在基类中访问，派生类和（任何）外部无法访问 protected：能在基类、派生类中访问，（任何）外部无法访问 public：能在基类、派生类中访问，（基类）外部可以访问，（派生类）外部要看下面一部分 再看继承时的访问描述符 private：继承的来的成员，除基类中的private部分外，全部属于派生类的private。（外部无法访问） protected：继承的来的成员，除基类中的private部分外，全部属于派生类的protected。（外部无法访问） public：继承的来的成员，除基类中的private部分外，基类中的protected部分属于派生类的protected，基类中的public部分属于派生类的public。 （注意，外部指的是类的用户）
派生类会继承基类中的以下部分：
基类中private、protected和public的一般的数据成员和成员函数 虚函数 派生类不会继承基类的以下部分：
友元声明：友元声明永远只对做出声明的类有效 静态成员：静态成员在整个类体系（基类和派生类）中被共享 改变个别成员的访问性 特别的，我们可以单独地改变某些成员的访问控制，称为访问声明。格式为基类名::成员，比如：
class Base{ public: int a; }; class Derived: private Base{ public: Base::a;//外部可以访问 //也可以这样写 using Base::a;//见Primer 546 }; 注意：
访问声明不能带任何类型说明（数据成员），或参数和返回类型声明（成员函数） 访问声明只能用于基类中的非private部分，基类的私有成员不能用访问声明 访问声明不能降低基类成员的可访问性（这条有问题，但考试还是当它对） 访问声明作用于所有同名函数（重载函数），因此，同名函数位于基类的不同访问域时，无法用访问声明 若派生类中存在与基类名字相同的成员，则不能用访问声明 类作用域 派生类的作用域嵌套在基类里面（想象几个同心圆）。当要查找某个数据成员或成员函数时，编译器先从内部查找，若不存在，再到外部查找。也就是说，如果派生类中存在与基类同名的成员，则派生类的成员将“隐藏”基类的成员，但我们依然可以通过类名::成员的方式显式地使用基类的成员。
实际上，类名::成员的方式是让编译器从指定类开始找，而非内部，这点在多层继承时要注意。
注意，只要名字相同，就会隐藏基类成员；就算同名而参数不同，也会隐藏！！！ 如果想要隐藏某个，而不隐藏某个，可以使用using。参照上面的“改变个别成员的访问性”那一节。
多继承和虚继承 派生类可以继承多个基类，这种继承是没有任何限制的，你甚至可以C继承B和A，同时B又继承A，这种情况下，C实际上有两个A部分，使用时要分清类作用域。</description></item><item><title>对C++类的整理(2)——运算符重载</title><link>http://example.org/posts/2019/2019-05-23-summary-class-of-c++/</link><pubDate>Thu, 23 May 2019 22:04:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-05-23-summary-class-of-c++/</guid><description>简单整理一下运算符重载的相关知识
基本概念 重载运算符是一种特殊的函数，使得类可以依靠运算符进行特点的操作。它的定义形式如下：
//声明为成员函数 [类型] [类名]::operator[运算符]( [参数表] ){ //操作 } //声明为非成员函数 [类型] operator[运算符]( [类名],[参数表] ){ //操作 } 参数的数量与该运算符作用的运算对象数量一样多 若运算符函数是成员函数，则它左侧（第一个）运算对象绑定到this指针上，故它的（显式）参数数量要少一个 运算符函数要么是类成员，要么含有一个类类型的参数 重载不改变运算符的优先级和结合律，也不能改变所需的操作数 有五个运算符不能被重载：::，.*，。，?:、sizeof。而有两个不应该被重载：,，&amp;amp;（取地址），&amp;amp;&amp;amp;（逻辑与），||（逻辑或），因为它们有特殊含义。（注：new和delete是可以被重载的！）
大部分重载函数可以是类的成员函数，也可以是友元函数。只有小部分只能是成员函数：=、()、[]、-&amp;gt;。
成员or非成员 对于声明为成员函数还是友元函数，应遵循以下原则：
赋值=、下标[]、调用()、成员访问箭头-&amp;gt;运算符必须是成员函数 具有对称性的运算符应该是非成员（比如加减乘除、相等性、关系、位运算符） 改变对象状态的运算符应该是成员（比如递增、递减、解引用） 具体的运算符 输入输出运算符(&amp;laquo;、&amp;raquo;) 考虑&amp;lt;&amp;lt;的使用方法：cout&amp;lt;&amp;lt;类类型，所以第一个对象是ostream，第二个对象是我们的类，故我们声明为非成员函数，并且声明为类的友元：
class Sales_data{ private: std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; public: friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;, const Sales_data); }; 由于ostream无法被复制，所以它的形参和返回值都是引用；而由于我们一般不改变类的数据，所以类用const修饰。
考虑&amp;gt;&amp;gt;的用法：cin&amp;gt;&amp;gt;类类型，所以第一个对象为istream，第二个对象是我们的类，故和&amp;lt;&amp;lt;的重载方法差不多：
class Sales_data{ private: std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; public: friend istream&amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;, Sales_data &amp;amp;); }; 同样，istream不能被复制，故形参和返回值也都是引用；而我们需要改变原类类型的值，故类的形参是引用。特别的，我们在定义输入重载函数时，需要考虑输入失败的情况，并要从失败中恢复，并将流状态设置为failbit（见《C++ Pimer》496页）</description></item><item><title>对C++类的整理(1)——类基础</title><link>http://example.org/posts/2019/2019-04-20-summary-class-of-c++/</link><pubDate>Sat, 20 Apr 2019 21:03:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-04-20-summary-class-of-c++/</guid><description>想象我们经营一家书店，需要对每本书的销售数据进行统计，我们将编写一个Sales_data，来完成这件事，并过一次类的基础知识。
类的简介 类的本质上是一种自定义的数据类型，它基本组成为(D, S, P)，D为数据对象，S为D上的关系集，P为对D的基本操作。简单来讲，就是：类=数据+操作。
类的声明以关键字struct开始（也可以用class，区别后面会讲。），紧跟着类名和类体（类体可为空）：
struct Sales_data{ //类体 }; //不要漏了分号！ 每个类内部是一个新的作用域，所以其内部定义的名字可以和外部重复。
数据成员 类内数据的定义方法和类外相同，比如我们的销售数据要有每本书的编号bookNo，卖出的数量units_sold，收到的钱revenue。如下
struct Sales_data{ std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } 我们可以为数据成员提供初始值（就像上面的units_sold和revenue）,没有初始值的成员将被默认初始化（如bookNo将为空字符串）。
如果要在类外使用数据成员，只需在类类型后面加“.变量”：
Sales_data data1; cout&amp;lt;&amp;lt;data1,revenue&amp;lt;&amp;lt;std::endl; //输出0.0 成员函数 成员函数的声明在类内，定义则可以在类内或内外（如果在类内，则自动是内联的），在内外定义时要指明函数的作用域（因为类本身就是一个作用域）。比如我们给销售数据类加点东西：
struct Sales_data{ std::string isbn() const {return bookNo;}//返回isbn码 //类内声明+定义 double avg_price() const;//返回平均售价 //类内声明，注意不要忘了&amp;#34;;&amp;#34; //下面的是数据成员 std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } double Sales_data::avg_price() const{//类外定义，注意不要忘了&amp;#34;::&amp;#34; if (units_sold) return revenue/units_sold; else return 0; } this 指针 调用成员函数时，用类名.</description></item><item><title>树莓派初始配置及软件安装</title><link>http://example.org/posts/2019/2019-03-30-set-up-raspberrypi/</link><pubDate>Sat, 30 Mar 2019 09:29:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-03-30-set-up-raspberrypi/</guid><description>树莓派安装完系统后，总是需要设置一堆东西，然后还要安装各种软件，等等。而且我经常把树莓派玩坏&amp;hellip;&amp;hellip;重装系统是常有的事。我受够了每次都要上网查一堆资料，下面我将总结一下所有东西。
基本设置 第一次开机 我的树莓派是3B/3B+，系统为2018-11-13-raspbian-stretch.img，就是带桌面但没那么多软件那个。烧录系统只需要10分钟。（最新的系统是buster，有些内容不兼容）
第一次开机时间有点久。进入桌面后，先设置Country(China)，Language(Chinese)，Timezone(Shanghai)，勾选Use US keyboard。接着输入‘pi’用户新的密码。然后连接WiFi。不要更新软件，更新的话时间有点久，而且容易出错，跳过。
重启。
树莓派现在对中文支持较好，重启后并不会出现中文乱码。赞！
换源&amp;amp;更新 Stretch 众所周知，树莓派官方软件源在中国很慢，所以要换源。编辑软件源list文件：
sudo nano /etc/apt/sources.list 注释官方源，然后在下面选一个输进去：
#清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi #中国科技大学 deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi #阿里云 deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi deb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi 修改系统更新源：
sudo nano /etc/apt/sources.list.d/raspi.list 同样，注释掉官方源，换成下面这个：
#中国科技大学 deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui 然后执行：</description></item><item><title>Arduino与I2C总线协议</title><link>http://example.org/posts/2019/2019-03-18-i2c-bus/</link><pubDate>Mon, 18 Mar 2019 22:16:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-03-18-i2c-bus/</guid><description>为了参加学院的电信杯，好好学一下 I2C
I2C总线协议入门 I2C总线协议（ 全称：Inter Integrated Circuit，又叫 I^2^C，IIC）是一种连接低速设备的通信协议，是由 Philips 在80年代设计的。它有如下几个优点：
只需要两条数据线； 没有严格的波特率（baud rate）限制 主/从关系简单 多主控，但任何时间点只能有一个主控。 缺点也有：
传输速度比SPI慢 每个数据字节都只能是8位 硬件要求比SPI更高 硬件结构 下面这幅图展示了单个主/从机之间的电路连接：
VCC 为I2C提供电压，范围为1.2V~5.5V GND 共地接线 SDA Serial data 串行数据（I2C 数据线） SCL Serial clock 串行时钟（I2C 时钟线） Rp 上拉电阻（大小计算可参考SLVA689） Rs 串口电阻 Cp Wire Caoacitance 线间电容 Cc Cross channel capacitance 路间电容 对于多个主/从机，可以这样连接：
下面重点讲一下双向通信的开漏结构（Open-Drain for Bidirectional Communication），这能帮助我们了解为什么同一时间只允许一个主控。请看结构图：
主/从机可以让晶体管的导通（开漏），让SDA/SCL线的电压拉低；当主/从机让晶体管不导通时，上拉电阻会将SDA/SCL线上的电压拉高。也就是说，主/从机只能让SDA/SCL为0，当主/从机不控制时，SDA/SCL为1。因此，永远不会出现一个从机传输0，另一个从机传输1的情况，即同一时间只能有一个设备在传输数据。
这种结构虽然效率较低，但其驱动电流/电压较小，很适合驱动能力差的微处理器和传感器。
I2C操作 I2C可以在主/从机之间的双向通信。为了分辨每个设备，每个设备都有一个独一的地址，这样主机就能通过地址和指定的从机通信。下面是一个大概的流程：
假如主机想要给从机发送数据： 主机发送起始条件和从机寄存器的地址 主机发送数据 主机发送终止条件 假如主机想要接收读取从机数据： 主机发送起始条件和从机寄存器地址 主机发送读指令 主机从从机接收数据 主机发送终止条件 下面我们来详细讲解一下。
起始条件和终止条件 开始条件：当SCL为高电平时，SDA从高电平变为低电平；终止条件：当SCL为高电平时，SDA从低电平变为高电平。</description></item><item><title>Arduino与I2C总线协议</title><link>http://example.org/posts/2019/2019-03-23-u8glib.md/</link><pubDate>Mon, 18 Mar 2019 22:16:00 +0800</pubDate><guid>http://example.org/posts/2019/2019-03-23-u8glib.md/</guid><description>为了参加学院的电信杯，好好学一下 I2C
I2C总线协议入门 I2C总线协议（ 全称：Inter Integrated Circuit，又叫 I^2^C，IIC）是一种连接低速设备的通信协议，是由 Philips 在80年代设计的。它有如下几个优点：
只需要两条数据线； 没有严格的波特率（baud rate）限制 主/从关系简单 多主控，但任何时间点只能有一个主控。 缺点也有：
传输速度比SPI慢 每个数据字节都只能是8位 硬件要求比SPI更高 硬件结构 下面这幅图展示了单个主/从机之间的电路连接：
VCC 为I2C提供电压，范围为1.2V~5.5V GND 共地接线 SDA Serial data 串行数据（I2C 数据线） SCL Serial clock 串行时钟（I2C 时钟线） Rp 上拉电阻（大小计算可参考SLVA689） Rs 串口电阻 Cp Wire Caoacitance 线间电容 Cc Cross channel capacitance 路间电容 对于多个主/从机，可以这样连接：
下面重点讲一下双向通信的开漏结构（Open-Drain for Bidirectional Communication），这能帮助我们了解为什么同一时间只允许一个主控。请看结构图：
主/从机可以让晶体管的导通（开漏），让SDA/SCL线的电压拉低；当主/从机让晶体管不导通时，上拉电阻会将SDA/SCL线上的电压拉高。也就是说，主/从机只能让SDA/SCL为0，当主/从机不控制时，SDA/SCL为1。因此，永远不会出现一个从机传输0，另一个从机传输1的情况，即同一时间只能有一个设备在传输数据。
这种结构虽然效率较低，但其驱动电流/电压较小，很适合驱动能力差的微处理器和传感器。
I2C操作 I2C可以在主/从机之间的双向通信。为了分辨每个设备，每个设备都有一个独一的地址，这样主机就能通过地址和指定的从机通信。下面是一个大概的流程：
假如主机想要给从机发送数据： 主机发送起始条件和从机寄存器的地址 主机发送数据 主机发送终止条件 假如主机想要接收读取从机数据： 主机发送起始条件和从机寄存器地址 主机发送读指令 主机从从机接收数据 主机发送终止条件 下面我们来详细讲解一下。
起始条件和终止条件 开始条件：当SCL为高电平时，SDA从高电平变为低电平；终止条件：当SCL为高电平时，SDA从低电平变为高电平。</description></item></channel></rss>